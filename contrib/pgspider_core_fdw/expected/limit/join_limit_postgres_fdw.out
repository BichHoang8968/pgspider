\set ECHO none
SET datestyle = ISO;
SET timezone = 'UTC';
CREATE EXTENSION pgspider_core_fdw;
CREATE SERVER pgspider_core_svr FOREIGN DATA WRAPPER pgspider_core_fdw OPTIONS (host :PGSPIDER_CORE_HOST);
CREATE USER MAPPING FOR CURRENT_USER SERVER pgspider_core_svr;
CREATE EXTENSION postgres_fdw;

CREATE FOREIGN TABLE J1_TBL ( i integer, j integer, t text, __spd_url text) SERVER pgspider_core_svr;
CREATE FOREIGN TABLE J2_TBL ( i integer, k integer, __spd_url text) SERVER pgspider_core_svr;
CREATE FOREIGN TABLE J3_TBL ( i integer, t text, __spd_url text) SERVER pgspider_core_svr;
CREATE SERVER postgres_svr FOREIGN DATA WRAPPER postgres_fdw OPTIONS (host :POSTGRES_HOST_JOIN, port :POSTGRES_PORT_JOIN);
CREATE USER MAPPING FOR CURRENT_USER SERVER postgres_svr OPTIONS(user :POSTGRES_USER, password :POSTGRES_PASS);

CREATE FOREIGN TABLE J1_TBL__postgres_svr__0 ( i integer, j integer, t text) SERVER postgres_svr OPTIONS (table_name 'j1_tbl');
CREATE FOREIGN TABLE J2_TBL__postgres_svr__0 ( i integer, k integer) SERVER postgres_svr OPTIONS (table_name 'j2_tbl');
CREATE FOREIGN TABLE J3_TBL__postgres_svr__0 ( i integer, t text) SERVER postgres_svr OPTIONS (table_name 'j3_tbl');

\i sql/limit/join_limit.sql
--Pattern 2
--Join  with WHERE __spd_url + ORDER BY
--Testcase 1:
EXPLAIN VERBOSE SELECT J1_TBL.i, J1_TBL.j, J1_TBL.t FROM J1_TBL CROSS JOIN J2_TBL WHERE J1_TBL.__spd_url != '23afw' ORDER BY 1, 2, 3;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=100.00..246.52 rows=11648569 width=40)
   Output: j1_tbl.i, j1_tbl.j, j1_tbl.t
   ->  Foreign Scan on public.j1_tbl  (cost=0.00..0.00 rows=1 width=40)
         Output: j1_tbl.i, j1_tbl.j, j1_tbl.t
         Filter: (j1_tbl.__spd_url <> '23afw'::text)
         Node: postgres_svr / Status: Alive
           Sort push-down: yes
           Remote SQL: SELECT i, j, t FROM public.j1_tbl ORDER BY i ASC NULLS LAST, j ASC NULLS LAST, t ASC NULLS LAST
   ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=0)
         Node: postgres_svr / Status: Alive
           Sort push-down: no
           Remote SQL: SELECT NULL FROM public.j2_tbl
(12 rows)

--Testcase 2:
SELECT J1_TBL.i, J1_TBL.j, J1_TBL.t FROM J1_TBL CROSS JOIN J2_TBL WHERE J1_TBL.__spd_url != '23afw' ORDER BY 1, 2, 3;
 i | j |   t   
---+---+-------
 0 |   | zero
 0 |   | zero
 0 |   | zero
 0 |   | zero
 0 |   | zero
 0 |   | zero
 0 |   | zero
 0 |   | zero
 1 | 4 | one
 1 | 4 | one
 1 | 4 | one
 1 | 4 | one
 1 | 4 | one
 1 | 4 | one
 1 | 4 | one
 1 | 4 | one
 2 | 3 | two
 2 | 3 | two
 2 | 3 | two
 2 | 3 | two
 2 | 3 | two
 2 | 3 | two
 2 | 3 | two
 2 | 3 | two
 3 | 2 | three
 3 | 2 | three
 3 | 2 | three
 3 | 2 | three
 3 | 2 | three
 3 | 2 | three
 3 | 2 | three
 3 | 2 | three
 4 | 1 | four
 4 | 1 | four
 4 | 1 | four
 4 | 1 | four
 4 | 1 | four
 4 | 1 | four
 4 | 1 | four
 4 | 1 | four
 5 | 0 | five
 5 | 0 | five
 5 | 0 | five
 5 | 0 | five
 5 | 0 | five
 5 | 0 | five
 5 | 0 | five
 5 | 0 | five
 6 | 6 | six
 6 | 6 | six
 6 | 6 | six
 6 | 6 | six
 6 | 6 | six
 6 | 6 | six
 6 | 6 | six
 6 | 6 | six
 7 | 7 | seven
 7 | 7 | seven
 7 | 7 | seven
 7 | 7 | seven
 7 | 7 | seven
 7 | 7 | seven
 7 | 7 | seven
 7 | 7 | seven
 8 | 8 | eight
 8 | 8 | eight
 8 | 8 | eight
 8 | 8 | eight
 8 | 8 | eight
 8 | 8 | eight
 8 | 8 | eight
 8 | 8 | eight
   | 0 | zero
   | 0 | zero
   | 0 | zero
   | 0 | zero
   | 0 | zero
   | 0 | zero
   | 0 | zero
   | 0 | zero
   |   | null
   |   | null
   |   | null
   |   | null
   |   | null
   |   | null
   |   | null
   |   | null
(88 rows)

--Testcase 3:
EXPLAIN VERBOSE SELECT J1_TBL.i, J1_TBL.j, J1_TBL.t FROM J1_TBL INNER JOIN J2_TBL USING (i) AS x WHERE J1_TBL.__spd_url != 'ffff' ORDER BY J1_TBL.i;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Nested Loop  (cost=0.00..0.01 rows=58243 width=40)
   Output: j1_tbl.i, j1_tbl.j, j1_tbl.t
   Join Filter: (j1_tbl.i = j2_tbl.i)
   ->  Foreign Scan on public.j1_tbl  (cost=0.00..0.00 rows=1 width=40)
         Output: j1_tbl.i, j1_tbl.j, j1_tbl.t
         Filter: (j1_tbl.__spd_url <> 'ffff'::text)
         Node: postgres_svr / Status: Alive
           Sort push-down: yes
           Remote SQL: SELECT i, j, t FROM public.j1_tbl ORDER BY i ASC NULLS LAST
   ->  Foreign Scan on public.j2_tbl  (cost=0.00..0.00 rows=1 width=4)
         Output: j2_tbl.i
         Node: postgres_svr / Status: Alive
           Sort push-down: yes
           Remote SQL: SELECT i FROM public.j2_tbl ORDER BY i ASC NULLS LAST
(14 rows)

--Testcase 4:
SELECT J1_TBL.i, J1_TBL.j, J1_TBL.t FROM J1_TBL INNER JOIN J2_TBL USING (i) AS x WHERE J1_TBL.__spd_url != 'ffff' ORDER BY J1_TBL.i;
 i | j |   t   
---+---+-------
 0 |   | zero
 1 | 4 | one
 2 | 3 | two
 2 | 3 | two
 3 | 2 | three
 5 | 0 | five
 5 | 0 | five
(7 rows)

--Testcase 5:
EXPLAIN VERBOSE SELECT t1.a, t1.b, t1.c, t2.a, t2.b FROM J1_TBL t1 (a, b, c, d) FULL JOIN J2_TBL t2 (a, b, d) USING (b) WHERE t1.d IS NOT NULL ORDER BY t1.a, t2.a;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Sort  (cost=6325.94..6471.55 rows=58243 width=48)
   Output: t1.a, t1.b, t1.c, t2.a, t2.b
   Sort Key: t1.a, t2.a
   ->  Merge Left Join  (cost=825.36..1716.07 rows=58243 width=48)
         Output: t1.a, t1.b, t1.c, t2.a, t2.b
         Merge Cond: (t1.b = t2.b)
         ->  Sort  (cost=412.68..421.21 rows=3413 width=40)
               Output: t1.a, t1.b, t1.c
               Sort Key: t1.b
               ->  Foreign Scan on public.j1_tbl t1  (cost=100.00..212.39 rows=3413 width=40)
                     Output: t1.a, t1.b, t1.c
                     Filter: (t1.d IS NOT NULL)
                     Node: postgres_svr / Status: Alive
                       Sort push-down: no
                       Remote SQL: SELECT i, j, t FROM public.j1_tbl
         ->  Sort  (cost=412.68..421.21 rows=3413 width=8)
               Output: t2.a, t2.b
               Sort Key: t2.b
               ->  Foreign Scan on public.j2_tbl t2  (cost=100.00..212.39 rows=3413 width=8)
                     Output: t2.a, t2.b
                     Node: postgres_svr / Status: Alive
                       Sort push-down: no
                       Remote SQL: SELECT i, k FROM public.j2_tbl
(23 rows)

--Testcase 6:
SELECT t1.a, t1.b, t1.c, t2.a, t2.b FROM J1_TBL t1 (a, b, c, d) FULL JOIN J2_TBL t2 (a, b, d) USING (b) WHERE t1.d IS NOT NULL ORDER BY t1.a, t2.a;
 a | b |   c   | a | b 
---+---+-------+---+---
 0 |   | zero  |   |  
 1 | 4 | one   | 2 | 4
 2 | 3 | two   |   |  
 3 | 2 | three | 2 | 2
 4 | 1 | four  |   |  
 5 | 0 | five  |   | 0
 6 | 6 | six   |   |  
 7 | 7 | seven |   |  
 8 | 8 | eight |   |  
   |   | null  |   |  
   | 0 | zero  |   | 0
(11 rows)

--Join  with WHERE __spd_url + aggregate function + GROUP BY + LIMIT
--Testcase 7:
EXPLAIN VERBOSE SELECT count(J1_TBL.i), sum(J1_TBL.j), J1_TBL.t FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k != 1 AND J1_TBL.__spd_url IS NOT NULL) GROUP BY J1_TBL.t LIMIT 5;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Limit  (cost=100.00..114.99 rows=5 width=48)
   Output: (count(j1_tbl.i)), (sum(j1_tbl.j)), j1_tbl.t
   ->  GroupAggregate  (cost=100.00..699.68 rows=200 width=48)
         Output: count(j1_tbl.i), sum(j1_tbl.j), j1_tbl.t
         Group Key: j1_tbl.t
         ->  Nested Loop  (cost=100.00..263.03 rows=57953 width=40)
               Output: j1_tbl.t, j1_tbl.i, j1_tbl.j
               Join Filter: (j1_tbl.i = j2_tbl.i)
               ->  Foreign Scan on public.j1_tbl  (cost=0.00..0.00 rows=1 width=40)
                     Output: j1_tbl.i, j1_tbl.j, j1_tbl.t
                     Filter: (j1_tbl.__spd_url IS NOT NULL)
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Remote SQL: SELECT i, j, t FROM public.j1_tbl ORDER BY t ASC NULLS LAST
               ->  Foreign Scan on public.j2_tbl  (cost=100.00..220.58 rows=3396 width=4)
                     Output: j2_tbl.i
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Remote SQL: SELECT i, k FROM public.j2_tbl WHERE ((k <> 1))
(19 rows)

--Testcase 8:
SELECT count(J1_TBL.i), sum(J1_TBL.j), J1_TBL.t FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k != 1 AND J1_TBL.__spd_url IS NOT NULL) GROUP BY J1_TBL.t LIMIT 5;
 count | sum |   t   
-------+-----+-------
     2 |   0 | five
     1 |   4 | one
     1 |   2 | three
     2 |   6 | two
(4 rows)

--Testcase 9:
EXPLAIN VERBOSE SELECT avg(J2_TBL.i) + 91, min(J2_TBL.k) FROM J1_TBL RIGHT JOIN J2_TBL USING (i) WHERE (i = 1 OR J2_TBL.__spd_url = '/influx') GROUP BY J2_TBL.i LIMIT 5;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Limit  (cost=100.00..114.87 rows=5 width=40)
   Output: ((avg(j2_tbl.i) + '91'::numeric)), (min(j2_tbl.k)), j2_tbl.i
   ->  GroupAggregate  (cost=100.00..694.88 rows=200 width=40)
         Output: (avg(j2_tbl.i) + '91'::numeric), min(j2_tbl.k), j2_tbl.i
         Group Key: j2_tbl.i
         ->  Nested Loop Left Join  (cost=100.00..255.05 rows=58243 width=8)
               Output: j2_tbl.i, j2_tbl.k
               Join Filter: (j1_tbl.i = j2_tbl.i)
               ->  Foreign Scan on public.j2_tbl  (cost=0.00..0.00 rows=1 width=8)
                     Output: j2_tbl.i, j2_tbl.k
                     Filter: ((j2_tbl.i = 1) OR (j2_tbl.__spd_url = '/influx'::text))
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Remote SQL: SELECT i, k FROM public.j2_tbl ORDER BY i ASC NULLS LAST
               ->  Foreign Scan on public.j1_tbl  (cost=100.00..212.39 rows=3413 width=4)
                     Output: j1_tbl.i
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Remote SQL: SELECT i FROM public.j1_tbl
(19 rows)

--Testcase 10:
SELECT avg(J2_TBL.i) + 91, min(J2_TBL.k) FROM J1_TBL RIGHT JOIN J2_TBL USING (i) WHERE (i = 1 OR J2_TBL.__spd_url = '/influx') GROUP BY J2_TBL.i LIMIT 5;
        ?column?         | min 
-------------------------+-----
 92.00000000000000000000 |  -1
(1 row)

--Testcase 11:
EXPLAIN VERBOSE SELECT t1.i, min(j), t3.t FROM J1_TBL t1 FULL JOIN J2_TBL t2 ON t1.i = t2.i LEFT JOIN J3_TBL t3 ON t3.i = 1 WHERE t1.__spd_url != '' GROUP BY t1.i, t1.j, t1.t, t3.t LIMIT 5;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Limit  (cost=1469.39..1679.22 rows=5 width=76)
   Output: t1.i, (min(t1.j)), t3.t, t1.j, t1.t
   ->  GroupAggregate  (cost=1469.39..135758.69 rows=3200 width=76)
         Output: t1.i, min(t1.j), t3.t, t1.j, t1.t
         Group Key: t1.i, t1.j, t1.t, t3.t
         ->  Incremental Sort  (cost=1469.39..123350.05 rows=990131 width=72)
               Output: t1.i, t3.t, t1.j, t1.t
               Sort Key: t1.i, t1.j, t1.t, t3.t
               Presorted Key: t1.i
               ->  Nested Loop Left Join  (cost=925.36..14245.75 rows=990131 width=72)
                     Output: t1.i, t3.t, t1.j, t1.t
                     ->  Merge Left Join  (cost=825.36..1716.07 rows=58243 width=40)
                           Output: t1.i, t1.j, t1.t
                           Merge Cond: (t1.i = t2.i)
                           ->  Sort  (cost=412.68..421.21 rows=3413 width=40)
                                 Output: t1.i, t1.j, t1.t
                                 Sort Key: t1.i
                                 ->  Foreign Scan on public.j1_tbl t1  (cost=100.00..212.39 rows=3413 width=40)
                                       Output: t1.i, t1.j, t1.t
                                       Filter: (t1.__spd_url <> ''::text)
                                       Node: postgres_svr / Status: Alive
                                         Limit push-down: no
                                         Remote SQL: SELECT i, j, t FROM public.j1_tbl
                           ->  Sort  (cost=412.68..421.21 rows=3413 width=4)
                                 Output: t2.i
                                 Sort Key: t2.i
                                 ->  Foreign Scan on public.j2_tbl t2  (cost=100.00..212.39 rows=3413 width=4)
                                       Output: t2.i
                                       Node: postgres_svr / Status: Alive
                                         Limit push-down: no
                                         Remote SQL: SELECT i FROM public.j2_tbl
                     ->  Materialize  (cost=100.00..153.09 rows=17 width=32)
                           Output: t3.t
                           ->  Foreign Scan on public.j3_tbl t3  (cost=100.00..153.00 rows=17 width=32)
                                 Output: t3.t
                                 Node: postgres_svr / Status: Alive
                                   Limit push-down: no
                                   Remote SQL: SELECT i, t FROM public.j3_tbl WHERE ((i = 1))
(38 rows)

--Testcase 12:
SELECT t1.i, min(j), t3.t FROM J1_TBL t1 FULL JOIN J2_TBL t2 ON t1.i = t2.i LEFT JOIN J3_TBL t3 ON t3.i = 1 WHERE t1.__spd_url != '' GROUP BY t1.i, t1.j, t1.t, t3.t LIMIT 5;
 i | min |   t   
---+-----+-------
 0 |     | first
 1 |   4 | first
 2 |   3 | first
 3 |   2 | first
 4 |   1 | first
(5 rows)

--Join  with WHERE __spd_url + ORDER BY + OFFSET
--Testcase 13:
EXPLAIN VERBOSE SELECT t1.j FROM j1_tbl t1 LEFT JOIN j2_tbl t2 ON (t1.__spd_url = t2.__spd_url) WHERE t1.__spd_url != '' ORDER BY t1.j OFFSET 10;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Limit  (cost=100.03..255.05 rows=58233 width=4)
   Output: t1.j
   ->  Nested Loop Left Join  (cost=100.00..255.05 rows=58243 width=4)
         Output: t1.j
         Join Filter: (t1.__spd_url = t2.__spd_url)
         ->  Foreign Scan on public.j1_tbl t1  (cost=0.00..0.00 rows=1 width=36)
               Output: t1.j, t1.__spd_url
               Filter: (t1.__spd_url <> ''::text)
               Node: postgres_svr / Status: Alive
                 Limit push-down: no
                 Sort push-down: yes
                 Remote SQL: SELECT j FROM public.j1_tbl ORDER BY j ASC NULLS LAST
         ->  Foreign Scan on public.j2_tbl t2  (cost=100.00..212.39 rows=3413 width=32)
               Output: t2.__spd_url
               Node: postgres_svr / Status: Alive
                 Limit push-down: no
                 Sort push-down: no
                 Remote SQL: SELECT NULL FROM public.j2_tbl
(18 rows)

--Testcase 14:
SELECT t1.j FROM j1_tbl t1 LEFT JOIN j2_tbl t2 ON (t1.__spd_url = t2.__spd_url) WHERE t1.__spd_url != '' ORDER BY t1.j OFFSET 10;
 j 
---
 0
 0
 0
 0
 0
 0
 1
 1
 1
 1
 1
 1
 1
 1
 2
 2
 2
 2
 2
 2
 2
 2
 3
 3
 3
 3
 3
 3
 3
 3
 4
 4
 4
 4
 4
 4
 4
 4
 6
 6
 6
 6
 6
 6
 6
 6
 7
 7
 7
 7
 7
 7
 7
 7
 8
 8
 8
 8
 8
 8
 8
 8
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
(78 rows)

--Testcase 15:
EXPLAIN VERBOSE SELECT j1.i, j, k  FROM J1_TBL j1 CROSS JOIN J2_TBL j2 WHERE j1.__spd_url != 'this' ORDER BY j1.t, j, k OFFSET 2;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Limit  (cost=2229879.55..2259000.97 rows=11648567 width=44)
   Output: j1.i, j1.j, j2.k, j1.t
   ->  Sort  (cost=2229879.55..2259000.97 rows=11648569 width=44)
         Output: j1.i, j1.j, j2.k, j1.t
         Sort Key: j1.t, j1.j, j2.k
         ->  Nested Loop  (cost=200.00..146040.43 rows=11648569 width=44)
               Output: j1.i, j1.j, j2.k, j1.t
               ->  Foreign Scan on public.j1_tbl j1  (cost=100.00..212.39 rows=3413 width=40)
                     Output: j1.i, j1.j, j1.t
                     Filter: (j1.__spd_url <> 'this'::text)
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Sort push-down: no
                       Remote SQL: SELECT i, j, t FROM public.j1_tbl
               ->  Materialize  (cost=100.00..229.45 rows=3413 width=4)
                     Output: j2.k
                     ->  Foreign Scan on public.j2_tbl j2  (cost=100.00..212.39 rows=3413 width=4)
                           Output: j2.k
                           Node: postgres_svr / Status: Alive
                             Limit push-down: no
                             Sort push-down: no
                             Remote SQL: SELECT k FROM public.j2_tbl
(22 rows)

--Testcase 16:
SELECT j1.i, j, k  FROM J1_TBL j1 CROSS JOIN J2_TBL j2 WHERE j1.__spd_url != 'this' ORDER BY j1.t, j, k OFFSET 2;
 i | j | k  
---+---+----
 8 | 8 | -3
 8 | 8 | -1
 8 | 8 |  0
 8 | 8 |  2
 8 | 8 |  4
 8 | 8 |   
 5 | 0 | -5
 5 | 0 | -5
 5 | 0 | -3
 5 | 0 | -1
 5 | 0 |  0
 5 | 0 |  2
 5 | 0 |  4
 5 | 0 |   
 4 | 1 | -5
 4 | 1 | -5
 4 | 1 | -3
 4 | 1 | -1
 4 | 1 |  0
 4 | 1 |  2
 4 | 1 |  4
 4 | 1 |   
   |   | -5
   |   | -5
   |   | -3
   |   | -1
   |   |  0
   |   |  2
   |   |  4
   |   |   
 1 | 4 | -5
 1 | 4 | -5
 1 | 4 | -3
 1 | 4 | -1
 1 | 4 |  0
 1 | 4 |  2
 1 | 4 |  4
 1 | 4 |   
 7 | 7 | -5
 7 | 7 | -5
 7 | 7 | -3
 7 | 7 | -1
 7 | 7 |  0
 7 | 7 |  2
 7 | 7 |  4
 7 | 7 |   
 6 | 6 | -5
 6 | 6 | -5
 6 | 6 | -3
 6 | 6 | -1
 6 | 6 |  0
 6 | 6 |  2
 6 | 6 |  4
 6 | 6 |   
 3 | 2 | -5
 3 | 2 | -5
 3 | 2 | -3
 3 | 2 | -1
 3 | 2 |  0
 3 | 2 |  2
 3 | 2 |  4
 3 | 2 |   
 2 | 3 | -5
 2 | 3 | -5
 2 | 3 | -3
 2 | 3 | -1
 2 | 3 |  0
 2 | 3 |  2
 2 | 3 |  4
 2 | 3 |   
   | 0 | -5
   | 0 | -5
   | 0 | -3
   | 0 | -1
   | 0 |  0
   | 0 |  2
   | 0 |  4
   | 0 |   
 0 |   | -5
 0 |   | -5
 0 |   | -3
 0 |   | -1
 0 |   |  0
 0 |   |  2
 0 |   |  4
 0 |   |   
(86 rows)

--Testcase 17:
EXPLAIN VERBOSE SELECT J1_TBL.i, J1_TBL.j, J1_TBL.t FROM J1_TBL CROSS JOIN J2_TBL WHERE J1_TBL.__spd_url != 'twq' ORDER BY J1_TBL.i, J1_TBL.j, J1_TBL.t OFFSET 1;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=100.00..246.52 rows=11648568 width=40)
   Output: j1_tbl.i, j1_tbl.j, j1_tbl.t
   ->  Nested Loop  (cost=100.00..246.52 rows=11648569 width=40)
         Output: j1_tbl.i, j1_tbl.j, j1_tbl.t
         ->  Foreign Scan on public.j1_tbl  (cost=0.00..0.00 rows=1 width=40)
               Output: j1_tbl.i, j1_tbl.j, j1_tbl.t
               Filter: (j1_tbl.__spd_url <> 'twq'::text)
               Node: postgres_svr / Status: Alive
                 Limit push-down: no
                 Sort push-down: yes
                 Remote SQL: SELECT i, j, t FROM public.j1_tbl ORDER BY i ASC NULLS LAST, j ASC NULLS LAST, t ASC NULLS LAST
         ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=0)
               Node: postgres_svr / Status: Alive
                 Limit push-down: no
                 Sort push-down: no
                 Remote SQL: SELECT NULL FROM public.j2_tbl
(16 rows)

--Testcase 18:
SELECT J1_TBL.i, J1_TBL.j, J1_TBL.t FROM J1_TBL CROSS JOIN J2_TBL WHERE J1_TBL.__spd_url != 'twq' ORDER BY J1_TBL.i, J1_TBL.j, J1_TBL.t OFFSET 1;
 i | j |   t   
---+---+-------
 0 |   | zero
 0 |   | zero
 0 |   | zero
 0 |   | zero
 0 |   | zero
 0 |   | zero
 0 |   | zero
 1 | 4 | one
 1 | 4 | one
 1 | 4 | one
 1 | 4 | one
 1 | 4 | one
 1 | 4 | one
 1 | 4 | one
 1 | 4 | one
 2 | 3 | two
 2 | 3 | two
 2 | 3 | two
 2 | 3 | two
 2 | 3 | two
 2 | 3 | two
 2 | 3 | two
 2 | 3 | two
 3 | 2 | three
 3 | 2 | three
 3 | 2 | three
 3 | 2 | three
 3 | 2 | three
 3 | 2 | three
 3 | 2 | three
 3 | 2 | three
 4 | 1 | four
 4 | 1 | four
 4 | 1 | four
 4 | 1 | four
 4 | 1 | four
 4 | 1 | four
 4 | 1 | four
 4 | 1 | four
 5 | 0 | five
 5 | 0 | five
 5 | 0 | five
 5 | 0 | five
 5 | 0 | five
 5 | 0 | five
 5 | 0 | five
 5 | 0 | five
 6 | 6 | six
 6 | 6 | six
 6 | 6 | six
 6 | 6 | six
 6 | 6 | six
 6 | 6 | six
 6 | 6 | six
 6 | 6 | six
 7 | 7 | seven
 7 | 7 | seven
 7 | 7 | seven
 7 | 7 | seven
 7 | 7 | seven
 7 | 7 | seven
 7 | 7 | seven
 7 | 7 | seven
 8 | 8 | eight
 8 | 8 | eight
 8 | 8 | eight
 8 | 8 | eight
 8 | 8 | eight
 8 | 8 | eight
 8 | 8 | eight
 8 | 8 | eight
   | 0 | zero
   | 0 | zero
   | 0 | zero
   | 0 | zero
   | 0 | zero
   | 0 | zero
   | 0 | zero
   | 0 | zero
   |   | null
   |   | null
   |   | null
   |   | null
   |   | null
   |   | null
   |   | null
   |   | null
(87 rows)

--Join  with ON  __spd_url + LIMIT
--Testcase 19:
EXPLAIN VERBOSE SELECT j3.i, k FROM j2_tbl INNER JOIN (SELECT i FROM j1_tbl) j3 ON j2_tbl.__spd_url != '' LIMIT 5;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Limit  (cost=200.00..200.06 rows=5 width=8)
   Output: j1_tbl.i, j2_tbl.k
   ->  Nested Loop  (cost=200.00..146040.43 rows=11648569 width=8)
         Output: j1_tbl.i, j2_tbl.k
         ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=4)
               Output: j2_tbl.k
               Filter: (j2_tbl.__spd_url <> ''::text)
               Node: postgres_svr / Status: Alive
                 Limit push-down: no
                 Remote SQL: SELECT k FROM public.j2_tbl
         ->  Materialize  (cost=100.00..229.45 rows=3413 width=4)
               Output: j1_tbl.i
               ->  Foreign Scan on public.j1_tbl  (cost=100.00..212.39 rows=3413 width=4)
                     Output: j1_tbl.i
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Remote SQL: SELECT i FROM public.j1_tbl
(17 rows)

--Testcase 20:
SELECT j3.i, k FROM j2_tbl INNER JOIN (SELECT i FROM j1_tbl) j3 ON j2_tbl.__spd_url != '' LIMIT 5;
 i | k  
---+----
 1 | -1
 2 | -1
 3 | -1
 4 | -1
 5 | -1
(5 rows)

--Testcase 21:
EXPLAIN VERBOSE SELECT k, J1_TBL.t FROM J1_TBL RIGHT JOIN J2_TBL ON (J1_TBL.__spd_url <= J2_TBL.__spd_url) LIMIT 5;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Limit  (cost=200.00..200.23 rows=5 width=36)
   Output: j2_tbl.k, j1_tbl.t
   ->  Nested Loop Left Join  (cost=200.00..175161.85 rows=3882856 width=36)
         Output: j2_tbl.k, j1_tbl.t
         Join Filter: (j1_tbl.__spd_url <= j2_tbl.__spd_url)
         ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=36)
               Output: j2_tbl.k, j2_tbl.__spd_url
               Node: postgres_svr / Status: Alive
                 Limit push-down: no
                 Remote SQL: SELECT k FROM public.j2_tbl
         ->  Materialize  (cost=100.00..229.45 rows=3413 width=64)
               Output: j1_tbl.t, j1_tbl.__spd_url
               ->  Foreign Scan on public.j1_tbl  (cost=100.00..212.39 rows=3413 width=64)
                     Output: j1_tbl.t, j1_tbl.__spd_url
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Remote SQL: SELECT t FROM public.j1_tbl
(17 rows)

--Testcase 22:
SELECT k, J1_TBL.t FROM J1_TBL RIGHT JOIN J2_TBL ON (J1_TBL.__spd_url <= J2_TBL.__spd_url) LIMIT 5;
 k  |   t   
----+-------
 -1 | one
 -1 | two
 -1 | three
 -1 | four
 -1 | five
(5 rows)

--Testcase 23:
EXPLAIN VERBOSE SELECT J1_TBL.i, k, t FROM J1_TBL FULL JOIN J2_TBL ON (J1_TBL.__spd_url = J2_TBL.__spd_url) LIMIT 3;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Limit  (cost=355.05..355.16 rows=3 width=40)
   Output: j1_tbl.i, j2_tbl.k, j1_tbl.t
   ->  Hash Full Join  (cost=355.05..2513.20 rows=58243 width=40)
         Output: j1_tbl.i, j2_tbl.k, j1_tbl.t
         Hash Cond: (j1_tbl.__spd_url = j2_tbl.__spd_url)
         ->  Foreign Scan on public.j1_tbl  (cost=100.00..212.39 rows=3413 width=68)
               Output: j1_tbl.i, j1_tbl.t, j1_tbl.__spd_url
               Node: postgres_svr / Status: Alive
                 Limit push-down: no
                 Remote SQL: SELECT i, t FROM public.j1_tbl
         ->  Hash  (cost=212.39..212.39 rows=3413 width=36)
               Output: j2_tbl.k, j2_tbl.__spd_url
               ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=36)
                     Output: j2_tbl.k, j2_tbl.__spd_url
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Remote SQL: SELECT k FROM public.j2_tbl
(17 rows)

--Testcase 24:
SELECT J1_TBL.i, k, t FROM J1_TBL FULL JOIN J2_TBL ON (J1_TBL.__spd_url = J2_TBL.__spd_url) LIMIT 3;
 i | k  |  t  
---+----+-----
 1 |  0 | one
 1 |    | one
 1 | -5 | one
(3 rows)

--Join  with ON __spd_url + ORDER BY + OFFSET
--Testcase 25:
EXPLAIN VERBOSE SELECT J1_TBL.i, J1_TBL.j, J1_TBL.t FROM J1_TBL INNER JOIN J2_TBL ON (J1_TBL.__spd_url = J2_TBL.__spd_url) ORDER BY J1_TBL.i OFFSET 1;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Limit  (cost=100.00..255.05 rows=58242 width=40)
   Output: j1_tbl.i, j1_tbl.j, j1_tbl.t
   ->  Nested Loop  (cost=100.00..255.05 rows=58243 width=40)
         Output: j1_tbl.i, j1_tbl.j, j1_tbl.t
         Join Filter: (j1_tbl.__spd_url = j2_tbl.__spd_url)
         ->  Foreign Scan on public.j1_tbl  (cost=0.00..0.00 rows=1 width=72)
               Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
               Node: postgres_svr / Status: Alive
                 Limit push-down: no
                 Sort push-down: yes
                 Remote SQL: SELECT i, j, t FROM public.j1_tbl ORDER BY i ASC NULLS LAST
         ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=32)
               Output: j2_tbl.__spd_url
               Node: postgres_svr / Status: Alive
                 Limit push-down: no
                 Sort push-down: no
                 Remote SQL: SELECT NULL FROM public.j2_tbl
(17 rows)

--Testcase 26:
SELECT J1_TBL.i, J1_TBL.j, J1_TBL.t FROM J1_TBL INNER JOIN J2_TBL ON (J1_TBL.__spd_url = J2_TBL.__spd_url) ORDER BY J1_TBL.i OFFSET 1;
 i | j |   t   
---+---+-------
 0 |   | zero
 0 |   | zero
 0 |   | zero
 0 |   | zero
 0 |   | zero
 0 |   | zero
 0 |   | zero
 1 | 4 | one
 1 | 4 | one
 1 | 4 | one
 1 | 4 | one
 1 | 4 | one
 1 | 4 | one
 1 | 4 | one
 1 | 4 | one
 2 | 3 | two
 2 | 3 | two
 2 | 3 | two
 2 | 3 | two
 2 | 3 | two
 2 | 3 | two
 2 | 3 | two
 2 | 3 | two
 3 | 2 | three
 3 | 2 | three
 3 | 2 | three
 3 | 2 | three
 3 | 2 | three
 3 | 2 | three
 3 | 2 | three
 3 | 2 | three
 4 | 1 | four
 4 | 1 | four
 4 | 1 | four
 4 | 1 | four
 4 | 1 | four
 4 | 1 | four
 4 | 1 | four
 4 | 1 | four
 5 | 0 | five
 5 | 0 | five
 5 | 0 | five
 5 | 0 | five
 5 | 0 | five
 5 | 0 | five
 5 | 0 | five
 5 | 0 | five
 6 | 6 | six
 6 | 6 | six
 6 | 6 | six
 6 | 6 | six
 6 | 6 | six
 6 | 6 | six
 6 | 6 | six
 6 | 6 | six
 7 | 7 | seven
 7 | 7 | seven
 7 | 7 | seven
 7 | 7 | seven
 7 | 7 | seven
 7 | 7 | seven
 7 | 7 | seven
 7 | 7 | seven
 8 | 8 | eight
 8 | 8 | eight
 8 | 8 | eight
 8 | 8 | eight
 8 | 8 | eight
 8 | 8 | eight
 8 | 8 | eight
 8 | 8 | eight
   |   | null
   |   | null
   |   | null
   |   | null
   |   | null
   |   | null
   |   | null
   |   | null
   | 0 | zero
   | 0 | zero
   | 0 | zero
   | 0 | zero
   | 0 | zero
   | 0 | zero
   | 0 | zero
   | 0 | zero
(87 rows)

--Testcase 27:
EXPLAIN VERBOSE SELECT t1.a, t1.b, t1.c, t2.a, t2.d FROM J1_TBL t1 (a, b, c, e) FULL JOIN J2_TBL t2 (a, d, e) ON (t1.e = t2.e) ORDER BY t1.a, t1.b, t1.c, t2.a, t2.d OFFSET 3;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Limit  (cost=6325.95..6471.55 rows=58240 width=48)
   Output: t1.a, t1.b, t1.c, t2.a, t2.d
   ->  Sort  (cost=6325.94..6471.55 rows=58243 width=48)
         Output: t1.a, t1.b, t1.c, t2.a, t2.d
         Sort Key: t1.a, t1.b, t1.c, t2.a, t2.d
         ->  Merge Full Join  (cost=825.36..1716.07 rows=58243 width=48)
               Output: t1.a, t1.b, t1.c, t2.a, t2.d
               Merge Cond: (t1.e = t2.e)
               ->  Sort  (cost=412.68..421.21 rows=3413 width=72)
                     Output: t1.a, t1.b, t1.c, t1.e
                     Sort Key: t1.e
                     ->  Foreign Scan on public.j1_tbl t1  (cost=100.00..212.39 rows=3413 width=72)
                           Output: t1.a, t1.b, t1.c, t1.e
                           Node: postgres_svr / Status: Alive
                             Limit push-down: no
                             Sort push-down: no
                             Remote SQL: SELECT i, j, t FROM public.j1_tbl
               ->  Sort  (cost=412.68..421.21 rows=3413 width=40)
                     Output: t2.a, t2.d, t2.e
                     Sort Key: t2.e
                     ->  Foreign Scan on public.j2_tbl t2  (cost=100.00..212.39 rows=3413 width=40)
                           Output: t2.a, t2.d, t2.e
                           Node: postgres_svr / Status: Alive
                             Limit push-down: no
                             Sort push-down: no
                             Remote SQL: SELECT i, k FROM public.j2_tbl
(26 rows)

--Testcase 28:
SELECT t1.a, t1.b, t1.c, t2.a, t2.d FROM J1_TBL t1 (a, b, c, e) FULL JOIN J2_TBL t2 (a, d, e) ON (t1.e = t2.e) ORDER BY t1.a, t1.b, t1.c, t2.a, t2.d OFFSET 3;
 a | b |   c   | a | d  
---+---+-------+---+----
 0 |   | zero  | 2 |  4
 0 |   | zero  | 3 | -3
 0 |   | zero  | 5 | -5
 0 |   | zero  | 5 | -5
 0 |   | zero  |   |  0
 1 | 4 | one   | 0 |   
 1 | 4 | one   | 1 | -1
 1 | 4 | one   | 2 |  2
 1 | 4 | one   | 2 |  4
 1 | 4 | one   | 3 | -3
 1 | 4 | one   | 5 | -5
 1 | 4 | one   | 5 | -5
 1 | 4 | one   |   |  0
 2 | 3 | two   | 0 |   
 2 | 3 | two   | 1 | -1
 2 | 3 | two   | 2 |  2
 2 | 3 | two   | 2 |  4
 2 | 3 | two   | 3 | -3
 2 | 3 | two   | 5 | -5
 2 | 3 | two   | 5 | -5
 2 | 3 | two   |   |  0
 3 | 2 | three | 0 |   
 3 | 2 | three | 1 | -1
 3 | 2 | three | 2 |  2
 3 | 2 | three | 2 |  4
 3 | 2 | three | 3 | -3
 3 | 2 | three | 5 | -5
 3 | 2 | three | 5 | -5
 3 | 2 | three |   |  0
 4 | 1 | four  | 0 |   
 4 | 1 | four  | 1 | -1
 4 | 1 | four  | 2 |  2
 4 | 1 | four  | 2 |  4
 4 | 1 | four  | 3 | -3
 4 | 1 | four  | 5 | -5
 4 | 1 | four  | 5 | -5
 4 | 1 | four  |   |  0
 5 | 0 | five  | 0 |   
 5 | 0 | five  | 1 | -1
 5 | 0 | five  | 2 |  2
 5 | 0 | five  | 2 |  4
 5 | 0 | five  | 3 | -3
 5 | 0 | five  | 5 | -5
 5 | 0 | five  | 5 | -5
 5 | 0 | five  |   |  0
 6 | 6 | six   | 0 |   
 6 | 6 | six   | 1 | -1
 6 | 6 | six   | 2 |  2
 6 | 6 | six   | 2 |  4
 6 | 6 | six   | 3 | -3
 6 | 6 | six   | 5 | -5
 6 | 6 | six   | 5 | -5
 6 | 6 | six   |   |  0
 7 | 7 | seven | 0 |   
 7 | 7 | seven | 1 | -1
 7 | 7 | seven | 2 |  2
 7 | 7 | seven | 2 |  4
 7 | 7 | seven | 3 | -3
 7 | 7 | seven | 5 | -5
 7 | 7 | seven | 5 | -5
 7 | 7 | seven |   |  0
 8 | 8 | eight | 0 |   
 8 | 8 | eight | 1 | -1
 8 | 8 | eight | 2 |  2
 8 | 8 | eight | 2 |  4
 8 | 8 | eight | 3 | -3
 8 | 8 | eight | 5 | -5
 8 | 8 | eight | 5 | -5
 8 | 8 | eight |   |  0
   | 0 | zero  | 0 |   
   | 0 | zero  | 1 | -1
   | 0 | zero  | 2 |  2
   | 0 | zero  | 2 |  4
   | 0 | zero  | 3 | -3
   | 0 | zero  | 5 | -5
   | 0 | zero  | 5 | -5
   | 0 | zero  |   |  0
   |   | null  | 0 |   
   |   | null  | 1 | -1
   |   | null  | 2 |  2
   |   | null  | 2 |  4
   |   | null  | 3 | -3
   |   | null  | 5 | -5
   |   | null  | 5 | -5
   |   | null  |   |  0
(85 rows)

--Testcase 29:
EXPLAIN VERBOSE SELECT t1.i, t2.i, t3.i, t4.i FROM J1_TBL AS t1 LEFT JOIN J2_TBL AS t2 ON t1.__spd_url = t2.__spd_url RIGHT JOIN J3_TBL AS t3 INNER JOIN J1_TBL AS t4 ON t4.i = t3.i ON t1.i = t3.i WHERE t1.i IS NOT NULL ORDER BY t1.i OFFSET 1;
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=100.00..399.95 rows=16876738 width=16)
   Output: t1.i, t2.i, t3.i, t4.i
   ->  Merge Join  (cost=100.00..399.95 rows=16876739 width=16)
         Output: t1.i, t2.i, t3.i, t4.i
         Merge Cond: (t1.i = t4.i)
         ->  Nested Loop Left Join  (cost=100.00..255.05 rows=57953 width=8)
               Output: t1.i, t2.i
               Join Filter: (t1.__spd_url = t2.__spd_url)
               ->  Foreign Scan on public.j1_tbl t1  (cost=0.00..0.00 rows=1 width=36)
                     Output: t1.i, t1.__spd_url
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Sort push-down: yes
                       Remote SQL: SELECT i FROM public.j1_tbl WHERE ((i IS NOT NULL)) ORDER BY i ASC NULLS LAST
               ->  Foreign Scan on public.j2_tbl t2  (cost=100.00..212.39 rows=3413 width=36)
                     Output: t2.i, t2.__spd_url
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Sort push-down: no
                       Remote SQL: SELECT i FROM public.j2_tbl
         ->  Materialize  (cost=0.00..0.00 rows=0 width=8)
               Output: t3.i, t4.i
               ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=8)
                     Output: t3.i, t4.i
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Sort push-down: yes
                       Relations: (public.j3_tbl t3) INNER JOIN (public.j1_tbl t4)
                       Remote SQL: SELECT r4.i, r5.i FROM (public.j3_tbl r4 INNER JOIN public.j1_tbl r5 ON (((r4.i = r5.i)))) ORDER BY r5.i ASC NULLS LAST
(29 rows)

--Testcase 30:
SELECT t1.i, t2.i, t3.i, t4.i FROM J1_TBL AS t1 LEFT JOIN J2_TBL AS t2 ON t1.__spd_url = t2.__spd_url RIGHT JOIN J3_TBL AS t3 INNER JOIN J1_TBL AS t4 ON t4.i = t3.i ON t1.i = t3.i WHERE t1.i IS NOT NULL ORDER BY t1.i OFFSET 1;
 i | i | i | i 
---+---+---+---
 1 | 2 | 1 | 1
 1 | 3 | 1 | 1
 1 | 2 | 1 | 1
 1 | 5 | 1 | 1
 1 | 5 | 1 | 1
 1 | 0 | 1 | 1
 1 |   | 1 | 1
 2 | 1 | 2 | 2
 2 | 1 | 2 | 2
 2 | 2 | 2 | 2
 2 | 2 | 2 | 2
 2 | 3 | 2 | 2
 2 | 3 | 2 | 2
 2 | 2 | 2 | 2
 2 | 2 | 2 | 2
 2 | 5 | 2 | 2
 2 | 5 | 2 | 2
 2 | 5 | 2 | 2
 2 | 5 | 2 | 2
 2 | 0 | 2 | 2
 2 | 0 | 2 | 2
 2 |   | 2 | 2
 2 |   | 2 | 2
 3 | 1 | 3 | 3
 3 | 2 | 3 | 3
 3 | 3 | 3 | 3
 3 | 2 | 3 | 3
 3 | 5 | 3 | 3
 3 | 5 | 3 | 3
 3 | 0 | 3 | 3
 3 |   | 3 | 3
 4 | 1 | 4 | 4
 4 | 2 | 4 | 4
 4 | 3 | 4 | 4
 4 | 2 | 4 | 4
 4 | 5 | 4 | 4
 4 | 5 | 4 | 4
 4 | 0 | 4 | 4
 4 |   | 4 | 4
 5 | 1 | 5 | 5
 5 | 2 | 5 | 5
 5 | 3 | 5 | 5
 5 | 2 | 5 | 5
 5 | 5 | 5 | 5
 5 | 5 | 5 | 5
 5 | 0 | 5 | 5
 5 |   | 5 | 5
(47 rows)

--Join  with ON __spd_url + aggregate function + GROUP BY + ORDER BY
--Testcase 31:
EXPLAIN VERBOSE SELECT t1.j + 1, max(t1.i), min(t1.t) FROM j1_tbl t1 LEFT JOIN j2_tbl t2 ON (t1.__spd_url = t2.__spd_url) GROUP BY t1.j ORDER BY t1.j;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Sort  (cost=672.34..672.84 rows=200 width=44)
   Output: ((t1.j + 1)), (max(t1.i)), (min(t1.t)), t1.j
   Sort Key: t1.j
   ->  HashAggregate  (cost=662.19..664.69 rows=200 width=44)
         Output: (t1.j + 1), max(t1.i), min(t1.t), t1.j
         Group Key: t1.j
         ->  Hash Right Join  (cost=100.01..225.37 rows=58243 width=40)
               Output: t1.j, t1.i, t1.t
               Hash Cond: (t2.__spd_url = t1.__spd_url)
               ->  Foreign Scan on public.j2_tbl t2  (cost=100.00..212.39 rows=3413 width=32)
                     Output: t2.__spd_url
                     Node: postgres_svr / Status: Alive
                       Sort push-down: no
                       Remote SQL: SELECT NULL FROM public.j2_tbl
               ->  Hash  (cost=0.00..0.00 rows=1 width=72)
                     Output: t1.j, t1.i, t1.t, t1.__spd_url
                     ->  Foreign Scan on public.j1_tbl t1  (cost=0.00..0.00 rows=1 width=72)
                           Output: t1.j, t1.i, t1.t, t1.__spd_url
                           Node: postgres_svr / Status: Alive
                             Sort push-down: yes
                             Remote SQL: SELECT i, j, t FROM public.j1_tbl ORDER BY j ASC NULLS LAST
(21 rows)

--Testcase 32:
SELECT t1.j + 1, max(t1.i), min(t1.t) FROM j1_tbl t1 LEFT JOIN j2_tbl t2 ON (t1.__spd_url = t2.__spd_url) GROUP BY t1.j ORDER BY t1.j;
 ?column? | max |  min  
----------+-----+-------
        1 |   5 | five
        2 |   4 | four
        3 |   3 | three
        4 |   2 | two
        5 |   1 | one
        7 |   6 | six
        8 |   7 | seven
        9 |   8 | eight
          |   0 | null
(9 rows)

--Testcase 33:
EXPLAIN VERBOSE SELECT count(J1_TBL.i) + 2, max(k), min(t) FROM J1_TBL FULL JOIN J2_TBL ON (J1_TBL.__spd_url = J2_TBL.__spd_url) GROUP BY J1_TBL.i ORDER BY J1_TBL.i;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=817.95..818.45 rows=200 width=48)
   Output: ((count(j1_tbl.i) + 2)), (max(j2_tbl.k)), (min(j1_tbl.t)), j1_tbl.i
   Sort Key: j1_tbl.i
   ->  HashAggregate  (cost=807.80..810.30 rows=200 width=48)
         Output: (count(j1_tbl.i) + 2), max(j2_tbl.k), min(j1_tbl.t), j1_tbl.i
         Group Key: j1_tbl.i
         ->  Hash Full Join  (cost=100.01..225.37 rows=58243 width=40)
               Output: j1_tbl.i, j2_tbl.k, j1_tbl.t
               Hash Cond: (j2_tbl.__spd_url = j1_tbl.__spd_url)
               ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=36)
                     Output: j2_tbl.k, j2_tbl.__spd_url
                     Node: postgres_svr / Status: Alive
                       Sort push-down: no
                       Remote SQL: SELECT k FROM public.j2_tbl
               ->  Hash  (cost=0.00..0.00 rows=1 width=68)
                     Output: j1_tbl.i, j1_tbl.t, j1_tbl.__spd_url
                     ->  Foreign Scan on public.j1_tbl  (cost=0.00..0.00 rows=1 width=68)
                           Output: j1_tbl.i, j1_tbl.t, j1_tbl.__spd_url
                           Node: postgres_svr / Status: Alive
                             Sort push-down: yes
                             Remote SQL: SELECT i, t FROM public.j1_tbl ORDER BY i ASC NULLS LAST
(21 rows)

--Testcase 34:
SELECT count(J1_TBL.i) + 2, max(k), min(t) FROM J1_TBL FULL JOIN J2_TBL ON (J1_TBL.__spd_url = J2_TBL.__spd_url) GROUP BY J1_TBL.i ORDER BY J1_TBL.i;
 ?column? | max |  min  
----------+-----+-------
       10 |   4 | zero
       10 |   4 | one
       10 |   4 | two
       10 |   4 | three
       10 |   4 | four
       10 |   4 | five
       10 |   4 | six
       10 |   4 | seven
       10 |   4 | eight
        2 |   4 | null
(10 rows)

--Join  with USING  __spd_url + ORDER BY
--Testcase 35:
EXPLAIN VERBOSE SELECT J1_TBL.i, J1_TBL.j, J1_TBL.t FROM J1_TBL INNER JOIN J2_TBL USING (__spd_url) AS x ORDER BY J1_TBL.i;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Nested Loop  (cost=100.00..255.05 rows=58243 width=40)
   Output: j1_tbl.i, j1_tbl.j, j1_tbl.t
   Join Filter: (j1_tbl.__spd_url = j2_tbl.__spd_url)
   ->  Foreign Scan on public.j1_tbl  (cost=0.00..0.00 rows=1 width=72)
         Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
         Node: postgres_svr / Status: Alive
           Sort push-down: yes
           Remote SQL: SELECT i, j, t FROM public.j1_tbl ORDER BY i ASC NULLS LAST
   ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=32)
         Output: j2_tbl.__spd_url
         Node: postgres_svr / Status: Alive
           Sort push-down: no
           Remote SQL: SELECT NULL FROM public.j2_tbl
(13 rows)

--Testcase 36:
SELECT J1_TBL.i, J1_TBL.j, J1_TBL.t FROM J1_TBL INNER JOIN J2_TBL USING (__spd_url) AS x ORDER BY J1_TBL.i;
 i | j |   t   
---+---+-------
 0 |   | zero
 0 |   | zero
 0 |   | zero
 0 |   | zero
 0 |   | zero
 0 |   | zero
 0 |   | zero
 0 |   | zero
 1 | 4 | one
 1 | 4 | one
 1 | 4 | one
 1 | 4 | one
 1 | 4 | one
 1 | 4 | one
 1 | 4 | one
 1 | 4 | one
 2 | 3 | two
 2 | 3 | two
 2 | 3 | two
 2 | 3 | two
 2 | 3 | two
 2 | 3 | two
 2 | 3 | two
 2 | 3 | two
 3 | 2 | three
 3 | 2 | three
 3 | 2 | three
 3 | 2 | three
 3 | 2 | three
 3 | 2 | three
 3 | 2 | three
 3 | 2 | three
 4 | 1 | four
 4 | 1 | four
 4 | 1 | four
 4 | 1 | four
 4 | 1 | four
 4 | 1 | four
 4 | 1 | four
 4 | 1 | four
 5 | 0 | five
 5 | 0 | five
 5 | 0 | five
 5 | 0 | five
 5 | 0 | five
 5 | 0 | five
 5 | 0 | five
 5 | 0 | five
 6 | 6 | six
 6 | 6 | six
 6 | 6 | six
 6 | 6 | six
 6 | 6 | six
 6 | 6 | six
 6 | 6 | six
 6 | 6 | six
 7 | 7 | seven
 7 | 7 | seven
 7 | 7 | seven
 7 | 7 | seven
 7 | 7 | seven
 7 | 7 | seven
 7 | 7 | seven
 7 | 7 | seven
 8 | 8 | eight
 8 | 8 | eight
 8 | 8 | eight
 8 | 8 | eight
 8 | 8 | eight
 8 | 8 | eight
 8 | 8 | eight
 8 | 8 | eight
   |   | null
   |   | null
   |   | null
   |   | null
   |   | null
   |   | null
   |   | null
   |   | null
   | 0 | zero
   | 0 | zero
   | 0 | zero
   | 0 | zero
   | 0 | zero
   | 0 | zero
   | 0 | zero
   | 0 | zero
(88 rows)

--Testcase 37:
EXPLAIN VERBOSE SELECT t1.a, t1.b, t1.c, t2.a, t2.d FROM J1_TBL t1 (a, b, c, f) FULL JOIN J2_TBL t2 (a, d, f) USING(f) ORDER BY t1.a, t1.b, t1.c, t2.a, t2.d;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Sort  (cost=6325.94..6471.55 rows=58243 width=48)
   Output: t1.a, t1.b, t1.c, t2.a, t2.d
   Sort Key: t1.a, t1.b, t1.c, t2.a, t2.d
   ->  Merge Full Join  (cost=825.36..1716.07 rows=58243 width=48)
         Output: t1.a, t1.b, t1.c, t2.a, t2.d
         Merge Cond: (t1.f = t2.f)
         ->  Sort  (cost=412.68..421.21 rows=3413 width=72)
               Output: t1.a, t1.b, t1.c, t1.f
               Sort Key: t1.f
               ->  Foreign Scan on public.j1_tbl t1  (cost=100.00..212.39 rows=3413 width=72)
                     Output: t1.a, t1.b, t1.c, t1.f
                     Node: postgres_svr / Status: Alive
                       Sort push-down: no
                       Remote SQL: SELECT i, j, t FROM public.j1_tbl
         ->  Sort  (cost=412.68..421.21 rows=3413 width=40)
               Output: t2.a, t2.d, t2.f
               Sort Key: t2.f
               ->  Foreign Scan on public.j2_tbl t2  (cost=100.00..212.39 rows=3413 width=40)
                     Output: t2.a, t2.d, t2.f
                     Node: postgres_svr / Status: Alive
                       Sort push-down: no
                       Remote SQL: SELECT i, k FROM public.j2_tbl
(22 rows)

--Testcase 38:
SELECT t1.a, t1.b, t1.c, t2.a, t2.d FROM J1_TBL t1 (a, b, c, f) FULL JOIN J2_TBL t2 (a, d, f) USING(f) ORDER BY t1.a, t1.b, t1.c, t2.a, t2.d;
 a | b |   c   | a | d  
---+---+-------+---+----
 0 |   | zero  | 0 |   
 0 |   | zero  | 1 | -1
 0 |   | zero  | 2 |  2
 0 |   | zero  | 2 |  4
 0 |   | zero  | 3 | -3
 0 |   | zero  | 5 | -5
 0 |   | zero  | 5 | -5
 0 |   | zero  |   |  0
 1 | 4 | one   | 0 |   
 1 | 4 | one   | 1 | -1
 1 | 4 | one   | 2 |  2
 1 | 4 | one   | 2 |  4
 1 | 4 | one   | 3 | -3
 1 | 4 | one   | 5 | -5
 1 | 4 | one   | 5 | -5
 1 | 4 | one   |   |  0
 2 | 3 | two   | 0 |   
 2 | 3 | two   | 1 | -1
 2 | 3 | two   | 2 |  2
 2 | 3 | two   | 2 |  4
 2 | 3 | two   | 3 | -3
 2 | 3 | two   | 5 | -5
 2 | 3 | two   | 5 | -5
 2 | 3 | two   |   |  0
 3 | 2 | three | 0 |   
 3 | 2 | three | 1 | -1
 3 | 2 | three | 2 |  2
 3 | 2 | three | 2 |  4
 3 | 2 | three | 3 | -3
 3 | 2 | three | 5 | -5
 3 | 2 | three | 5 | -5
 3 | 2 | three |   |  0
 4 | 1 | four  | 0 |   
 4 | 1 | four  | 1 | -1
 4 | 1 | four  | 2 |  2
 4 | 1 | four  | 2 |  4
 4 | 1 | four  | 3 | -3
 4 | 1 | four  | 5 | -5
 4 | 1 | four  | 5 | -5
 4 | 1 | four  |   |  0
 5 | 0 | five  | 0 |   
 5 | 0 | five  | 1 | -1
 5 | 0 | five  | 2 |  2
 5 | 0 | five  | 2 |  4
 5 | 0 | five  | 3 | -3
 5 | 0 | five  | 5 | -5
 5 | 0 | five  | 5 | -5
 5 | 0 | five  |   |  0
 6 | 6 | six   | 0 |   
 6 | 6 | six   | 1 | -1
 6 | 6 | six   | 2 |  2
 6 | 6 | six   | 2 |  4
 6 | 6 | six   | 3 | -3
 6 | 6 | six   | 5 | -5
 6 | 6 | six   | 5 | -5
 6 | 6 | six   |   |  0
 7 | 7 | seven | 0 |   
 7 | 7 | seven | 1 | -1
 7 | 7 | seven | 2 |  2
 7 | 7 | seven | 2 |  4
 7 | 7 | seven | 3 | -3
 7 | 7 | seven | 5 | -5
 7 | 7 | seven | 5 | -5
 7 | 7 | seven |   |  0
 8 | 8 | eight | 0 |   
 8 | 8 | eight | 1 | -1
 8 | 8 | eight | 2 |  2
 8 | 8 | eight | 2 |  4
 8 | 8 | eight | 3 | -3
 8 | 8 | eight | 5 | -5
 8 | 8 | eight | 5 | -5
 8 | 8 | eight |   |  0
   | 0 | zero  | 0 |   
   | 0 | zero  | 1 | -1
   | 0 | zero  | 2 |  2
   | 0 | zero  | 2 |  4
   | 0 | zero  | 3 | -3
   | 0 | zero  | 5 | -5
   | 0 | zero  | 5 | -5
   | 0 | zero  |   |  0
   |   | null  | 0 |   
   |   | null  | 1 | -1
   |   | null  | 2 |  2
   |   | null  | 2 |  4
   |   | null  | 3 | -3
   |   | null  | 5 | -5
   |   | null  | 5 | -5
   |   | null  |   |  0
(88 rows)

--Testcase 39:
EXPLAIN VERBOSE SELECT t1.i, k, t3.t FROM J1_TBL t1 INNER JOIN J2_TBL t2 USING(__spd_url) CROSS JOIN J3_TBL t3 ORDER BY 1, 2, 3;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Sort  (cost=46192104.81..46689063.21 rows=198783359 width=40)
   Output: t1.i, t2.k, t3.t
   Sort Key: t1.i, t2.k, t3.t
   ->  Nested Loop  (cost=925.36..2486728.98 rows=198783359 width=40)
         Output: t1.i, t2.k, t3.t
         ->  Merge Join  (cost=825.36..1716.07 rows=58243 width=8)
               Output: t1.i, t2.k
               Merge Cond: (t1.__spd_url = t2.__spd_url)
               ->  Sort  (cost=412.68..421.21 rows=3413 width=36)
                     Output: t1.i, t1.__spd_url
                     Sort Key: t1.__spd_url
                     ->  Foreign Scan on public.j1_tbl t1  (cost=100.00..212.39 rows=3413 width=36)
                           Output: t1.i, t1.__spd_url
                           Node: postgres_svr / Status: Alive
                             Sort push-down: no
                             Remote SQL: SELECT i FROM public.j1_tbl
               ->  Sort  (cost=412.68..421.21 rows=3413 width=36)
                     Output: t2.k, t2.__spd_url
                     Sort Key: t2.__spd_url
                     ->  Foreign Scan on public.j2_tbl t2  (cost=100.00..212.39 rows=3413 width=36)
                           Output: t2.k, t2.__spd_url
                           Node: postgres_svr / Status: Alive
                             Sort push-down: no
                             Remote SQL: SELECT k FROM public.j2_tbl
         ->  Materialize  (cost=100.00..229.45 rows=3413 width=32)
               Output: t3.t
               ->  Foreign Scan on public.j3_tbl t3  (cost=100.00..212.39 rows=3413 width=32)
                     Output: t3.t
                     Node: postgres_svr / Status: Alive
                       Sort push-down: no
                       Remote SQL: SELECT t FROM public.j3_tbl
(31 rows)

--Testcase 40:
SELECT t1.i, k, t3.t FROM J1_TBL t1 INNER JOIN J2_TBL t2 USING(__spd_url) CROSS JOIN J3_TBL t3 ORDER BY 1, 2, 3;
 i | k  |   t    
---+----+--------
 0 | -5 | first
 0 | -5 | first
 0 | -5 | five
 0 | -5 | five
 0 | -5 | forth
 0 | -5 | forth
 0 | -5 | second
 0 | -5 | second
 0 | -5 | third
 0 | -5 | third
 0 | -5 | 
 0 | -5 | 
 0 | -3 | first
 0 | -3 | five
 0 | -3 | forth
 0 | -3 | second
 0 | -3 | third
 0 | -3 | 
 0 | -1 | first
 0 | -1 | five
 0 | -1 | forth
 0 | -1 | second
 0 | -1 | third
 0 | -1 | 
 0 |  0 | first
 0 |  0 | five
 0 |  0 | forth
 0 |  0 | second
 0 |  0 | third
 0 |  0 | 
 0 |  2 | first
 0 |  2 | five
 0 |  2 | forth
 0 |  2 | second
 0 |  2 | third
 0 |  2 | 
 0 |  4 | first
 0 |  4 | five
 0 |  4 | forth
 0 |  4 | second
 0 |  4 | third
 0 |  4 | 
 0 |    | first
 0 |    | five
 0 |    | forth
 0 |    | second
 0 |    | third
 0 |    | 
 1 | -5 | first
 1 | -5 | first
 1 | -5 | five
 1 | -5 | five
 1 | -5 | forth
 1 | -5 | forth
 1 | -5 | second
 1 | -5 | second
 1 | -5 | third
 1 | -5 | third
 1 | -5 | 
 1 | -5 | 
 1 | -3 | first
 1 | -3 | five
 1 | -3 | forth
 1 | -3 | second
 1 | -3 | third
 1 | -3 | 
 1 | -1 | first
 1 | -1 | five
 1 | -1 | forth
 1 | -1 | second
 1 | -1 | third
 1 | -1 | 
 1 |  0 | first
 1 |  0 | five
 1 |  0 | forth
 1 |  0 | second
 1 |  0 | third
 1 |  0 | 
 1 |  2 | first
 1 |  2 | five
 1 |  2 | forth
 1 |  2 | second
 1 |  2 | third
 1 |  2 | 
 1 |  4 | first
 1 |  4 | five
 1 |  4 | forth
 1 |  4 | second
 1 |  4 | third
 1 |  4 | 
 1 |    | first
 1 |    | five
 1 |    | forth
 1 |    | second
 1 |    | third
 1 |    | 
 2 | -5 | first
 2 | -5 | first
 2 | -5 | five
 2 | -5 | five
 2 | -5 | forth
 2 | -5 | forth
 2 | -5 | second
 2 | -5 | second
 2 | -5 | third
 2 | -5 | third
 2 | -5 | 
 2 | -5 | 
 2 | -3 | first
 2 | -3 | five
 2 | -3 | forth
 2 | -3 | second
 2 | -3 | third
 2 | -3 | 
 2 | -1 | first
 2 | -1 | five
 2 | -1 | forth
 2 | -1 | second
 2 | -1 | third
 2 | -1 | 
 2 |  0 | first
 2 |  0 | five
 2 |  0 | forth
 2 |  0 | second
 2 |  0 | third
 2 |  0 | 
 2 |  2 | first
 2 |  2 | five
 2 |  2 | forth
 2 |  2 | second
 2 |  2 | third
 2 |  2 | 
 2 |  4 | first
 2 |  4 | five
 2 |  4 | forth
 2 |  4 | second
 2 |  4 | third
 2 |  4 | 
 2 |    | first
 2 |    | five
 2 |    | forth
 2 |    | second
 2 |    | third
 2 |    | 
 3 | -5 | first
 3 | -5 | first
 3 | -5 | five
 3 | -5 | five
 3 | -5 | forth
 3 | -5 | forth
 3 | -5 | second
 3 | -5 | second
 3 | -5 | third
 3 | -5 | third
 3 | -5 | 
 3 | -5 | 
 3 | -3 | first
 3 | -3 | five
 3 | -3 | forth
 3 | -3 | second
 3 | -3 | third
 3 | -3 | 
 3 | -1 | first
 3 | -1 | five
 3 | -1 | forth
 3 | -1 | second
 3 | -1 | third
 3 | -1 | 
 3 |  0 | first
 3 |  0 | five
 3 |  0 | forth
 3 |  0 | second
 3 |  0 | third
 3 |  0 | 
 3 |  2 | first
 3 |  2 | five
 3 |  2 | forth
 3 |  2 | second
 3 |  2 | third
 3 |  2 | 
 3 |  4 | first
 3 |  4 | five
 3 |  4 | forth
 3 |  4 | second
 3 |  4 | third
 3 |  4 | 
 3 |    | first
 3 |    | five
 3 |    | forth
 3 |    | second
 3 |    | third
 3 |    | 
 4 | -5 | first
 4 | -5 | first
 4 | -5 | five
 4 | -5 | five
 4 | -5 | forth
 4 | -5 | forth
 4 | -5 | second
 4 | -5 | second
 4 | -5 | third
 4 | -5 | third
 4 | -5 | 
 4 | -5 | 
 4 | -3 | first
 4 | -3 | five
 4 | -3 | forth
 4 | -3 | second
 4 | -3 | third
 4 | -3 | 
 4 | -1 | first
 4 | -1 | five
 4 | -1 | forth
 4 | -1 | second
 4 | -1 | third
 4 | -1 | 
 4 |  0 | first
 4 |  0 | five
 4 |  0 | forth
 4 |  0 | second
 4 |  0 | third
 4 |  0 | 
 4 |  2 | first
 4 |  2 | five
 4 |  2 | forth
 4 |  2 | second
 4 |  2 | third
 4 |  2 | 
 4 |  4 | first
 4 |  4 | five
 4 |  4 | forth
 4 |  4 | second
 4 |  4 | third
 4 |  4 | 
 4 |    | first
 4 |    | five
 4 |    | forth
 4 |    | second
 4 |    | third
 4 |    | 
 5 | -5 | first
 5 | -5 | first
 5 | -5 | five
 5 | -5 | five
 5 | -5 | forth
 5 | -5 | forth
 5 | -5 | second
 5 | -5 | second
 5 | -5 | third
 5 | -5 | third
 5 | -5 | 
 5 | -5 | 
 5 | -3 | first
 5 | -3 | five
 5 | -3 | forth
 5 | -3 | second
 5 | -3 | third
 5 | -3 | 
 5 | -1 | first
 5 | -1 | five
 5 | -1 | forth
 5 | -1 | second
 5 | -1 | third
 5 | -1 | 
 5 |  0 | first
 5 |  0 | five
 5 |  0 | forth
 5 |  0 | second
 5 |  0 | third
 5 |  0 | 
 5 |  2 | first
 5 |  2 | five
 5 |  2 | forth
 5 |  2 | second
 5 |  2 | third
 5 |  2 | 
 5 |  4 | first
 5 |  4 | five
 5 |  4 | forth
 5 |  4 | second
 5 |  4 | third
 5 |  4 | 
 5 |    | first
 5 |    | five
 5 |    | forth
 5 |    | second
 5 |    | third
 5 |    | 
 6 | -5 | first
 6 | -5 | first
 6 | -5 | five
 6 | -5 | five
 6 | -5 | forth
 6 | -5 | forth
 6 | -5 | second
 6 | -5 | second
 6 | -5 | third
 6 | -5 | third
 6 | -5 | 
 6 | -5 | 
 6 | -3 | first
 6 | -3 | five
 6 | -3 | forth
 6 | -3 | second
 6 | -3 | third
 6 | -3 | 
 6 | -1 | first
 6 | -1 | five
 6 | -1 | forth
 6 | -1 | second
 6 | -1 | third
 6 | -1 | 
 6 |  0 | first
 6 |  0 | five
 6 |  0 | forth
 6 |  0 | second
 6 |  0 | third
 6 |  0 | 
 6 |  2 | first
 6 |  2 | five
 6 |  2 | forth
 6 |  2 | second
 6 |  2 | third
 6 |  2 | 
 6 |  4 | first
 6 |  4 | five
 6 |  4 | forth
 6 |  4 | second
 6 |  4 | third
 6 |  4 | 
 6 |    | first
 6 |    | five
 6 |    | forth
 6 |    | second
 6 |    | third
 6 |    | 
 7 | -5 | first
 7 | -5 | first
 7 | -5 | five
 7 | -5 | five
 7 | -5 | forth
 7 | -5 | forth
 7 | -5 | second
 7 | -5 | second
 7 | -5 | third
 7 | -5 | third
 7 | -5 | 
 7 | -5 | 
 7 | -3 | first
 7 | -3 | five
 7 | -3 | forth
 7 | -3 | second
 7 | -3 | third
 7 | -3 | 
 7 | -1 | first
 7 | -1 | five
 7 | -1 | forth
 7 | -1 | second
 7 | -1 | third
 7 | -1 | 
 7 |  0 | first
 7 |  0 | five
 7 |  0 | forth
 7 |  0 | second
 7 |  0 | third
 7 |  0 | 
 7 |  2 | first
 7 |  2 | five
 7 |  2 | forth
 7 |  2 | second
 7 |  2 | third
 7 |  2 | 
 7 |  4 | first
 7 |  4 | five
 7 |  4 | forth
 7 |  4 | second
 7 |  4 | third
 7 |  4 | 
 7 |    | first
 7 |    | five
 7 |    | forth
 7 |    | second
 7 |    | third
 7 |    | 
 8 | -5 | first
 8 | -5 | first
 8 | -5 | five
 8 | -5 | five
 8 | -5 | forth
 8 | -5 | forth
 8 | -5 | second
 8 | -5 | second
 8 | -5 | third
 8 | -5 | third
 8 | -5 | 
 8 | -5 | 
 8 | -3 | first
 8 | -3 | five
 8 | -3 | forth
 8 | -3 | second
 8 | -3 | third
 8 | -3 | 
 8 | -1 | first
 8 | -1 | five
 8 | -1 | forth
 8 | -1 | second
 8 | -1 | third
 8 | -1 | 
 8 |  0 | first
 8 |  0 | five
 8 |  0 | forth
 8 |  0 | second
 8 |  0 | third
 8 |  0 | 
 8 |  2 | first
 8 |  2 | five
 8 |  2 | forth
 8 |  2 | second
 8 |  2 | third
 8 |  2 | 
 8 |  4 | first
 8 |  4 | five
 8 |  4 | forth
 8 |  4 | second
 8 |  4 | third
 8 |  4 | 
 8 |    | first
 8 |    | five
 8 |    | forth
 8 |    | second
 8 |    | third
 8 |    | 
   | -5 | first
   | -5 | first
   | -5 | first
   | -5 | first
   | -5 | five
   | -5 | five
   | -5 | five
   | -5 | five
   | -5 | forth
   | -5 | forth
   | -5 | forth
   | -5 | forth
   | -5 | second
   | -5 | second
   | -5 | second
   | -5 | second
   | -5 | third
   | -5 | third
   | -5 | third
   | -5 | third
   | -5 | 
   | -5 | 
   | -5 | 
   | -5 | 
   | -3 | first
   | -3 | first
   | -3 | five
   | -3 | five
   | -3 | forth
   | -3 | forth
   | -3 | second
   | -3 | second
   | -3 | third
   | -3 | third
   | -3 | 
   | -3 | 
   | -1 | first
   | -1 | first
   | -1 | five
   | -1 | five
   | -1 | forth
   | -1 | forth
   | -1 | second
   | -1 | second
   | -1 | third
   | -1 | third
   | -1 | 
   | -1 | 
   |  0 | first
   |  0 | first
   |  0 | five
   |  0 | five
   |  0 | forth
   |  0 | forth
   |  0 | second
   |  0 | second
   |  0 | third
   |  0 | third
   |  0 | 
   |  0 | 
   |  2 | first
   |  2 | first
   |  2 | five
   |  2 | five
   |  2 | forth
   |  2 | forth
   |  2 | second
   |  2 | second
   |  2 | third
   |  2 | third
   |  2 | 
   |  2 | 
   |  4 | first
   |  4 | first
   |  4 | five
   |  4 | five
   |  4 | forth
   |  4 | forth
   |  4 | second
   |  4 | second
   |  4 | third
   |  4 | third
   |  4 | 
   |  4 | 
   |    | first
   |    | first
   |    | five
   |    | five
   |    | forth
   |    | forth
   |    | second
   |    | second
   |    | third
   |    | third
   |    | 
   |    | 
(528 rows)

--Join  with USING  __spd_url + GROUP BY + LIMIT + ORDER BY
--Testcase 41:
EXPLAIN VERBOSE SELECT J1_TBL.i, J1_TBL.j, J1_TBL.t FROM J1_TBL LEFT JOIN J2_TBL USING (__spd_url) GROUP BY J1_TBL.i, J1_TBL.j, J1_TBL.t ORDER BY J1_TBL.i LIMIT 5;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=100.00..114.80 rows=5 width=40)
   Output: j1_tbl.i, j1_tbl.j, j1_tbl.t
   ->  Group  (cost=100.00..691.88 rows=200 width=40)
         Output: j1_tbl.i, j1_tbl.j, j1_tbl.t
         Group Key: j1_tbl.i, j1_tbl.j, j1_tbl.t
         ->  Nested Loop Left Join  (cost=100.00..255.05 rows=58243 width=40)
               Output: j1_tbl.i, j1_tbl.j, j1_tbl.t
               Join Filter: (j1_tbl.__spd_url = j2_tbl.__spd_url)
               ->  Foreign Scan on public.j1_tbl  (cost=0.00..0.00 rows=1 width=72)
                     Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Sort push-down: yes
                       Remote SQL: SELECT i, j, t FROM public.j1_tbl ORDER BY i ASC NULLS LAST, j ASC NULLS LAST, t ASC NULLS LAST
               ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=32)
                     Output: j2_tbl.__spd_url
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Sort push-down: no
                       Remote SQL: SELECT NULL FROM public.j2_tbl
(20 rows)

--Testcase 42:
SELECT J1_TBL.i, J1_TBL.j, J1_TBL.t FROM J1_TBL LEFT JOIN J2_TBL USING (__spd_url) GROUP BY J1_TBL.i, J1_TBL.j, J1_TBL.t ORDER BY J1_TBL.i LIMIT 5;
 i | j |   t   
---+---+-------
 0 |   | zero
 1 | 4 | one
 2 | 3 | two
 3 | 2 | three
 4 | 1 | four
(5 rows)

--Testcase 43:
EXPLAIN VERBOSE SELECT J2_TBL.i, J2_TBL.k FROM J1_TBL RIGHT JOIN J2_TBL USING (__spd_url) GROUP BY J2_TBL.i, J2_TBL.k ORDER BY J2_TBL.i LIMIT 5;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Limit  (cost=100.00..111.16 rows=5 width=8)
   Output: j2_tbl.i, j2_tbl.k
   ->  Group  (cost=100.00..546.27 rows=200 width=8)
         Output: j2_tbl.i, j2_tbl.k
         Group Key: j2_tbl.i, j2_tbl.k
         ->  Nested Loop Left Join  (cost=100.00..255.05 rows=58243 width=8)
               Output: j2_tbl.i, j2_tbl.k
               Join Filter: (j1_tbl.__spd_url = j2_tbl.__spd_url)
               ->  Foreign Scan on public.j2_tbl  (cost=0.00..0.00 rows=1 width=40)
                     Output: j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Sort push-down: yes
                       Remote SQL: SELECT i, k FROM public.j2_tbl ORDER BY i ASC NULLS LAST, k ASC NULLS LAST
               ->  Foreign Scan on public.j1_tbl  (cost=100.00..212.39 rows=3413 width=32)
                     Output: j1_tbl.__spd_url
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Sort push-down: no
                       Remote SQL: SELECT NULL FROM public.j1_tbl
(20 rows)

--Testcase 44:
SELECT J2_TBL.i, J2_TBL.k FROM J1_TBL RIGHT JOIN J2_TBL USING (__spd_url) GROUP BY J2_TBL.i, J2_TBL.k ORDER BY J2_TBL.i LIMIT 5;
 i | k  
---+----
 0 |   
 1 | -1
 2 |  2
 2 |  4
 3 | -3
(5 rows)

--Pattern 3
--SELECT __spd_url FROM join clause + LIMIT
--Testcase 45:
EXPLAIN VERBOSE SELECT * FROM J1_TBL LEFT JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i) LIMIT 10;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit  (cost=200.00..230.04 rows=10 width=112)
   Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url
   ->  Nested Loop Left Join  (cost=200.00..175161.85 rows=58243 width=112)
         Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url
         Join Filter: (j1_tbl.i = j2_tbl.i)
         ->  Foreign Scan on public.j1_tbl  (cost=100.00..212.39 rows=3413 width=72)
               Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
               Node: postgres_svr / Status: Alive
                 Limit push-down: no
                 Remote SQL: SELECT i, j, t FROM public.j1_tbl
         ->  Materialize  (cost=100.00..229.45 rows=3413 width=40)
               Output: j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url
               ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=40)
                     Output: j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Remote SQL: SELECT i, k FROM public.j2_tbl
(17 rows)

--Testcase 46:
SELECT * FROM J1_TBL LEFT JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i) LIMIT 10;
 i | j |   t   |   __spd_url    | i | k  |   __spd_url    
---+---+-------+----------------+---+----+----------------
 1 | 4 | one   | /postgres_svr/ | 1 | -1 | /postgres_svr/
 2 | 3 | two   | /postgres_svr/ | 2 |  2 | /postgres_svr/
 2 | 3 | two   | /postgres_svr/ | 2 |  4 | /postgres_svr/
 3 | 2 | three | /postgres_svr/ | 3 | -3 | /postgres_svr/
 4 | 1 | four  | /postgres_svr/ |   |    | 
 5 | 0 | five  | /postgres_svr/ | 5 | -5 | /postgres_svr/
 5 | 0 | five  | /postgres_svr/ | 5 | -5 | /postgres_svr/
 6 | 6 | six   | /postgres_svr/ |   |    | 
 7 | 7 | seven | /postgres_svr/ |   |    | 
 8 | 8 | eight | /postgres_svr/ |   |    | 
(10 rows)

--Testcase 47:
EXPLAIN VERBOSE SELECT * FROM (SELECT * FROM J1_TBL) AS t1 INNER JOIN (SELECT * FROM J2_TBL) t2 USING (i) LIMIT 10;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Limit  (cost=200.00..230.04 rows=10 width=108)
   Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.k, j2_tbl.__spd_url
   ->  Nested Loop  (cost=200.00..175161.85 rows=58243 width=108)
         Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.k, j2_tbl.__spd_url
         Join Filter: (j1_tbl.i = j2_tbl.i)
         ->  Foreign Scan on public.j1_tbl  (cost=100.00..212.39 rows=3413 width=72)
               Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
               Node: postgres_svr / Status: Alive
                 Limit push-down: no
                 Remote SQL: SELECT i, j, t FROM public.j1_tbl
         ->  Materialize  (cost=100.00..229.45 rows=3413 width=40)
               Output: j2_tbl.k, j2_tbl.__spd_url, j2_tbl.i
               ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=40)
                     Output: j2_tbl.k, j2_tbl.__spd_url, j2_tbl.i
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Remote SQL: SELECT i, k FROM public.j2_tbl
(17 rows)

--Testcase 48:
SELECT * FROM (SELECT * FROM J1_TBL) AS t1 INNER JOIN (SELECT * FROM J2_TBL) t2 USING (i) LIMIT 10;
 i | j |   t   |   __spd_url    | k  |   __spd_url    
---+---+-------+----------------+----+----------------
 1 | 4 | one   | /postgres_svr/ | -1 | /postgres_svr/
 2 | 3 | two   | /postgres_svr/ |  2 | /postgres_svr/
 2 | 3 | two   | /postgres_svr/ |  4 | /postgres_svr/
 3 | 2 | three | /postgres_svr/ | -3 | /postgres_svr/
 5 | 0 | five  | /postgres_svr/ | -5 | /postgres_svr/
 5 | 0 | five  | /postgres_svr/ | -5 | /postgres_svr/
 0 |   | zero  | /postgres_svr/ |    | /postgres_svr/
(7 rows)

--Testcase 49:
EXPLAIN VERBOSE SELECT * FROM (SELECT * FROM J1_TBL) AS t1 FULL JOIN (SELECT * FROM J2_TBL) t2 USING (i) LIMIT 10;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Limit  (cost=355.05..355.42 rows=10 width=108)
   Output: (COALESCE(j1_tbl.i, j2_tbl.i)), j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.k, j2_tbl.__spd_url
   ->  Hash Full Join  (cost=355.05..2513.20 rows=58243 width=108)
         Output: COALESCE(j1_tbl.i, j2_tbl.i), j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.k, j2_tbl.__spd_url
         Hash Cond: (j1_tbl.i = j2_tbl.i)
         ->  Foreign Scan on public.j1_tbl  (cost=100.00..212.39 rows=3413 width=72)
               Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
               Node: postgres_svr / Status: Alive
                 Limit push-down: no
                 Remote SQL: SELECT i, j, t FROM public.j1_tbl
         ->  Hash  (cost=212.39..212.39 rows=3413 width=40)
               Output: j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url
               ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=40)
                     Output: j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Remote SQL: SELECT i, k FROM public.j2_tbl
(17 rows)

--Testcase 50:
SELECT * FROM (SELECT * FROM J1_TBL) AS t1 FULL JOIN (SELECT * FROM J2_TBL) t2 USING (i) LIMIT 10;
 i | j |   t   |   __spd_url    | k  |   __spd_url    
---+---+-------+----------------+----+----------------
 1 | 4 | one   | /postgres_svr/ | -1 | /postgres_svr/
 2 | 3 | two   | /postgres_svr/ |  4 | /postgres_svr/
 2 | 3 | two   | /postgres_svr/ |  2 | /postgres_svr/
 3 | 2 | three | /postgres_svr/ | -3 | /postgres_svr/
 4 | 1 | four  | /postgres_svr/ |    | 
 5 | 0 | five  | /postgres_svr/ | -5 | /postgres_svr/
 5 | 0 | five  | /postgres_svr/ | -5 | /postgres_svr/
 6 | 6 | six   | /postgres_svr/ |    | 
 7 | 7 | seven | /postgres_svr/ |    | 
 8 | 8 | eight | /postgres_svr/ |    | 
(10 rows)

--Testcase 51:
EXPLAIN VERBOSE SELECT i, k, t, J1_TBL.__spd_url FROM J1_TBL RIGHT JOIN J2_TBL USING (i) LIMIT 10;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Limit  (cost=200.00..230.04 rows=10 width=72)
   Output: j2_tbl.i, j2_tbl.k, j1_tbl.t, j1_tbl.__spd_url
   ->  Nested Loop Left Join  (cost=200.00..175161.85 rows=58243 width=72)
         Output: j2_tbl.i, j2_tbl.k, j1_tbl.t, j1_tbl.__spd_url
         Join Filter: (j1_tbl.i = j2_tbl.i)
         ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=8)
               Output: j2_tbl.i, j2_tbl.k
               Node: postgres_svr / Status: Alive
                 Limit push-down: no
                 Remote SQL: SELECT i, k FROM public.j2_tbl
         ->  Materialize  (cost=100.00..229.45 rows=3413 width=68)
               Output: j1_tbl.t, j1_tbl.__spd_url, j1_tbl.i
               ->  Foreign Scan on public.j1_tbl  (cost=100.00..212.39 rows=3413 width=68)
                     Output: j1_tbl.t, j1_tbl.__spd_url, j1_tbl.i
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Remote SQL: SELECT i, t FROM public.j1_tbl
(17 rows)

--Testcase 52:
SELECT i, k, t, J1_TBL.__spd_url FROM J1_TBL RIGHT JOIN J2_TBL USING (i) LIMIT 10;
 i | k  |   t   |   __spd_url    
---+----+-------+----------------
 1 | -1 | one   | /postgres_svr/
 2 |  2 | two   | /postgres_svr/
 3 | -3 | three | /postgres_svr/
 2 |  4 | two   | /postgres_svr/
 5 | -5 | five  | /postgres_svr/
 5 | -5 | five  | /postgres_svr/
 0 |    | zero  | /postgres_svr/
   |  0 |       | 
(8 rows)

--SELECT __spd_url FROM join clause + ORDER BY + OFFSET
--Testcase 53:
EXPLAIN VERBOSE SELECT * FROM J1_TBL CROSS JOIN J2_TBL ORDER BY J1_TBL.i OFFSET 1;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit  (cost=100.00..246.52 rows=11648568 width=112)
   Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url
   ->  Nested Loop  (cost=100.00..246.52 rows=11648569 width=112)
         Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url
         ->  Foreign Scan on public.j1_tbl  (cost=0.00..0.00 rows=1 width=72)
               Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
               Node: postgres_svr / Status: Alive
                 Limit push-down: no
                 Sort push-down: yes
                 Remote SQL: SELECT i, j, t FROM public.j1_tbl ORDER BY i ASC NULLS LAST
         ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=40)
               Output: j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url
               Node: postgres_svr / Status: Alive
                 Limit push-down: no
                 Sort push-down: no
                 Remote SQL: SELECT i, k FROM public.j2_tbl
(16 rows)

--Testcase 54:
SELECT * FROM J1_TBL CROSS JOIN J2_TBL ORDER BY J1_TBL.i OFFSET 1;
 i | j |   t   |   __spd_url    | i | k  |   __spd_url    
---+---+-------+----------------+---+----+----------------
 0 |   | zero  | /postgres_svr/ | 2 |  2 | /postgres_svr/
 0 |   | zero  | /postgres_svr/ | 3 | -3 | /postgres_svr/
 0 |   | zero  | /postgres_svr/ | 2 |  4 | /postgres_svr/
 0 |   | zero  | /postgres_svr/ | 5 | -5 | /postgres_svr/
 0 |   | zero  | /postgres_svr/ | 5 | -5 | /postgres_svr/
 0 |   | zero  | /postgres_svr/ | 0 |    | /postgres_svr/
 0 |   | zero  | /postgres_svr/ |   |  0 | /postgres_svr/
 1 | 4 | one   | /postgres_svr/ | 1 | -1 | /postgres_svr/
 1 | 4 | one   | /postgres_svr/ | 2 |  2 | /postgres_svr/
 1 | 4 | one   | /postgres_svr/ | 3 | -3 | /postgres_svr/
 1 | 4 | one   | /postgres_svr/ | 2 |  4 | /postgres_svr/
 1 | 4 | one   | /postgres_svr/ | 5 | -5 | /postgres_svr/
 1 | 4 | one   | /postgres_svr/ | 5 | -5 | /postgres_svr/
 1 | 4 | one   | /postgres_svr/ | 0 |    | /postgres_svr/
 1 | 4 | one   | /postgres_svr/ |   |  0 | /postgres_svr/
 2 | 3 | two   | /postgres_svr/ | 1 | -1 | /postgres_svr/
 2 | 3 | two   | /postgres_svr/ | 2 |  2 | /postgres_svr/
 2 | 3 | two   | /postgres_svr/ | 3 | -3 | /postgres_svr/
 2 | 3 | two   | /postgres_svr/ | 2 |  4 | /postgres_svr/
 2 | 3 | two   | /postgres_svr/ | 5 | -5 | /postgres_svr/
 2 | 3 | two   | /postgres_svr/ | 5 | -5 | /postgres_svr/
 2 | 3 | two   | /postgres_svr/ | 0 |    | /postgres_svr/
 2 | 3 | two   | /postgres_svr/ |   |  0 | /postgres_svr/
 3 | 2 | three | /postgres_svr/ | 1 | -1 | /postgres_svr/
 3 | 2 | three | /postgres_svr/ | 2 |  2 | /postgres_svr/
 3 | 2 | three | /postgres_svr/ | 3 | -3 | /postgres_svr/
 3 | 2 | three | /postgres_svr/ | 2 |  4 | /postgres_svr/
 3 | 2 | three | /postgres_svr/ | 5 | -5 | /postgres_svr/
 3 | 2 | three | /postgres_svr/ | 5 | -5 | /postgres_svr/
 3 | 2 | three | /postgres_svr/ | 0 |    | /postgres_svr/
 3 | 2 | three | /postgres_svr/ |   |  0 | /postgres_svr/
 4 | 1 | four  | /postgres_svr/ | 1 | -1 | /postgres_svr/
 4 | 1 | four  | /postgres_svr/ | 2 |  2 | /postgres_svr/
 4 | 1 | four  | /postgres_svr/ | 3 | -3 | /postgres_svr/
 4 | 1 | four  | /postgres_svr/ | 2 |  4 | /postgres_svr/
 4 | 1 | four  | /postgres_svr/ | 5 | -5 | /postgres_svr/
 4 | 1 | four  | /postgres_svr/ | 5 | -5 | /postgres_svr/
 4 | 1 | four  | /postgres_svr/ | 0 |    | /postgres_svr/
 4 | 1 | four  | /postgres_svr/ |   |  0 | /postgres_svr/
 5 | 0 | five  | /postgres_svr/ | 1 | -1 | /postgres_svr/
 5 | 0 | five  | /postgres_svr/ | 2 |  2 | /postgres_svr/
 5 | 0 | five  | /postgres_svr/ | 3 | -3 | /postgres_svr/
 5 | 0 | five  | /postgres_svr/ | 2 |  4 | /postgres_svr/
 5 | 0 | five  | /postgres_svr/ | 5 | -5 | /postgres_svr/
 5 | 0 | five  | /postgres_svr/ | 5 | -5 | /postgres_svr/
 5 | 0 | five  | /postgres_svr/ | 0 |    | /postgres_svr/
 5 | 0 | five  | /postgres_svr/ |   |  0 | /postgres_svr/
 6 | 6 | six   | /postgres_svr/ | 1 | -1 | /postgres_svr/
 6 | 6 | six   | /postgres_svr/ | 2 |  2 | /postgres_svr/
 6 | 6 | six   | /postgres_svr/ | 3 | -3 | /postgres_svr/
 6 | 6 | six   | /postgres_svr/ | 2 |  4 | /postgres_svr/
 6 | 6 | six   | /postgres_svr/ | 5 | -5 | /postgres_svr/
 6 | 6 | six   | /postgres_svr/ | 5 | -5 | /postgres_svr/
 6 | 6 | six   | /postgres_svr/ | 0 |    | /postgres_svr/
 6 | 6 | six   | /postgres_svr/ |   |  0 | /postgres_svr/
 7 | 7 | seven | /postgres_svr/ | 1 | -1 | /postgres_svr/
 7 | 7 | seven | /postgres_svr/ | 2 |  2 | /postgres_svr/
 7 | 7 | seven | /postgres_svr/ | 3 | -3 | /postgres_svr/
 7 | 7 | seven | /postgres_svr/ | 2 |  4 | /postgres_svr/
 7 | 7 | seven | /postgres_svr/ | 5 | -5 | /postgres_svr/
 7 | 7 | seven | /postgres_svr/ | 5 | -5 | /postgres_svr/
 7 | 7 | seven | /postgres_svr/ | 0 |    | /postgres_svr/
 7 | 7 | seven | /postgres_svr/ |   |  0 | /postgres_svr/
 8 | 8 | eight | /postgres_svr/ | 1 | -1 | /postgres_svr/
 8 | 8 | eight | /postgres_svr/ | 2 |  2 | /postgres_svr/
 8 | 8 | eight | /postgres_svr/ | 3 | -3 | /postgres_svr/
 8 | 8 | eight | /postgres_svr/ | 2 |  4 | /postgres_svr/
 8 | 8 | eight | /postgres_svr/ | 5 | -5 | /postgres_svr/
 8 | 8 | eight | /postgres_svr/ | 5 | -5 | /postgres_svr/
 8 | 8 | eight | /postgres_svr/ | 0 |    | /postgres_svr/
 8 | 8 | eight | /postgres_svr/ |   |  0 | /postgres_svr/
   |   | null  | /postgres_svr/ | 1 | -1 | /postgres_svr/
   |   | null  | /postgres_svr/ | 2 |  2 | /postgres_svr/
   |   | null  | /postgres_svr/ | 3 | -3 | /postgres_svr/
   |   | null  | /postgres_svr/ | 2 |  4 | /postgres_svr/
   |   | null  | /postgres_svr/ | 5 | -5 | /postgres_svr/
   |   | null  | /postgres_svr/ | 5 | -5 | /postgres_svr/
   |   | null  | /postgres_svr/ | 0 |    | /postgres_svr/
   |   | null  | /postgres_svr/ |   |  0 | /postgres_svr/
   | 0 | zero  | /postgres_svr/ | 1 | -1 | /postgres_svr/
   | 0 | zero  | /postgres_svr/ | 2 |  2 | /postgres_svr/
   | 0 | zero  | /postgres_svr/ | 3 | -3 | /postgres_svr/
   | 0 | zero  | /postgres_svr/ | 2 |  4 | /postgres_svr/
   | 0 | zero  | /postgres_svr/ | 5 | -5 | /postgres_svr/
   | 0 | zero  | /postgres_svr/ | 5 | -5 | /postgres_svr/
   | 0 | zero  | /postgres_svr/ | 0 |    | /postgres_svr/
   | 0 | zero  | /postgres_svr/ |   |  0 | /postgres_svr/
(87 rows)

--Testcase 55:
EXPLAIN VERBOSE SELECT * FROM (J1_TBL t1 LEFT JOIN J2_TBL t2 ON (t1.i = t2.i)) x1(a, b, c, d, e) FULL JOIN J2_TBL x2(xx1,xx2) ON (x1.a = xx1) ORDER BY x1.a, x1.b OFFSET 1;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Limit  (cost=264207.97..266692.76 rows=993916 width=152)
   Output: t1.i, t1.j, t1.t, t1.__spd_url, t2.i, t2.k, t2.__spd_url, x2.xx1, x2.xx2, x2.__spd_url
   ->  Sort  (cost=264207.97..266692.76 rows=993917 width=152)
         Output: t1.i, t1.j, t1.t, t1.__spd_url, t2.i, t2.k, t2.__spd_url, x2.xx1, x2.xx2, x2.__spd_url
         Sort Key: t1.i, t1.j
         ->  Merge Full Join  (cost=512.68..15722.09 rows=993917 width=152)
               Output: t1.i, t1.j, t1.t, t1.__spd_url, t2.i, t2.k, t2.__spd_url, x2.xx1, x2.xx2, x2.__spd_url
               Merge Cond: (t1.i = x2.xx1)
               ->  Nested Loop Left Join  (cost=100.00..255.05 rows=58243 width=112)
                     Output: t1.i, t1.j, t1.t, t1.__spd_url, t2.i, t2.k, t2.__spd_url
                     Join Filter: (t1.i = t2.i)
                     ->  Foreign Scan on public.j1_tbl t1  (cost=0.00..0.00 rows=1 width=72)
                           Output: t1.i, t1.j, t1.t, t1.__spd_url
                           Node: postgres_svr / Status: Alive
                             Limit push-down: no
                             Sort push-down: yes
                             Remote SQL: SELECT i, j, t FROM public.j1_tbl ORDER BY i ASC NULLS LAST, j ASC NULLS LAST
                     ->  Foreign Scan on public.j2_tbl t2  (cost=100.00..212.39 rows=3413 width=40)
                           Output: t2.i, t2.k, t2.__spd_url
                           Node: postgres_svr / Status: Alive
                             Limit push-down: no
                             Sort push-down: no
                             Remote SQL: SELECT i, k FROM public.j2_tbl
               ->  Sort  (cost=412.68..421.21 rows=3413 width=40)
                     Output: x2.xx1, x2.xx2, x2.__spd_url
                     Sort Key: x2.xx1
                     ->  Foreign Scan on public.j2_tbl x2  (cost=100.00..212.39 rows=3413 width=40)
                           Output: x2.xx1, x2.xx2, x2.__spd_url
                           Node: postgres_svr / Status: Alive
                             Limit push-down: no
                             Sort push-down: no
                             Remote SQL: SELECT i, k FROM public.j2_tbl
(32 rows)

--Testcase 56:
SELECT * FROM (J1_TBL t1 LEFT JOIN J2_TBL t2 ON (t1.i = t2.i)) x1(a, b, c, d, e) FULL JOIN J2_TBL x2(xx1,xx2) ON (x1.a = xx1) ORDER BY x1.a, x1.b OFFSET 1;
 a | b |   c   |       d        | e | k  |   __spd_url    | xx1 | xx2 |   __spd_url    
---+---+-------+----------------+---+----+----------------+-----+-----+----------------
 1 | 4 | one   | /postgres_svr/ | 1 | -1 | /postgres_svr/ |   1 |  -1 | /postgres_svr/
 2 | 3 | two   | /postgres_svr/ | 2 |  2 | /postgres_svr/ |   2 |   4 | /postgres_svr/
 2 | 3 | two   | /postgres_svr/ | 2 |  4 | /postgres_svr/ |   2 |   4 | /postgres_svr/
 2 | 3 | two   | /postgres_svr/ | 2 |  4 | /postgres_svr/ |   2 |   2 | /postgres_svr/
 2 | 3 | two   | /postgres_svr/ | 2 |  2 | /postgres_svr/ |   2 |   2 | /postgres_svr/
 3 | 2 | three | /postgres_svr/ | 3 | -3 | /postgres_svr/ |   3 |  -3 | /postgres_svr/
 4 | 1 | four  | /postgres_svr/ |   |    |                |     |     | 
 5 | 0 | five  | /postgres_svr/ | 5 | -5 | /postgres_svr/ |   5 |  -5 | /postgres_svr/
 5 | 0 | five  | /postgres_svr/ | 5 | -5 | /postgres_svr/ |   5 |  -5 | /postgres_svr/
 5 | 0 | five  | /postgres_svr/ | 5 | -5 | /postgres_svr/ |   5 |  -5 | /postgres_svr/
 5 | 0 | five  | /postgres_svr/ | 5 | -5 | /postgres_svr/ |   5 |  -5 | /postgres_svr/
 6 | 6 | six   | /postgres_svr/ |   |    |                |     |     | 
 7 | 7 | seven | /postgres_svr/ |   |    |                |     |     | 
 8 | 8 | eight | /postgres_svr/ |   |    |                |     |     | 
   | 0 | zero  | /postgres_svr/ |   |    |                |     |     | 
   |   |       |                |   |    |                |     |   0 | /postgres_svr/
   |   | null  | /postgres_svr/ |   |    |                |     |     | 
(17 rows)

--Testcase 57:
EXPLAIN VERBOSE SELECT J1_TBL.* FROM J1_TBL FULL JOIN J2_TBL ON J1_TBL.i = J2_TBL.i ORDER BY J1_TBL.i, J2_TBL.i OFFSET 2;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Limit  (cost=8915.95..9061.55 rows=58241 width=76)
   Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.i
   ->  Sort  (cost=8915.94..9061.55 rows=58243 width=76)
         Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.i
         Sort Key: j1_tbl.i, j2_tbl.i
         ->  Merge Full Join  (cost=825.36..1716.07 rows=58243 width=76)
               Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.i
               Merge Cond: (j1_tbl.i = j2_tbl.i)
               ->  Sort  (cost=412.68..421.21 rows=3413 width=72)
                     Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
                     Sort Key: j1_tbl.i
                     ->  Foreign Scan on public.j1_tbl  (cost=100.00..212.39 rows=3413 width=72)
                           Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
                           Node: postgres_svr / Status: Alive
                             Limit push-down: no
                             Sort push-down: no
                             Remote SQL: SELECT i, j, t FROM public.j1_tbl
               ->  Sort  (cost=412.68..421.21 rows=3413 width=4)
                     Output: j2_tbl.i
                     Sort Key: j2_tbl.i
                     ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=4)
                           Output: j2_tbl.i
                           Node: postgres_svr / Status: Alive
                             Limit push-down: no
                             Sort push-down: no
                             Remote SQL: SELECT i FROM public.j2_tbl
(26 rows)

--Testcase 58:
SELECT J1_TBL.* FROM J1_TBL FULL JOIN J2_TBL ON J1_TBL.i = J2_TBL.i ORDER BY J1_TBL.i, J2_TBL.i OFFSET 2;
 i | j |   t   |   __spd_url    
---+---+-------+----------------
 2 | 3 | two   | /postgres_svr/
 2 | 3 | two   | /postgres_svr/
 3 | 2 | three | /postgres_svr/
 4 | 1 | four  | /postgres_svr/
 5 | 0 | five  | /postgres_svr/
 5 | 0 | five  | /postgres_svr/
 6 | 6 | six   | /postgres_svr/
 7 | 7 | seven | /postgres_svr/
 8 | 8 | eight | /postgres_svr/
   |   |       | 
   |   | null  | /postgres_svr/
   | 0 | zero  | /postgres_svr/
(12 rows)

--Testcase 59:
EXPLAIN VERBOSE SELECT J2_TBL.* FROM J1_TBL RIGHT JOIN J2_TBL ON J1_TBL.i = J2_TBL.i ORDER BY J2_TBL.i OFFSET 3;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Limit  (cost=100.01..255.05 rows=58240 width=40)
   Output: j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url
   ->  Nested Loop Left Join  (cost=100.00..255.05 rows=58243 width=40)
         Output: j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url
         Join Filter: (j1_tbl.i = j2_tbl.i)
         ->  Foreign Scan on public.j2_tbl  (cost=0.00..0.00 rows=1 width=40)
               Output: j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url
               Node: postgres_svr / Status: Alive
                 Limit push-down: no
                 Sort push-down: yes
                 Remote SQL: SELECT i, k FROM public.j2_tbl ORDER BY i ASC NULLS LAST
         ->  Foreign Scan on public.j1_tbl  (cost=100.00..212.39 rows=3413 width=4)
               Output: j1_tbl.i
               Node: postgres_svr / Status: Alive
                 Limit push-down: no
                 Sort push-down: no
                 Remote SQL: SELECT i FROM public.j1_tbl
(17 rows)

--Testcase 60:
SELECT J2_TBL.* FROM J1_TBL RIGHT JOIN J2_TBL ON J1_TBL.i = J2_TBL.i ORDER BY J2_TBL.i OFFSET 3;
 i | k  |   __spd_url    
---+----+----------------
 2 |  4 | /postgres_svr/
 3 | -3 | /postgres_svr/
 5 | -5 | /postgres_svr/
 5 | -5 | /postgres_svr/
   |  0 | /postgres_svr/
(5 rows)

--Testcase 61:
EXPLAIN VERBOSE SELECT t2.* FROM J1_TBL t1 LEFT JOIN J2_TBL t2 ON t1.i = t2.i ORDER BY t1.i OFFSET 1;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Limit  (cost=100.00..255.05 rows=58242 width=44)
   Output: t2.i, t2.k, t2.__spd_url, t1.i
   ->  Nested Loop Left Join  (cost=100.00..255.05 rows=58243 width=44)
         Output: t2.i, t2.k, t2.__spd_url, t1.i
         Join Filter: (t1.i = t2.i)
         ->  Foreign Scan on public.j1_tbl t1  (cost=0.00..0.00 rows=1 width=4)
               Output: t1.i
               Node: postgres_svr / Status: Alive
                 Limit push-down: no
                 Sort push-down: yes
                 Remote SQL: SELECT i FROM public.j1_tbl ORDER BY i ASC NULLS LAST
         ->  Foreign Scan on public.j2_tbl t2  (cost=100.00..212.39 rows=3413 width=40)
               Output: t2.i, t2.k, t2.__spd_url
               Node: postgres_svr / Status: Alive
                 Limit push-down: no
                 Sort push-down: no
                 Remote SQL: SELECT i, k FROM public.j2_tbl
(17 rows)

--Testcase 62:
SELECT t2.* FROM J1_TBL t1 LEFT JOIN J2_TBL t2 ON t1.i = t2.i ORDER BY t1.i OFFSET 1;
 i | k  |   __spd_url    
---+----+----------------
 1 | -1 | /postgres_svr/
 2 |  2 | /postgres_svr/
 2 |  4 | /postgres_svr/
 3 | -3 | /postgres_svr/
   |    | 
 5 | -5 | /postgres_svr/
 5 | -5 | /postgres_svr/
   |    | 
   |    | 
   |    | 
   |    | 
   |    | 
(12 rows)

--Testcase 63:
EXPLAIN VERBOSE SELECT * FROM J1_TBL INNER JOIN (SELECT distinct i FROM J2_TBL) j2 ON J1_TBL.i = j2.i ORDER BY j2 OFFSET 1;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Limit  (cost=221.91..221.95 rows=16 width=104)
   Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2.i, j2.*
   ->  Sort  (cost=221.91..221.95 rows=17 width=104)
         Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2.i, j2.*
         Sort Key: j2.*
         ->  Hash Join  (cost=100.03..221.56 rows=17 width=104)
               Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2.i, j2.*
               Inner Unique: true
               Hash Cond: (j1_tbl.i = j2.i)
               ->  Foreign Scan on public.j1_tbl  (cost=100.00..212.39 rows=3413 width=72)
                     Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Sort push-down: no
                       Remote SQL: SELECT i, j, t FROM public.j1_tbl
               ->  Hash  (cost=0.01..0.01 rows=1 width=32)
                     Output: j2.i, j2.*
                     ->  Subquery Scan on j2  (cost=0.00..0.01 rows=1 width=32)
                           Output: j2.i, j2.*
                           ->  Unique  (cost=0.00..0.00 rows=1 width=4)
                                 Output: j2_tbl.i
                                 ->  Foreign Scan on public.j2_tbl  (cost=0.00..0.00 rows=1 width=4)
                                       Output: j2_tbl.i
                                       Node: postgres_svr / Status: Alive
                                         Remote SQL: SELECT i FROM public.j2_tbl ORDER BY i ASC NULLS LAST
(25 rows)

--Testcase 64:
SELECT * FROM J1_TBL INNER JOIN (SELECT distinct i FROM J2_TBL) j2 ON J1_TBL.i = j2.i ORDER BY j2 OFFSET 1;
 i | j |   t   |   __spd_url    | i 
---+---+-------+----------------+---
 1 | 4 | one   | /postgres_svr/ | 1
 2 | 3 | two   | /postgres_svr/ | 2
 3 | 2 | three | /postgres_svr/ | 3
 5 | 0 | five  | /postgres_svr/ | 5
(4 rows)

--Testcase 65:
EXPLAIN VERBOSE SELECT t1.i, t2.k, t3.__spd_url FROM J1_TBL t1 RIGHT JOIN (J2_TBL t2 LEFT JOIN J3_TBL t3 ON t2.i > t3.i INNER JOIN J1_TBL t4 ON t2.i = t4.i) ON t1.i = t2.i AND t1.t != t3.t ORDER BY t1.i, t2.k OFFSET 1;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=311173927.02..313986649.99 rows=1125089191 width=40)
   Output: t1.i, t2.k, t3.__spd_url
   ->  Sort  (cost=311173927.01..313986649.99 rows=1125089192 width=40)
         Output: t1.i, t2.k, t3.__spd_url
         Sort Key: t1.i, t2.k
         ->  Merge Join  (cost=919461.30..18974796.86 rows=1125089192 width=40)
               Output: t1.i, t2.k, t3.__spd_url
               Merge Cond: (t4.i = t2.i)
               ->  Sort  (cost=412.68..421.21 rows=3413 width=4)
                     Output: t4.i
                     Sort Key: t4.i
                     ->  Foreign Scan on public.j1_tbl t4  (cost=100.00..212.39 rows=3413 width=4)
                           Output: t4.i
                           Node: postgres_svr / Status: Alive
                             Limit push-down: no
                             Sort push-down: no
                             Remote SQL: SELECT i FROM public.j1_tbl
               ->  Materialize  (cost=919048.62..2262853.40 rows=65929633 width=44)
                     Output: t2.k, t2.i, t3.__spd_url, t1.i
                     ->  Merge Left Join  (cost=919048.62..2098029.32 rows=65929633 width=44)
                           Output: t2.k, t2.i, t3.__spd_url, t1.i
                           Merge Cond: (t2.i = t1.i)
                           Join Filter: (t1.t <> t3.t)
                           ->  Sort  (cost=918635.94..928343.08 rows=3882856 width=72)
                                 Output: t2.k, t2.i, t3.__spd_url, t3.t
                                 Sort Key: t2.i
                                 ->  Nested Loop Left Join  (cost=200.00..175161.85 rows=3882856 width=72)
                                       Output: t2.k, t2.i, t3.__spd_url, t3.t
                                       Join Filter: (t2.i > t3.i)
                                       ->  Foreign Scan on public.j2_tbl t2  (cost=100.00..212.39 rows=3413 width=8)
                                             Output: t2.k, t2.i
                                             Node: postgres_svr / Status: Alive
                                               Limit push-down: no
                                               Sort push-down: no
                                               Remote SQL: SELECT i, k FROM public.j2_tbl
                                       ->  Materialize  (cost=100.00..229.45 rows=3413 width=68)
                                             Output: t3.__spd_url, t3.i, t3.t
                                             ->  Foreign Scan on public.j3_tbl t3  (cost=100.00..212.39 rows=3413 width=68)
                                                   Output: t3.__spd_url, t3.i, t3.t
                                                   Node: postgres_svr / Status: Alive
                                                     Limit push-down: no
                                                     Sort push-down: no
                                                     Remote SQL: SELECT i, t FROM public.j3_tbl
                           ->  Sort  (cost=412.68..421.21 rows=3413 width=36)
                                 Output: t1.i, t1.t
                                 Sort Key: t1.i
                                 ->  Foreign Scan on public.j1_tbl t1  (cost=100.00..212.39 rows=3413 width=36)
                                       Output: t1.i, t1.t
                                       Node: postgres_svr / Status: Alive
                                         Limit push-down: no
                                         Sort push-down: no
                                         Remote SQL: SELECT i, t FROM public.j1_tbl
(52 rows)

--Testcase 66:
SELECT t1.i, t2.k, t3.__spd_url FROM J1_TBL t1 RIGHT JOIN (J2_TBL t2 LEFT JOIN J3_TBL t3 ON t2.i > t3.i INNER JOIN J1_TBL t4 ON t2.i = t4.i) ON t1.i = t2.i AND t1.t != t3.t ORDER BY t1.i, t2.k OFFSET 1;
 i | k  |   __spd_url    
---+----+----------------
 2 |  4 | /postgres_svr/
 3 | -3 | /postgres_svr/
 3 | -3 | /postgres_svr/
 5 | -5 | /postgres_svr/
 5 | -5 | /postgres_svr/
 5 | -5 | /postgres_svr/
 5 | -5 | /postgres_svr/
 5 | -5 | /postgres_svr/
 5 | -5 | /postgres_svr/
 5 | -5 | /postgres_svr/
 5 | -5 | /postgres_svr/
   | -5 | /postgres_svr/
   | -5 | /postgres_svr/
   | -3 | /postgres_svr/
   | -1 | 
   |    | 
(16 rows)

--LATERAL subquery is involved in Join  + LIMIT
--Testcase 67:
EXPLAIN VERBOSE SELECT a.i, x.i FROM J1_TBL a, LATERAL (SELECT * FROM J2_TBL b WHERE i = a.i) x LIMIT 5;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..100.11 rows=0 width=8)
   Output: a.i, b.i
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Relations: (public.j1_tbl a) INNER JOIN (public.j2_tbl b)
     Remote SQL: SELECT r1.i, r3.i FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r3 ON (((r1.i = r3.i)))) LIMIT 5::bigint
(6 rows)

--Testcase 68:
SELECT a.i, x.i FROM J1_TBL a, LATERAL (SELECT * FROM J2_TBL b WHERE i = a.i) x LIMIT 5;
 i | i 
---+---
 1 | 1
 2 | 2
 3 | 3
 2 | 2
 5 | 5
(5 rows)

--Testcase 69:
EXPLAIN VERBOSE SELECT ss.i, x.k FROM J2_TBL x CROSS JOIN LATERAL (SELECT i FROM J1_TBL WHERE i = x.i) ss LIMIT 3;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..100.06 rows=0 width=8)
   Output: j1_tbl.i, x.k
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Relations: (public.j2_tbl x) INNER JOIN (public.j1_tbl)
     Remote SQL: SELECT r4.i, r1.k FROM (public.j2_tbl r1 INNER JOIN public.j1_tbl r4 ON (((r1.i = r4.i)))) LIMIT 3::bigint
(6 rows)

--Testcase 70:
SELECT ss.i, x.k FROM J2_TBL x CROSS JOIN LATERAL (SELECT i FROM J1_TBL WHERE i = x.i) ss LIMIT 3;
 i | k  
---+----
 1 | -1
 2 |  2
 3 | -3
(3 rows)

--Testcase 71:
EXPLAIN VERBOSE SELECT x.i, x.j, x.t FROM J1_TBL x LEFT JOIN LATERAL (SELECT i, k FROM J2_TBL WHERE i=x.i) ss ON true LIMIT 5;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..100.11 rows=0 width=40)
   Output: x.i, x.j, x.t
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Relations: (public.j1_tbl x) LEFT JOIN (public.j2_tbl)
     Remote SQL: SELECT r1.i, r1.j, r1.t FROM (public.j1_tbl r1 LEFT JOIN public.j2_tbl r4 ON (((r4.i = r1.i)))) LIMIT 5::bigint
(6 rows)

--Testcase 72:
SELECT x.i, x.j, x.t FROM J1_TBL x LEFT JOIN LATERAL (SELECT i, k FROM J2_TBL WHERE i=x.i) ss ON true LIMIT 5;
 i | j |   t   
---+---+-------
 1 | 4 | one
 2 | 3 | two
 2 | 3 | two
 3 | 2 | three
 4 | 1 | four
(5 rows)

--SELECT __spd_url, aggregate functions FROM join clause + WHERE + GROUP BY + LIMIT
--Testcase 73:
EXPLAIN VERBOSE SELECT *, count (J1_TBL.i) FROM J1_TBL LEFT JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i) WHERE J1_TBL.i IS NOT NULL GROUP BY J1_TBL.i, J1_TBL.j, J1_TBL.t, J1_TBL.__spd_url, J2_TBL.i, J2_TBL.k, J2_TBL.__spd_url LIMIT 5;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Limit  (cost=847.37..848.25 rows=5 width=120)
   Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url, (count(j1_tbl.i))
   ->  GroupAggregate  (cost=847.37..7879.21 rows=40000 width=120)
         Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url, count(j1_tbl.i)
         Group Key: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url
         ->  Incremental Sort  (cost=847.37..6320.15 rows=57953 width=112)
               Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url
               Sort Key: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url
               Presorted Key: j1_tbl.i
               ->  Merge Left Join  (cost=823.90..1710.17 rows=57953 width=112)
                     Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url
                     Merge Cond: (j1_tbl.i = j2_tbl.i)
                     ->  Sort  (cost=411.22..419.71 rows=3396 width=72)
                           Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
                           Sort Key: j1_tbl.i
                           ->  Foreign Scan on public.j1_tbl  (cost=100.00..212.05 rows=3396 width=72)
                                 Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
                                 Node: postgres_svr / Status: Alive
                                   Limit push-down: no
                                   Remote SQL: SELECT i, j, t FROM public.j1_tbl WHERE ((i IS NOT NULL))
                     ->  Sort  (cost=412.68..421.21 rows=3413 width=40)
                           Output: j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url
                           Sort Key: j2_tbl.i
                           ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=40)
                                 Output: j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url
                                 Node: postgres_svr / Status: Alive
                                   Limit push-down: no
                                   Remote SQL: SELECT i, k FROM public.j2_tbl
(28 rows)

--Testcase 74:
SELECT *, count (J1_TBL.i) FROM J1_TBL LEFT JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i) WHERE J1_TBL.i IS NOT NULL GROUP BY J1_TBL.i, J1_TBL.j, J1_TBL.t, J1_TBL.__spd_url, J2_TBL.i, J2_TBL.k, J2_TBL.__spd_url LIMIT 5;
 i | j |   t   |   __spd_url    | i | k  |   __spd_url    | count 
---+---+-------+----------------+---+----+----------------+-------
 0 |   | zero  | /postgres_svr/ | 0 |    | /postgres_svr/ |     1
 1 | 4 | one   | /postgres_svr/ | 1 | -1 | /postgres_svr/ |     1
 2 | 3 | two   | /postgres_svr/ | 2 |  2 | /postgres_svr/ |     1
 2 | 3 | two   | /postgres_svr/ | 2 |  4 | /postgres_svr/ |     1
 3 | 2 | three | /postgres_svr/ | 3 | -3 | /postgres_svr/ |     1
(5 rows)

--Testcase 75:
EXPLAIN VERBOSE SELECT *, max(t1.i), min(t2.i) FROM (SELECT * FROM J1_TBL) AS t1 INNER JOIN (SELECT * FROM J2_TBL) t2 USING (i) WHERE i IN (1, 2, 3, 4, 5) GROUP BY t1.i, t1.j, t1.t, t1.__spd_url, t2.k, t2.__spd_url LIMIT 5;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=466.81..466.86 rows=5 width=116)
   Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.k, j2_tbl.__spd_url, (max(j1_tbl.i)), (min(j2_tbl.i))
   ->  HashAggregate  (cost=466.81..481.32 rows=1451 width=116)
         Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.k, j2_tbl.__spd_url, max(j1_tbl.i), min(j2_tbl.i)
         Group Key: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.k, j2_tbl.__spd_url
         ->  Hash Join  (cost=268.22..437.79 rows=1451 width=112)
               Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.k, j2_tbl.__spd_url, j2_tbl.i
               Hash Cond: (j2_tbl.i = j1_tbl.i)
               ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=40)
                     Output: j2_tbl.k, j2_tbl.__spd_url, j2_tbl.i
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Remote SQL: SELECT i, k FROM public.j2_tbl
               ->  Hash  (cost=167.16..167.16 rows=85 width=72)
                     Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
                     ->  Foreign Scan on public.j1_tbl  (cost=100.00..167.16 rows=85 width=72)
                           Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
                           Node: postgres_svr / Status: Alive
                             Limit push-down: no
                             Remote SQL: SELECT i, j, t FROM public.j1_tbl WHERE ((i = ANY ('{1,2,3,4,5}'::integer[])))
(20 rows)

--Testcase 76:
SELECT *, max(t1.i), min(t2.i) FROM (SELECT * FROM J1_TBL) AS t1 INNER JOIN (SELECT * FROM J2_TBL) t2 USING (i) WHERE i IN (1, 2, 3, 4, 5) GROUP BY t1.i, t1.j, t1.t, t1.__spd_url, t2.k, t2.__spd_url LIMIT 5;
 i | j |   t   |   __spd_url    | k  |   __spd_url    | max | min 
---+---+-------+----------------+----+----------------+-----+-----
 2 | 3 | two   | /postgres_svr/ |  4 | /postgres_svr/ |   2 |   2
 1 | 4 | one   | /postgres_svr/ | -1 | /postgres_svr/ |   1 |   1
 5 | 0 | five  | /postgres_svr/ | -5 | /postgres_svr/ |   5 |   5
 2 | 3 | two   | /postgres_svr/ |  2 | /postgres_svr/ |   2 |   2
 3 | 2 | three | /postgres_svr/ | -3 | /postgres_svr/ |   3 |   3
(5 rows)

--Testcase 77:
EXPLAIN VERBOSE SELECT *, avg(t1.j) FROM (SELECT * FROM J1_TBL) AS t1 FULL JOIN (SELECT * FROM J2_TBL) t2 USING (i) WHERE t1.j BETWEEN 0 AND 8 GROUP BY t1.i, t1.j, t1.t, t1.__spd_url, t2.i, t2.k, t2.__spd_url LIMIT 5;
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=399.90..399.96 rows=5 width=148)
   Output: (COALESCE(j1_tbl.i, j2_tbl.i)), j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.k, j2_tbl.__spd_url, (avg(j1_tbl.j)), j1_tbl.i, j2_tbl.i
   ->  HashAggregate  (cost=399.90..403.53 rows=290 width=148)
         Output: COALESCE(j1_tbl.i, j2_tbl.i), j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.k, j2_tbl.__spd_url, avg(j1_tbl.j), j1_tbl.i, j2_tbl.i
         Group Key: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url
         ->  Hash Right Join  (cost=261.75..394.10 rows=290 width=112)
               Output: j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.k, j2_tbl.__spd_url, j1_tbl.i, j2_tbl.i
               Hash Cond: (j2_tbl.i = j1_tbl.i)
               ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=40)
                     Output: j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Remote SQL: SELECT i, k FROM public.j2_tbl
               ->  Hash  (cost=161.53..161.53 rows=17 width=72)
                     Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
                     ->  Foreign Scan on public.j1_tbl  (cost=100.00..161.53 rows=17 width=72)
                           Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
                           Node: postgres_svr / Status: Alive
                             Limit push-down: no
                             Remote SQL: SELECT i, j, t FROM public.j1_tbl WHERE ((j >= 0)) AND ((j <= 8))
(20 rows)

--Testcase 78:
SELECT *, avg(t1.j) FROM (SELECT * FROM J1_TBL) AS t1 FULL JOIN (SELECT * FROM J2_TBL) t2 USING (i) WHERE t1.j BETWEEN 0 AND 8 GROUP BY t1.i, t1.j, t1.t, t1.__spd_url, t2.i, t2.k, t2.__spd_url LIMIT 5;
 i | j |   t   |   __spd_url    | k  |   __spd_url    |          avg           
---+---+-------+----------------+----+----------------+------------------------
   | 0 | zero  | /postgres_svr/ |    |                | 0.00000000000000000000
 5 | 0 | five  | /postgres_svr/ | -5 | /postgres_svr/ | 0.00000000000000000000
 4 | 1 | four  | /postgres_svr/ |    |                | 1.00000000000000000000
 8 | 8 | eight | /postgres_svr/ |    |                |     8.0000000000000000
 1 | 4 | one   | /postgres_svr/ | -1 | /postgres_svr/ |     4.0000000000000000
(5 rows)

--Testcase 79:
EXPLAIN VERBOSE SELECT max(J1_TBL.i), max(k), min(t), max(J1_TBL.__spd_url) FROM J1_TBL RIGHT JOIN J2_TBL USING (i) WHERE k < 0 GROUP BY J1_TBL.i, J2_TBL.k, J1_TBL.t, J1_TBL.__spd_url LIMIT 3;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=2326.07..2326.17 rows=3 width=144)
   Output: (max(j1_tbl.i)), (max(j2_tbl.k)), (min(j1_tbl.t)), (max(j1_tbl.__spd_url)), j1_tbl.i, j2_tbl.k, j1_tbl.t, j1_tbl.__spd_url
   ->  GroupAggregate  (cost=2326.07..2957.22 rows=19420 width=144)
         Output: max(j1_tbl.i), max(j2_tbl.k), min(j1_tbl.t), max(j1_tbl.__spd_url), j1_tbl.i, j2_tbl.k, j1_tbl.t, j1_tbl.__spd_url
         Group Key: j1_tbl.i, j2_tbl.k, j1_tbl.t, j1_tbl.__spd_url
         ->  Sort  (cost=2326.07..2374.62 rows=19420 width=72)
               Output: j1_tbl.i, j2_tbl.k, j1_tbl.t, j1_tbl.__spd_url
               Sort Key: j1_tbl.i, j2_tbl.k, j1_tbl.t, j1_tbl.__spd_url
               ->  Merge Left Join  (cost=645.87..942.86 rows=19420 width=72)
                     Output: j1_tbl.i, j2_tbl.k, j1_tbl.t, j1_tbl.__spd_url
                     Merge Cond: (j2_tbl.i = j1_tbl.i)
                     ->  Sort  (cost=233.19..236.03 rows=1138 width=8)
                           Output: j2_tbl.k, j2_tbl.i
                           Sort Key: j2_tbl.i
                           ->  Foreign Scan on public.j2_tbl  (cost=100.00..175.42 rows=1138 width=8)
                                 Output: j2_tbl.k, j2_tbl.i
                                 Node: postgres_svr / Status: Alive
                                   Limit push-down: no
                                   Remote SQL: SELECT i, k FROM public.j2_tbl WHERE ((k < 0))
                     ->  Sort  (cost=412.68..421.21 rows=3413 width=68)
                           Output: j1_tbl.i, j1_tbl.t, j1_tbl.__spd_url
                           Sort Key: j1_tbl.i
                           ->  Foreign Scan on public.j1_tbl  (cost=100.00..212.39 rows=3413 width=68)
                                 Output: j1_tbl.i, j1_tbl.t, j1_tbl.__spd_url
                                 Node: postgres_svr / Status: Alive
                                   Limit push-down: no
                                   Remote SQL: SELECT i, t FROM public.j1_tbl
(27 rows)

--Testcase 80:
SELECT max(J1_TBL.i), max(k), min(t), max(J1_TBL.__spd_url) FROM J1_TBL RIGHT JOIN J2_TBL USING (i) WHERE k < 0 GROUP BY J1_TBL.i, J2_TBL.k, J1_TBL.t, J1_TBL.__spd_url LIMIT 3;
 max | max |  min  |      max       
-----+-----+-------+----------------
   1 |  -1 | one   | /postgres_svr/
   3 |  -3 | three | /postgres_svr/
   5 |  -5 | five  | /postgres_svr/
(3 rows)

--Testcase 81:
EXPLAIN VERBOSE SELECT max(ss1), min(ss2), ii, tt, kk FROM (J1_TBL CROSS JOIN J2_TBL) AS tx (ii, jj, tt, ii2, kk, ss1, ss2) WHERE ii > 0 GROUP BY ss1, ss2, ii, tt, kk LIMIT 5;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Limit  (cost=589058.50..589070.88 rows=5 width=112)
   Output: (max(j2_tbl.k)), (min(j2_tbl.__spd_url)), j1_tbl.i, j1_tbl.t, j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url
   ->  HashAggregate  (cost=589058.50..688075.53 rows=40000 width=112)
         Output: max(j2_tbl.k), min(j2_tbl.__spd_url), j1_tbl.i, j1_tbl.t, j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url
         Group Key: j2_tbl.k, j2_tbl.__spd_url, j1_tbl.i, j1_tbl.t, j2_tbl.i
         Planned Partitions: 4
         ->  Nested Loop  (cost=200.00..48940.58 rows=3883994 width=76)
               Output: j1_tbl.i, j1_tbl.t, j2_tbl.i, j2_tbl.k, j2_tbl.__spd_url
               ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=40)
                     Output: j2_tbl.k, j2_tbl.__spd_url, j2_tbl.i
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Remote SQL: SELECT i, k FROM public.j2_tbl
               ->  Materialize  (cost=100.00..181.11 rows=1138 width=36)
                     Output: j1_tbl.i, j1_tbl.t
                     ->  Foreign Scan on public.j1_tbl  (cost=100.00..175.42 rows=1138 width=36)
                           Output: j1_tbl.i, j1_tbl.t
                           Node: postgres_svr / Status: Alive
                             Limit push-down: no
                             Remote SQL: SELECT i, t FROM public.j1_tbl WHERE ((i > 0))
(20 rows)

--Testcase 82:
SELECT max(ss1), min(ss2), ii, tt, kk FROM (J1_TBL CROSS JOIN J2_TBL) AS tx (ii, jj, tt, ii2, kk, ss1, ss2) WHERE ii > 0 GROUP BY ss1, ss2, ii, tt, kk LIMIT 5;
 max |      min       | ii |  tt   | kk 
-----+----------------+----+-------+----
  -3 | /postgres_svr/ |  5 | five  |  3
  -5 | /postgres_svr/ |  6 | six   |  5
  -3 | /postgres_svr/ |  8 | eight |  3
  -1 | /postgres_svr/ |  3 | three |  1
   2 | /postgres_svr/ |  1 | one   |  2
(5 rows)

--Testcase 83:
EXPLAIN VERBOSE SELECT max(t1.i + t2.i), t1.__spd_url, t2.__spd_url FROM J1_TBL t1 INNER JOIN J2_TBL t2 ON t1.i = t2.i WHERE EXISTS (SELECT t3.i, t FROM J3_TBL t3 CROSS JOIN J2_TBL t4) AND t2.k < 1 GROUP BY t1.i, t2.i, t1.__spd_url, t2.__spd_url LIMIT 5;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Limit  (cost=652.59..653.13 rows=5 width=76)
   Output: (max((t1.i + t2.i))), t1.__spd_url, t2.__spd_url, t1.i, t2.i
   InitPlan 1 (returns $0)
     ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=0)
           Node: postgres_svr / Status: Alive
             Relations: (public.j3_tbl t3) INNER JOIN (public.j2_tbl t4)
             Remote SQL: SELECT NULL FROM (public.j3_tbl r1 INNER JOIN public.j2_tbl r2 ON (TRUE))
   ->  GroupAggregate  (cost=652.59..2746.08 rows=19420 width=76)
         Output: max((t1.i + t2.i)), t1.__spd_url, t2.__spd_url, t1.i, t2.i
         Group Key: t1.i, t2.i, t1.__spd_url, t2.__spd_url
         ->  Incremental Sort  (cost=652.59..2260.58 rows=19420 width=72)
               Output: t1.__spd_url, t2.__spd_url, t1.i, t2.i
               Sort Key: t1.i, t1.__spd_url, t2.__spd_url
               Presorted Key: t1.i
               ->  Result  (cost=645.87..942.86 rows=19420 width=72)
                     Output: t1.__spd_url, t2.__spd_url, t1.i, t2.i
                     One-Time Filter: $0
                     ->  Merge Join  (cost=645.87..942.86 rows=19420 width=72)
                           Output: t1.__spd_url, t2.__spd_url, t1.i, t2.i
                           Merge Cond: (t2.i = t1.i)
                           ->  Sort  (cost=233.19..236.03 rows=1138 width=36)
                                 Output: t2.i, t2.__spd_url
                                 Sort Key: t2.i
                                 ->  Foreign Scan on public.j2_tbl t2  (cost=100.00..175.42 rows=1138 width=36)
                                       Output: t2.i, t2.__spd_url
                                       Node: postgres_svr / Status: Alive
                                         Limit push-down: no
                                         Remote SQL: SELECT i, k FROM public.j2_tbl WHERE ((k < 1))
                           ->  Sort  (cost=412.68..421.21 rows=3413 width=36)
                                 Output: t1.i, t1.__spd_url
                                 Sort Key: t1.i
                                 ->  Foreign Scan on public.j1_tbl t1  (cost=100.00..212.39 rows=3413 width=36)
                                       Output: t1.i, t1.__spd_url
                                       Node: postgres_svr / Status: Alive
                                         Limit push-down: no
                                         Remote SQL: SELECT i FROM public.j1_tbl
(36 rows)

--Testcase 84:
SELECT max(t1.i + t2.i), t1.__spd_url, t2.__spd_url FROM J1_TBL t1 INNER JOIN J2_TBL t2 ON t1.i = t2.i WHERE EXISTS (SELECT t3.i, t FROM J3_TBL t3 CROSS JOIN J2_TBL t4) AND t2.k < 1 GROUP BY t1.i, t2.i, t1.__spd_url, t2.__spd_url LIMIT 5;
 max |   __spd_url    |   __spd_url    
-----+----------------+----------------
   2 | /postgres_svr/ | /postgres_svr/
   6 | /postgres_svr/ | /postgres_svr/
  10 | /postgres_svr/ | /postgres_svr/
(3 rows)

--Pattern 4
--Join  with + HAVING(aggregate function) + GROUP BY + LIMIT + OFFSET
--Testcase 85:
EXPLAIN VERBOSE SELECT t1.i, t1.j, t1.t FROM J1_TBL t1 INNER JOIN J2_TBL t2 USING(i) GROUP BY t1.i, t1.j, t1.t HAVING max(t1.i) NOT IN (1, 2, 3) LIMIT 5 OFFSET 0;
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=87464.27..116684.18 rows=1 width=40)
   Output: t1.i, t1.j, t1.t
   ->  Foreign Scan  (cost=87464.27..116684.18 rows=1 width=40)
         Output: t1.i, t1.j, t1.t
         Filter: ((max(t1.i)) <> ALL ('{1,2,3}'::integer[]))
         Node: postgres_svr / Status: Alive
           Limit push-down: no
           Agg push-down: yes
           Relations: Aggregate on ((public.j1_tbl t1) INNER JOIN (public.j2_tbl t2))
           Remote SQL: SELECT r1.i, r1.j, r1.t, max(r1.i) FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) GROUP BY 1, 2, 3
(10 rows)

--Testcase 86:
SELECT t1.i, t1.j, t1.t FROM J1_TBL t1 INNER JOIN J2_TBL t2 USING(i) GROUP BY t1.i, t1.j, t1.t HAVING max(t1.i) NOT IN (1, 2, 3) LIMIT 5 OFFSET 0;
 i | j |  t   
---+---+------
 0 |   | zero
 5 | 0 | five
(2 rows)

--Testcase 87:
EXPLAIN VERBOSE SELECT t1.i FROM j1_tbl t1 FULL JOIN (SELECT i, k FROM j2_tbl) t2 ON (t1.i = t2.i) GROUP BY t1.__spd_url, t1.i HAVING min(t1.t) != '' LIMIT 3 OFFSET 1;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Limit  (cost=2152.90..2152.94 rows=3 width=36)
   Output: t1.i, t1.__spd_url
   ->  HashAggregate  (cost=2152.89..2155.39 rows=199 width=36)
         Output: t1.i, t1.__spd_url
         Group Key: t1.__spd_url, t1.i
         Filter: (min(t1.t) <> ''::text)
         ->  Merge Full Join  (cost=825.36..1716.07 rows=58243 width=68)
               Output: t1.i, t1.__spd_url, t1.t
               Merge Cond: (t1.i = j2_tbl.i)
               ->  Sort  (cost=412.68..421.21 rows=3413 width=68)
                     Output: t1.i, t1.__spd_url, t1.t
                     Sort Key: t1.i
                     ->  Foreign Scan on public.j1_tbl t1  (cost=100.00..212.39 rows=3413 width=68)
                           Output: t1.i, t1.__spd_url, t1.t
                           Node: postgres_svr / Status: Alive
                             Limit push-down: no
                             Remote SQL: SELECT i, t FROM public.j1_tbl
               ->  Sort  (cost=412.68..421.21 rows=3413 width=4)
                     Output: j2_tbl.i
                     Sort Key: j2_tbl.i
                     ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=4)
                           Output: j2_tbl.i
                           Node: postgres_svr / Status: Alive
                             Limit push-down: no
                             Remote SQL: SELECT i FROM public.j2_tbl
(25 rows)

--Testcase 88:
SELECT t1.i FROM j1_tbl t1 FULL JOIN (SELECT i, k FROM j2_tbl) t2 ON (t1.i = t2.i) GROUP BY t1.__spd_url, t1.i HAVING min(t1.t) != '' LIMIT 3 OFFSET 1;
 i 
---
 5
  
 4
(3 rows)

--Testcase 89:
EXPLAIN VERBOSE SELECT t1.a, t1.b, t1.c, t2.a, t2.b FROM J1_TBL t1 (a, b, c, d) LEFT JOIN J2_TBL t2 (a, b, d) USING (a) GROUP BY t1.a, t1.b, t1.c, t2.a, t2.b, t1.d HAVING max(t1.d) <> '/example' LIMIT 5 OFFSET 1;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Limit  (cost=849.14..850.03 rows=5 width=80)
   Output: t1.a, t1.b, t1.c, t2.a, t2.b, t1.d
   ->  GroupAggregate  (cost=848.97..7871.49 rows=39800 width=80)
         Output: t1.a, t1.b, t1.c, t2.a, t2.b, t1.d
         Group Key: t1.a, t1.b, t1.c, t2.a, t2.b, t1.d
         Filter: (max(t1.d) <> '/example'::text)
         ->  Incremental Sort  (cost=848.97..6352.24 rows=58243 width=80)
               Output: t1.a, t1.b, t1.c, t2.a, t2.b, t1.d
               Sort Key: t1.a, t1.b, t1.c, t2.a, t2.b, t1.d
               Presorted Key: t1.a
               ->  Merge Left Join  (cost=825.36..1716.07 rows=58243 width=80)
                     Output: t1.a, t1.b, t1.c, t2.a, t2.b, t1.d
                     Merge Cond: (t1.a = t2.a)
                     ->  Sort  (cost=412.68..421.21 rows=3413 width=72)
                           Output: t1.a, t1.b, t1.c, t1.d
                           Sort Key: t1.a
                           ->  Foreign Scan on public.j1_tbl t1  (cost=100.00..212.39 rows=3413 width=72)
                                 Output: t1.a, t1.b, t1.c, t1.d
                                 Node: postgres_svr / Status: Alive
                                   Limit push-down: no
                                   Remote SQL: SELECT i, j, t FROM public.j1_tbl
                     ->  Sort  (cost=412.68..421.21 rows=3413 width=8)
                           Output: t2.a, t2.b
                           Sort Key: t2.a
                           ->  Foreign Scan on public.j2_tbl t2  (cost=100.00..212.39 rows=3413 width=8)
                                 Output: t2.a, t2.b
                                 Node: postgres_svr / Status: Alive
                                   Limit push-down: no
                                   Remote SQL: SELECT i, k FROM public.j2_tbl
(29 rows)

--Testcase 90:
SELECT t1.a, t1.b, t1.c, t2.a, t2.b FROM J1_TBL t1 (a, b, c, d) LEFT JOIN J2_TBL t2 (a, b, d) USING (a) GROUP BY t1.a, t1.b, t1.c, t2.a, t2.b, t1.d HAVING max(t1.d) <> '/example' LIMIT 5 OFFSET 1;
 a | b |   c   | a | b  
---+---+-------+---+----
 1 | 4 | one   | 1 | -1
 2 | 3 | two   | 2 |  2
 2 | 3 | two   | 2 |  4
 3 | 2 | three | 3 | -3
 4 | 1 | four  |   |   
(5 rows)

--Testcase 91:
EXPLAIN VERBOSE SELECT t1.i, t2.i, t3.i, t4.i FROM J1_TBL AS t1 LEFT JOIN J2_TBL AS t2 ON t1.i = t2.i RIGHT JOIN J3_TBL AS t3 INNER JOIN J1_TBL AS t4 ON t4.i = t3.i ON t1.i = t3.i GROUP BY t1.i, t2.i, t3.i, t4.i HAVING count(t1.i) > 1 LIMIT 5 OFFSET 0;
                                                                                                                            QUERY PLAN                                                                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=1356891597577.61..1696261917659.95 rows=1 width=16)
   Output: t1.i, t2.i, t3.i, t4.i
   ->  Foreign Scan  (cost=1356891597577.61..1696261917659.95 rows=1 width=16)
         Output: t1.i, t2.i, t3.i, t4.i
         Filter: ((count(t1.i)) > 1)
         Node: postgres_svr / Status: Alive
           Limit push-down: no
           Agg push-down: yes
           Relations: Aggregate on ((((public.j3_tbl t3) INNER JOIN (public.j1_tbl t4)) LEFT JOIN (public.j1_tbl t1)) LEFT JOIN (public.j2_tbl t2))
           Remote SQL: SELECT r1.i, r2.i, r4.i, r5.i, count(r1.i) FROM (((public.j3_tbl r4 INNER JOIN public.j1_tbl r5 ON (((r4.i = r5.i)))) LEFT JOIN public.j1_tbl r1 ON (((r1.i = r4.i)))) LEFT JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) GROUP BY 1, 2, 3, 4
(10 rows)

--Testcase 92:
SELECT t1.i, t2.i, t3.i, t4.i FROM J1_TBL AS t1 LEFT JOIN J2_TBL AS t2 ON t1.i = t2.i RIGHT JOIN J3_TBL AS t3 INNER JOIN J1_TBL AS t4 ON t4.i = t3.i ON t1.i = t3.i GROUP BY t1.i, t2.i, t3.i, t4.i HAVING count(t1.i) > 1 LIMIT 5 OFFSET 0;
 i | i | i | i 
---+---+---+---
 2 | 2 | 2 | 2
 5 | 5 | 5 | 5
(2 rows)

--Join  with + HAVING(aggregate function) + GROUP BY + ORDER BY
--Testcase 93:
EXPLAIN VERBOSE SELECT J1_TBL.i, j, k FROM J1_TBL CROSS JOIN J2_TBL GROUP BY J1_TBL.i, j, k HAVING max(J1_TBL.t) > '$' ORDER BY J1_TBL.i, j, k;
                                                                                                QUERY PLAN                                                                                                
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=91832.48..94005.25 rows=0 width=12)
   Output: j1_tbl.i, j1_tbl.j, j2_tbl.k
   Filter: ((max(j1_tbl.t)) > '$'::text)
   Node: postgres_svr / Status: Alive
     Sort push-down: yes
     Agg push-down: yes
     Relations: Aggregate on ((public.j1_tbl) INNER JOIN (public.j2_tbl))
     Remote SQL: SELECT r1.i, r1.j, r2.k, max(r1.t) FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (TRUE)) GROUP BY 1, 2, 3 ORDER BY r1.i ASC NULLS LAST, r1.j ASC NULLS LAST, r2.k ASC NULLS LAST
(8 rows)

--Testcase 94:
SELECT J1_TBL.i, j, k FROM J1_TBL CROSS JOIN J2_TBL GROUP BY J1_TBL.i, j, k HAVING max(J1_TBL.t) > '$' ORDER BY J1_TBL.i, j, k;
 i | j | k  
---+---+----
 0 |   | -5
 0 |   | -3
 0 |   | -1
 0 |   |  0
 0 |   |  2
 0 |   |  4
 0 |   |   
 1 | 4 | -5
 1 | 4 | -3
 1 | 4 | -1
 1 | 4 |  0
 1 | 4 |  2
 1 | 4 |  4
 1 | 4 |   
 2 | 3 | -5
 2 | 3 | -3
 2 | 3 | -1
 2 | 3 |  0
 2 | 3 |  2
 2 | 3 |  4
 2 | 3 |   
 3 | 2 | -5
 3 | 2 | -3
 3 | 2 | -1
 3 | 2 |  0
 3 | 2 |  2
 3 | 2 |  4
 3 | 2 |   
 4 | 1 | -5
 4 | 1 | -3
 4 | 1 | -1
 4 | 1 |  0
 4 | 1 |  2
 4 | 1 |  4
 4 | 1 |   
 5 | 0 | -5
 5 | 0 | -3
 5 | 0 | -1
 5 | 0 |  0
 5 | 0 |  2
 5 | 0 |  4
 5 | 0 |   
 6 | 6 | -5
 6 | 6 | -3
 6 | 6 | -1
 6 | 6 |  0
 6 | 6 |  2
 6 | 6 |  4
 6 | 6 |   
 7 | 7 | -5
 7 | 7 | -3
 7 | 7 | -1
 7 | 7 |  0
 7 | 7 |  2
 7 | 7 |  4
 7 | 7 |   
 8 | 8 | -5
 8 | 8 | -3
 8 | 8 | -1
 8 | 8 |  0
 8 | 8 |  2
 8 | 8 |  4
 8 | 8 |   
   | 0 | -5
   | 0 | -3
   | 0 | -1
   | 0 |  0
   | 0 |  2
   | 0 |  4
   | 0 |   
   |   | -5
   |   | -3
   |   | -1
   |   |  0
   |   |  2
   |   |  4
   |   |   
(77 rows)

--Testcase 95:
EXPLAIN VERBOSE SELECT J1_TBL.i, J1_TBL.j, J1_TBL.t FROM J1_TBL RIGHT JOIN (SELECT i, k FROM J2_TBL) s ON J1_TBL.i = s.i GROUP BY __spd_url, J1_TBL.i, J1_TBL.j, J1_TBL.t HAVING count(s.i) > 3 ORDER BY J1_TBL.i, J1_TBL.j, J1_TBL.t;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Sort  (cost=2448.64..2448.80 rows=67 width=72)
   Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
   Sort Key: j1_tbl.i, j1_tbl.j, j1_tbl.t
   ->  HashAggregate  (cost=2444.11..2446.61 rows=67 width=72)
         Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
         Group Key: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
         Filter: (count(j2_tbl.i) > 3)
         ->  Merge Left Join  (cost=825.36..1716.07 rows=58243 width=76)
               Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url, j2_tbl.i
               Merge Cond: (j2_tbl.i = j1_tbl.i)
               ->  Sort  (cost=412.68..421.21 rows=3413 width=4)
                     Output: j2_tbl.i
                     Sort Key: j2_tbl.i
                     ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=4)
                           Output: j2_tbl.i
                           Node: postgres_svr / Status: Alive
                             Sort push-down: no
                             Remote SQL: SELECT i FROM public.j2_tbl
               ->  Sort  (cost=412.68..421.21 rows=3413 width=72)
                     Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
                     Sort Key: j1_tbl.i
                     ->  Foreign Scan on public.j1_tbl  (cost=100.00..212.39 rows=3413 width=72)
                           Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
                           Node: postgres_svr / Status: Alive
                             Sort push-down: no
                             Remote SQL: SELECT i, j, t FROM public.j1_tbl
(26 rows)

--Testcase 96:
SELECT J1_TBL.i, J1_TBL.j, J1_TBL.t FROM J1_TBL RIGHT JOIN (SELECT i, k FROM J2_TBL) s ON J1_TBL.i = s.i GROUP BY __spd_url, J1_TBL.i, J1_TBL.j, J1_TBL.t HAVING count(s.i) > 3 ORDER BY J1_TBL.i, J1_TBL.j, J1_TBL.t;
 i | j | t 
---+---+---
(0 rows)

--Testcase 97:
EXPLAIN VERBOSE SELECT x1.a, x1.b, x1.c, x1.d, x1.e, xx1 FROM (J1_TBL t1 LEFT JOIN J2_TBL t2 ON (t1.i = t2.i)) x1(a, b, c, d, e) FULL JOIN J2_TBL x2(xx1,xx2) ON (x1.a = xx1) GROUP BY x1.a, x1.b, x1.c, x1.d, x1.e, xx1 HAVING max(x1.a) > 0 ORDER BY x1.a, x1.b;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=204395.45..236697.75 rows=331306 width=80)
   Output: t1.i, t1.j, t1.t, t1.__spd_url, t2.i, x2.xx1
   Group Key: t1.i, t1.j, t1.t, t1.__spd_url, t2.i, x2.xx1
   Filter: (max(t1.i) > 0)
   ->  Sort  (cost=204395.45..206880.24 rows=993917 width=80)
         Output: t1.i, t1.j, t1.t, t1.__spd_url, t2.i, x2.xx1
         Sort Key: t1.i, t1.j, t1.t, t1.__spd_url, t2.i, x2.xx1
         ->  Merge Full Join  (cost=1238.04..17054.57 rows=993917 width=80)
               Output: t1.i, t1.j, t1.t, t1.__spd_url, t2.i, x2.xx1
               Merge Cond: (x2.xx1 = t1.i)
               ->  Sort  (cost=412.68..421.21 rows=3413 width=4)
                     Output: x2.xx1
                     Sort Key: x2.xx1
                     ->  Foreign Scan on public.j2_tbl x2  (cost=100.00..212.39 rows=3413 width=4)
                           Output: x2.xx1
                           Node: postgres_svr / Status: Alive
                             Sort push-down: no
                             Remote SQL: SELECT i FROM public.j2_tbl
               ->  Materialize  (cost=825.36..1861.68 rows=58243 width=76)
                     Output: t1.i, t1.j, t1.t, t1.__spd_url, t2.i
                     ->  Merge Left Join  (cost=825.36..1716.07 rows=58243 width=76)
                           Output: t1.i, t1.j, t1.t, t1.__spd_url, t2.i
                           Merge Cond: (t1.i = t2.i)
                           ->  Sort  (cost=412.68..421.21 rows=3413 width=72)
                                 Output: t1.i, t1.j, t1.t, t1.__spd_url
                                 Sort Key: t1.i
                                 ->  Foreign Scan on public.j1_tbl t1  (cost=100.00..212.39 rows=3413 width=72)
                                       Output: t1.i, t1.j, t1.t, t1.__spd_url
                                       Node: postgres_svr / Status: Alive
                                         Sort push-down: no
                                         Remote SQL: SELECT i, j, t FROM public.j1_tbl
                           ->  Sort  (cost=412.68..421.21 rows=3413 width=4)
                                 Output: t2.i
                                 Sort Key: t2.i
                                 ->  Foreign Scan on public.j2_tbl t2  (cost=100.00..212.39 rows=3413 width=4)
                                       Output: t2.i
                                       Node: postgres_svr / Status: Alive
                                         Sort push-down: no
                                         Remote SQL: SELECT i FROM public.j2_tbl
(39 rows)

--Testcase 98:
SELECT x1.a, x1.b, x1.c, x1.d, x1.e, xx1 FROM (J1_TBL t1 LEFT JOIN J2_TBL t2 ON (t1.i = t2.i)) x1(a, b, c, d, e) FULL JOIN J2_TBL x2(xx1,xx2) ON (x1.a = xx1) GROUP BY x1.a, x1.b, x1.c, x1.d, x1.e, xx1 HAVING max(x1.a) > 0 ORDER BY x1.a, x1.b;
 a | b |   c   |       d        | e | xx1 
---+---+-------+----------------+---+-----
 1 | 4 | one   | /postgres_svr/ | 1 |   1
 2 | 3 | two   | /postgres_svr/ | 2 |   2
 3 | 2 | three | /postgres_svr/ | 3 |   3
 4 | 1 | four  | /postgres_svr/ |   |    
 5 | 0 | five  | /postgres_svr/ | 5 |   5
 6 | 6 | six   | /postgres_svr/ |   |    
 7 | 7 | seven | /postgres_svr/ |   |    
 8 | 8 | eight | /postgres_svr/ |   |    
(8 rows)

--Join  with aggregate functions not safe + GROUP BY + ORDER BY + LIMIT
--Testcase 99:
EXPLAIN VERBOSE SELECT count(DISTINCT i), string_agg(t, '~!@#' ORDER BY t) FROM J1_TBL FULL JOIN J2_TBL USING (i) GROUP BY i ORDER BY i LIMIT 1;
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.01..0.03 rows=1 width=44)
   Output: (count(DISTINCT (COALESCE(j1_tbl.i, j2_tbl.i)))), (string_agg(j1_tbl.t, '~!@#'::text ORDER BY j1_tbl.t)), (COALESCE(j1_tbl.i, j2_tbl.i))
   ->  GroupAggregate  (cost=0.01..0.03 rows=1 width=44)
         Output: count(DISTINCT (COALESCE(j1_tbl.i, j2_tbl.i))), string_agg(j1_tbl.t, '~!@#'::text ORDER BY j1_tbl.t), (COALESCE(j1_tbl.i, j2_tbl.i))
         Group Key: (COALESCE(j1_tbl.i, j2_tbl.i))
         ->  Sort  (cost=0.01..0.02 rows=0 width=44)
               Output: (COALESCE(j1_tbl.i, j2_tbl.i)), j1_tbl.i, j2_tbl.i, j1_tbl.t
               Sort Key: (COALESCE(j1_tbl.i, j2_tbl.i))
               ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=44)
                     Output: COALESCE(j1_tbl.i, j2_tbl.i), j1_tbl.i, j2_tbl.i, j1_tbl.t
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Sort push-down: no
                       Relations: (public.j1_tbl) FULL JOIN (public.j2_tbl)
                       Remote SQL: SELECT r1.i, r2.i, r1.t FROM (public.j1_tbl r1 FULL JOIN public.j2_tbl r2 ON (((r1.i = r2.i))))
(15 rows)

--Testcase 100:
SELECT count(DISTINCT i), string_agg(t, '~!@#' ORDER BY t) FROM J1_TBL FULL JOIN J2_TBL USING (i) GROUP BY i ORDER BY i LIMIT 1;
 count | string_agg 
-------+------------
     1 | zero
(1 row)

--Testcase 101:
EXPLAIN VERBOSE SELECT string_agg(t, ' ' ORDER BY t) FROM J1_TBL LEFT JOIN J2_TBL USING (i) GROUP BY i ORDER BY i LIMIT 2;
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..0.01 rows=1 width=36)
   Output: (string_agg(j1_tbl.t, ' '::text ORDER BY j1_tbl.t)), j1_tbl.i
   ->  GroupAggregate  (cost=0.00..0.01 rows=1 width=36)
         Output: string_agg(j1_tbl.t, ' '::text ORDER BY j1_tbl.t), j1_tbl.i
         Group Key: j1_tbl.i
         ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=36)
               Output: j1_tbl.i, j1_tbl.t
               Node: postgres_svr / Status: Alive
                 Limit push-down: no
                 Sort push-down: yes
                 Relations: (public.j1_tbl) LEFT JOIN (public.j2_tbl)
                 Remote SQL: SELECT r1.i, r1.t FROM (public.j1_tbl r1 LEFT JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) ORDER BY r1.i ASC NULLS LAST
(12 rows)

--Testcase 102:
SELECT string_agg(t, ' ' ORDER BY t) FROM J1_TBL LEFT JOIN J2_TBL USING (i) GROUP BY i ORDER BY i LIMIT 2;
 string_agg 
------------
 zero
 one
(2 rows)

--Testcase 103:
EXPLAIN VERBOSE SELECT t1.a, string_agg(t1.c, t1.c), t2.d FROM J1_TBL t1 (a, b, c, e) INNER JOIN J2_TBL t2 (a, d, e) USING(a) GROUP BY t1.a, t2.d ORDER BY t1.a LIMIT 3;
                                                                                   QUERY PLAN                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..0.01 rows=1 width=40)
   Output: t1.a, (string_agg(t1.c, t1.c)), t2.d
   ->  GroupAggregate  (cost=0.00..0.01 rows=1 width=40)
         Output: t1.a, string_agg(t1.c, t1.c), t2.d
         Group Key: t1.a, t2.d
         ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=40)
               Output: t1.a, t2.d, t1.c
               Node: postgres_svr / Status: Alive
                 Limit push-down: no
                 Sort push-down: yes
                 Relations: (public.j1_tbl t1) INNER JOIN (public.j2_tbl t2)
                 Remote SQL: SELECT r1.i, r2.k, r1.t FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) ORDER BY r1.i ASC NULLS LAST, r2.k ASC NULLS LAST
(12 rows)

--Testcase 104:
SELECT t1.a, string_agg(t1.c, t1.c), t2.d FROM J1_TBL t1 (a, b, c, e) INNER JOIN J2_TBL t2 (a, d, e) USING(a) GROUP BY t1.a, t2.d ORDER BY t1.a LIMIT 3;
 a | string_agg | d  
---+------------+----
 0 | zero       |   
 1 | one        | -1
 2 | two        |  2
(3 rows)

--Testcase 105:
EXPLAIN VERBOSE SELECT string_agg(t, ' ' ORDER BY t), json_agg(('~!@#', t)) FROM J1_TBL CROSS JOIN J2_TBL GROUP BY t ORDER BY t LIMIT 1;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..0.01 rows=1 width=96)
   Output: (string_agg(j1_tbl.t, ' '::text ORDER BY j1_tbl.t)), (json_agg(ROW('~!@#', j1_tbl.t))), j1_tbl.t
   ->  GroupAggregate  (cost=0.00..0.01 rows=1 width=96)
         Output: string_agg(j1_tbl.t, ' '::text ORDER BY j1_tbl.t), json_agg(ROW('~!@#', j1_tbl.t)), j1_tbl.t
         Group Key: j1_tbl.t
         ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=32)
               Output: j1_tbl.t
               Node: postgres_svr / Status: Alive
                 Limit push-down: no
                 Sort push-down: yes
                 Relations: (public.j1_tbl) INNER JOIN (public.j2_tbl)
                 Remote SQL: SELECT r1.t FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (TRUE)) ORDER BY r1.t ASC NULLS LAST
(12 rows)

--Testcase 106:
SELECT string_agg(t, ' ' ORDER BY t), json_agg(('~!@#', t)) FROM J1_TBL CROSS JOIN J2_TBL GROUP BY t ORDER BY t LIMIT 1;
                   string_agg                    |           json_agg            
-------------------------------------------------+-------------------------------
 eight eight eight eight eight eight eight eight | [{"f1":"~!@#","f2":"eight"}, +
                                                 |  {"f1":"~!@#","f2":"eight"}, +
                                                 |  {"f1":"~!@#","f2":"eight"}, +
                                                 |  {"f1":"~!@#","f2":"eight"}, +
                                                 |  {"f1":"~!@#","f2":"eight"}, +
                                                 |  {"f1":"~!@#","f2":"eight"}, +
                                                 |  {"f1":"~!@#","f2":"eight"}, +
                                                 |  {"f1":"~!@#","f2":"eight"}]
(1 row)

--Testcase 107:
EXPLAIN VERBOSE SELECT count(DISTINCT i), count(*), string_agg(t, ' ' ORDER BY t) FROM J1_TBL RIGHT JOIN J2_TBL USING (i) GROUP BY i, t ORDER BY i, t LIMIT 1;
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..0.01 rows=1 width=84)
   Output: (count(DISTINCT j2_tbl.i)), (count(*)), (string_agg(j1_tbl.t, ' '::text ORDER BY j1_tbl.t)), j2_tbl.i, j1_tbl.t
   ->  GroupAggregate  (cost=0.00..0.01 rows=1 width=84)
         Output: count(DISTINCT j2_tbl.i), count(*), string_agg(j1_tbl.t, ' '::text ORDER BY j1_tbl.t), j2_tbl.i, j1_tbl.t
         Group Key: j2_tbl.i, j1_tbl.t
         ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=36)
               Output: j2_tbl.i, j1_tbl.t
               Node: postgres_svr / Status: Alive
                 Limit push-down: no
                 Sort push-down: yes
                 Relations: (public.j2_tbl) LEFT JOIN (public.j1_tbl)
                 Remote SQL: SELECT r2.i, r1.t FROM (public.j2_tbl r2 LEFT JOIN public.j1_tbl r1 ON (((r1.i = r2.i)))) ORDER BY r2.i ASC NULLS LAST, r1.t ASC NULLS LAST
(12 rows)

--Testcase 108:
SELECT count(DISTINCT i), count(*), string_agg(t, ' ' ORDER BY t) FROM J1_TBL RIGHT JOIN J2_TBL USING (i) GROUP BY i, t ORDER BY i, t LIMIT 1;
 count | count | string_agg 
-------+-------+------------
     1 |     1 | zero
(1 row)

--Testcase 109:
EXPLAIN VERBOSE SELECT t1.i, string_agg(t, ' ' ORDER BY t), t3.t FROM J1_TBL t1 CROSS JOIN J2_TBL t2 INNER JOIN J3_TBL t3 USING(t) GROUP BY t1.i, k, t3.t ORDER BY t1.i LIMIT 5;
                                                                                                                    QUERY PLAN                                                                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.00..0.01 rows=1 width=72)
   Output: t1.i, (string_agg(t1.t, ' '::text ORDER BY t1.t)), t3.t, t2.k
   ->  GroupAggregate  (cost=0.00..0.01 rows=1 width=72)
         Output: t1.i, string_agg(t1.t, ' '::text ORDER BY t1.t), t3.t, t2.k
         Group Key: t1.i, t2.k, t3.t
         ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=72)
               Output: t1.i, t3.t, t2.k, t1.t
               Node: postgres_svr / Status: Alive
                 Limit push-down: no
                 Sort push-down: yes
                 Relations: ((public.j1_tbl t1) INNER JOIN (public.j3_tbl t3)) INNER JOIN (public.j2_tbl t2)
                 Remote SQL: SELECT r1.i, r4.t, r2.k, r1.t FROM ((public.j1_tbl r1 INNER JOIN public.j3_tbl r4 ON (((r1.t = r4.t)))) INNER JOIN public.j2_tbl r2 ON (TRUE)) ORDER BY r1.i ASC NULLS LAST, r2.k ASC NULLS LAST, r1.t ASC NULLS LAST
(12 rows)

--Testcase 110:
SELECT t1.i, string_agg(t, ' ' ORDER BY t), t3.t FROM J1_TBL t1 CROSS JOIN J2_TBL t2 INNER JOIN J3_TBL t3 USING(t) GROUP BY t1.i, k, t3.t ORDER BY t1.i LIMIT 5;
 i | string_agg |  t   
---+------------+------
 5 | five five  | five
 5 | five       | five
 5 | five       | five
 5 | five       | five
 5 | five       | five
(5 rows)

--Pattern 5
--Join  with ORDER BY (__spd_url)
--Testcase 111:
EXPLAIN VERBOSE SELECT J1_TBL.i, k, t FROM J1_TBL CROSS JOIN J2_TBL ORDER BY i, k, t, J1_TBL.__spd_url;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Sort  (cost=2946536.05..2975657.47 rows=11648569 width=72)
   Output: j1_tbl.i, j2_tbl.k, j1_tbl.t, j1_tbl.__spd_url
   Sort Key: j1_tbl.i, j2_tbl.k, j1_tbl.t, j1_tbl.__spd_url
   ->  Nested Loop  (cost=200.00..146040.43 rows=11648569 width=72)
         Output: j1_tbl.i, j2_tbl.k, j1_tbl.t, j1_tbl.__spd_url
         ->  Foreign Scan on public.j1_tbl  (cost=100.00..212.39 rows=3413 width=68)
               Output: j1_tbl.i, j1_tbl.t, j1_tbl.__spd_url
               Node: postgres_svr / Status: Alive
                 Sort push-down: no
                 Remote SQL: SELECT i, t FROM public.j1_tbl
         ->  Materialize  (cost=100.00..229.45 rows=3413 width=4)
               Output: j2_tbl.k
               ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=4)
                     Output: j2_tbl.k
                     Node: postgres_svr / Status: Alive
                       Sort push-down: no
                       Remote SQL: SELECT k FROM public.j2_tbl
(17 rows)

--Testcase 112:
SELECT J1_TBL.i, k, t FROM J1_TBL CROSS JOIN J2_TBL ORDER BY i, k, t, J1_TBL.__spd_url;
 i | k  |   t   
---+----+-------
 0 | -5 | zero
 0 | -5 | zero
 0 | -3 | zero
 0 | -1 | zero
 0 |  0 | zero
 0 |  2 | zero
 0 |  4 | zero
 0 |    | zero
 1 | -5 | one
 1 | -5 | one
 1 | -3 | one
 1 | -1 | one
 1 |  0 | one
 1 |  2 | one
 1 |  4 | one
 1 |    | one
 2 | -5 | two
 2 | -5 | two
 2 | -3 | two
 2 | -1 | two
 2 |  0 | two
 2 |  2 | two
 2 |  4 | two
 2 |    | two
 3 | -5 | three
 3 | -5 | three
 3 | -3 | three
 3 | -1 | three
 3 |  0 | three
 3 |  2 | three
 3 |  4 | three
 3 |    | three
 4 | -5 | four
 4 | -5 | four
 4 | -3 | four
 4 | -1 | four
 4 |  0 | four
 4 |  2 | four
 4 |  4 | four
 4 |    | four
 5 | -5 | five
 5 | -5 | five
 5 | -3 | five
 5 | -1 | five
 5 |  0 | five
 5 |  2 | five
 5 |  4 | five
 5 |    | five
 6 | -5 | six
 6 | -5 | six
 6 | -3 | six
 6 | -1 | six
 6 |  0 | six
 6 |  2 | six
 6 |  4 | six
 6 |    | six
 7 | -5 | seven
 7 | -5 | seven
 7 | -3 | seven
 7 | -1 | seven
 7 |  0 | seven
 7 |  2 | seven
 7 |  4 | seven
 7 |    | seven
 8 | -5 | eight
 8 | -5 | eight
 8 | -3 | eight
 8 | -1 | eight
 8 |  0 | eight
 8 |  2 | eight
 8 |  4 | eight
 8 |    | eight
   | -5 | null
   | -5 | null
   | -5 | zero
   | -5 | zero
   | -3 | null
   | -3 | zero
   | -1 | null
   | -1 | zero
   |  0 | null
   |  0 | zero
   |  2 | null
   |  2 | zero
   |  4 | null
   |  4 | zero
   |    | null
   |    | zero
(88 rows)

--Testcase 113:
EXPLAIN VERBOSE SELECT J1_TBL.i, J1_TBL.j, J1_TBL.t FROM J1_TBL FULL JOIN (SELECT i, k FROM J2_TBL) s ON J1_TBL.i = s.i ORDER BY __spd_url;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Sort  (cost=8716.44..8862.05 rows=58243 width=72)
   Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
   Sort Key: j1_tbl.__spd_url
   ->  Merge Full Join  (cost=825.36..1716.07 rows=58243 width=72)
         Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
         Merge Cond: (j1_tbl.i = j2_tbl.i)
         ->  Sort  (cost=412.68..421.21 rows=3413 width=72)
               Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
               Sort Key: j1_tbl.i
               ->  Foreign Scan on public.j1_tbl  (cost=100.00..212.39 rows=3413 width=72)
                     Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
                     Node: postgres_svr / Status: Alive
                       Sort push-down: no
                       Remote SQL: SELECT i, j, t FROM public.j1_tbl
         ->  Sort  (cost=412.68..421.21 rows=3413 width=4)
               Output: j2_tbl.i
               Sort Key: j2_tbl.i
               ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=4)
                     Output: j2_tbl.i
                     Node: postgres_svr / Status: Alive
                       Sort push-down: no
                       Remote SQL: SELECT i FROM public.j2_tbl
(22 rows)

--Testcase 114:
SELECT J1_TBL.i, J1_TBL.j, J1_TBL.t FROM J1_TBL FULL JOIN (SELECT i, k FROM J2_TBL) s ON J1_TBL.i = s.i ORDER BY __spd_url;
 i | j |   t   
---+---+-------
   | 0 | zero
 1 | 4 | one
 2 | 3 | two
 2 | 3 | two
 3 | 2 | three
 4 | 1 | four
 5 | 0 | five
 5 | 0 | five
 0 |   | zero
 6 | 6 | six
 7 | 7 | seven
 8 | 8 | eight
   |   | null
   |   | 
(14 rows)

--Testcase 115:
EXPLAIN VERBOSE SELECT t2.a, t1.a FROM J1_TBL t1(a, b, c, d) INNER JOIN J2_TBL t2 (a, d, e) USING (a) ORDER BY t1.d;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Sort  (cost=6325.94..6471.55 rows=58243 width=40)
   Output: t2.a, t1.a, t1.d
   Sort Key: t1.d
   ->  Merge Join  (cost=825.36..1716.07 rows=58243 width=40)
         Output: t2.a, t1.a, t1.d
         Merge Cond: (t1.a = t2.a)
         ->  Sort  (cost=412.68..421.21 rows=3413 width=36)
               Output: t1.a, t1.d
               Sort Key: t1.a
               ->  Foreign Scan on public.j1_tbl t1  (cost=100.00..212.39 rows=3413 width=36)
                     Output: t1.a, t1.d
                     Node: postgres_svr / Status: Alive
                       Sort push-down: no
                       Remote SQL: SELECT i FROM public.j1_tbl
         ->  Sort  (cost=412.68..421.21 rows=3413 width=4)
               Output: t2.a
               Sort Key: t2.a
               ->  Foreign Scan on public.j2_tbl t2  (cost=100.00..212.39 rows=3413 width=4)
                     Output: t2.a
                     Node: postgres_svr / Status: Alive
                       Sort push-down: no
                       Remote SQL: SELECT i FROM public.j2_tbl
(22 rows)

--Testcase 116:
SELECT t2.a, t1.a FROM J1_TBL t1(a, b, c, d) INNER JOIN J2_TBL t2 (a, d, e) USING (a) ORDER BY t1.d;
 a | a 
---+---
 0 | 0
 1 | 1
 2 | 2
 2 | 2
 3 | 3
 5 | 5
 5 | 5
(7 rows)

--Testcase 117:
EXPLAIN VERBOSE SELECT t1.c, t1.a, t2.b FROM J1_TBL t1 (a, b, c, e) LEFT JOIN J2_TBL t2(a, b, e) USING (b) ORDER BY t2.b, t2.e;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Sort  (cost=8716.44..8862.05 rows=58243 width=72)
   Output: t1.c, t1.a, t2.b, t2.e
   Sort Key: t2.b, t2.e
   ->  Merge Left Join  (cost=825.36..1716.07 rows=58243 width=72)
         Output: t1.c, t1.a, t2.b, t2.e
         Merge Cond: (t1.b = t2.b)
         ->  Sort  (cost=412.68..421.21 rows=3413 width=40)
               Output: t1.c, t1.a, t1.b
               Sort Key: t1.b
               ->  Foreign Scan on public.j1_tbl t1  (cost=100.00..212.39 rows=3413 width=40)
                     Output: t1.c, t1.a, t1.b
                     Node: postgres_svr / Status: Alive
                       Sort push-down: no
                       Remote SQL: SELECT i, j, t FROM public.j1_tbl
         ->  Sort  (cost=412.68..421.21 rows=3413 width=36)
               Output: t2.b, t2.e
               Sort Key: t2.b
               ->  Foreign Scan on public.j2_tbl t2  (cost=100.00..212.39 rows=3413 width=36)
                     Output: t2.b, t2.e
                     Node: postgres_svr / Status: Alive
                       Sort push-down: no
                       Remote SQL: SELECT k FROM public.j2_tbl
(22 rows)

--Testcase 118:
SELECT t1.c, t1.a, t2.b FROM J1_TBL t1 (a, b, c, e) LEFT JOIN J2_TBL t2(a, b, e) USING (b) ORDER BY t2.b, t2.e;
   c   | a | b 
-------+---+---
 five  | 5 | 0
 zero  |   | 0
 three | 3 | 2
 one   | 1 | 4
 two   | 2 |  
 four  | 4 |  
 six   | 6 |  
 seven | 7 |  
 eight | 8 |  
 zero  | 0 |  
 null  |   |  
(11 rows)

--Testcase 119:
EXPLAIN VERBOSE SELECT a.i, a.j, a.t FROM J1_TBL a RIGHT JOIN (SELECT i FROM J2_TBL y) ss(z) ON a.i = ss.z ORDER BY a.i, a.j, ss.z, a.__spd_url;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Sort  (cost=8915.94..9061.55 rows=58243 width=76)
   Output: a.i, a.j, a.t, y.i, a.__spd_url
   Sort Key: a.i, a.j, y.i, a.__spd_url
   ->  Merge Left Join  (cost=825.36..1716.07 rows=58243 width=76)
         Output: a.i, a.j, a.t, y.i, a.__spd_url
         Merge Cond: (y.i = a.i)
         ->  Sort  (cost=412.68..421.21 rows=3413 width=4)
               Output: y.i
               Sort Key: y.i
               ->  Foreign Scan on public.j2_tbl y  (cost=100.00..212.39 rows=3413 width=4)
                     Output: y.i
                     Node: postgres_svr / Status: Alive
                       Sort push-down: no
                       Remote SQL: SELECT i FROM public.j2_tbl
         ->  Sort  (cost=412.68..421.21 rows=3413 width=72)
               Output: a.i, a.j, a.t, a.__spd_url
               Sort Key: a.i
               ->  Foreign Scan on public.j1_tbl a  (cost=100.00..212.39 rows=3413 width=72)
                     Output: a.i, a.j, a.t, a.__spd_url
                     Node: postgres_svr / Status: Alive
                       Sort push-down: no
                       Remote SQL: SELECT i, j, t FROM public.j1_tbl
(22 rows)

--Testcase 120:
SELECT a.i, a.j, a.t FROM J1_TBL a RIGHT JOIN (SELECT i FROM J2_TBL y) ss(z) ON a.i = ss.z ORDER BY a.i, a.j, ss.z, a.__spd_url;
 i | j |   t   
---+---+-------
 0 |   | zero
 1 | 4 | one
 2 | 3 | two
 2 | 3 | two
 3 | 2 | three
 5 | 0 | five
 5 | 0 | five
   |   | 
(8 rows)

--Testcase 121:
EXPLAIN VERBOSE SELECT t1.i, j, t3.t FROM J1_TBL t1 FULL JOIN J2_TBL t2 ON t1.i = t2.i LEFT JOIN J3_TBL t3 ON t3.i = 1 ORDER BY t1.i, t1.j, t1.__spd_url, t3.t;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Sort  (cost=194077.23..196552.56 rows=990131 width=72)
   Output: t1.i, t1.j, t3.t, t1.__spd_url
   Sort Key: t1.i, t1.j, t1.__spd_url, t3.t
   ->  Nested Loop Left Join  (cost=925.36..14245.75 rows=990131 width=72)
         Output: t1.i, t1.j, t3.t, t1.__spd_url
         ->  Merge Full Join  (cost=825.36..1716.07 rows=58243 width=40)
               Output: t1.i, t1.j, t1.__spd_url
               Merge Cond: (t1.i = t2.i)
               ->  Sort  (cost=412.68..421.21 rows=3413 width=40)
                     Output: t1.i, t1.j, t1.__spd_url
                     Sort Key: t1.i
                     ->  Foreign Scan on public.j1_tbl t1  (cost=100.00..212.39 rows=3413 width=40)
                           Output: t1.i, t1.j, t1.__spd_url
                           Node: postgres_svr / Status: Alive
                             Sort push-down: no
                             Remote SQL: SELECT i, j FROM public.j1_tbl
               ->  Sort  (cost=412.68..421.21 rows=3413 width=4)
                     Output: t2.i
                     Sort Key: t2.i
                     ->  Foreign Scan on public.j2_tbl t2  (cost=100.00..212.39 rows=3413 width=4)
                           Output: t2.i
                           Node: postgres_svr / Status: Alive
                             Sort push-down: no
                             Remote SQL: SELECT i FROM public.j2_tbl
         ->  Materialize  (cost=100.00..153.09 rows=17 width=32)
               Output: t3.t
               ->  Foreign Scan on public.j3_tbl t3  (cost=100.00..153.00 rows=17 width=32)
                     Output: t3.t
                     Node: postgres_svr / Status: Alive
                       Sort push-down: no
                       Remote SQL: SELECT i, t FROM public.j3_tbl WHERE ((i = 1))
(31 rows)

--Testcase 122:
SELECT t1.i, j, t3.t FROM J1_TBL t1 FULL JOIN J2_TBL t2 ON t1.i = t2.i LEFT JOIN J3_TBL t3 ON t3.i = 1 ORDER BY t1.i, t1.j, t1.__spd_url, t3.t;
 i | j |   t   
---+---+-------
 0 |   | first
 1 | 4 | first
 2 | 3 | first
 2 | 3 | first
 3 | 2 | first
 4 | 1 | first
 5 | 0 | first
 5 | 0 | first
 6 | 6 | first
 7 | 7 | first
 8 | 8 | first
   | 0 | first
   |   | first
   |   | first
(14 rows)

--Join  + ORDER BY (__spd_url) + OFFSET
--Testcase 123:
EXPLAIN VERBOSE SELECT t1.i, k, t FROM J1_TBL t1 INNER JOIN J2_TBL t2 ON t2.i = 0 ORDER BY t1.i, t1.__spd_url OFFSET 1;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Limit  (cost=8061.40..8206.45 rows=58020 width=72)
   Output: t1.i, t2.k, t1.t, t1.__spd_url
   ->  Sort  (cost=8061.40..8206.45 rows=58021 width=72)
         Output: t1.i, t2.k, t1.t, t1.__spd_url
         Sort Key: t1.i, t1.__spd_url
         ->  Nested Loop  (cost=200.00..1090.70 rows=58021 width=72)
               Output: t1.i, t2.k, t1.t, t1.__spd_url
               ->  Foreign Scan on public.j1_tbl t1  (cost=100.00..212.39 rows=3413 width=68)
                     Output: t1.i, t1.t, t1.__spd_url
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Sort push-down: no
                       Remote SQL: SELECT i, t FROM public.j1_tbl
               ->  Materialize  (cost=100.00..153.09 rows=17 width=4)
                     Output: t2.k
                     ->  Foreign Scan on public.j2_tbl t2  (cost=100.00..153.00 rows=17 width=4)
                           Output: t2.k
                           Node: postgres_svr / Status: Alive
                             Limit push-down: no
                             Sort push-down: no
                             Remote SQL: SELECT i, k FROM public.j2_tbl WHERE ((i = 0))
(21 rows)

--Testcase 124:
SELECT t1.i, k, t FROM J1_TBL t1 INNER JOIN J2_TBL t2 ON t2.i = 0 ORDER BY t1.i, t1.__spd_url OFFSET 1;
 i | k |   t   
---+---+-------
 1 |   | one
 2 |   | two
 3 |   | three
 4 |   | four
 5 |   | five
 6 |   | six
 7 |   | seven
 8 |   | eight
   |   | null
   |   | zero
(10 rows)

--Testcase 125:
EXPLAIN VERBOSE SELECT t2.i, k, t FROM J1_TBL x CROSS JOIN J2_TBL t2 ORDER BY t2.__spd_url OFFSET 2;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Limit  (cost=2946536.05..2975657.47 rows=11648567 width=72)
   Output: t2.i, t2.k, x.t, t2.__spd_url
   ->  Sort  (cost=2946536.05..2975657.47 rows=11648569 width=72)
         Output: t2.i, t2.k, x.t, t2.__spd_url
         Sort Key: t2.__spd_url
         ->  Nested Loop  (cost=200.00..146040.43 rows=11648569 width=72)
               Output: t2.i, t2.k, x.t, t2.__spd_url
               ->  Foreign Scan on public.j1_tbl x  (cost=100.00..212.39 rows=3413 width=32)
                     Output: x.t
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Sort push-down: no
                       Remote SQL: SELECT t FROM public.j1_tbl
               ->  Materialize  (cost=100.00..229.45 rows=3413 width=40)
                     Output: t2.i, t2.k, t2.__spd_url
                     ->  Foreign Scan on public.j2_tbl t2  (cost=100.00..212.39 rows=3413 width=40)
                           Output: t2.i, t2.k, t2.__spd_url
                           Node: postgres_svr / Status: Alive
                             Limit push-down: no
                             Sort push-down: no
                             Remote SQL: SELECT i, k FROM public.j2_tbl
(21 rows)

--Testcase 126:
SELECT t2.i, k, t FROM J1_TBL x CROSS JOIN J2_TBL t2 ORDER BY t2.__spd_url OFFSET 2;
 i | k  |   t   
---+----+-------
 3 | -3 | one
 2 |  4 | one
 5 | -5 | one
 5 | -5 | one
 0 |    | one
   |  0 | one
 1 | -1 | two
 2 |  2 | two
 3 | -3 | two
 2 |  4 | two
 5 | -5 | two
 5 | -5 | two
 0 |    | two
   |  0 | two
 1 | -1 | three
 2 |  2 | three
 3 | -3 | three
 2 |  4 | three
 5 | -5 | three
 5 | -5 | three
 0 |    | three
   |  0 | three
 1 | -1 | four
 2 |  2 | four
 3 | -3 | four
 2 |  4 | four
 5 | -5 | four
 5 | -5 | four
 0 |    | four
   |  0 | four
 1 | -1 | five
 2 |  2 | five
 3 | -3 | five
 2 |  4 | five
 5 | -5 | five
 5 | -5 | five
 0 |    | five
   |  0 | five
 1 | -1 | six
 2 |  2 | six
 3 | -3 | six
 2 |  4 | six
 5 | -5 | six
 5 | -5 | six
 0 |    | six
   |  0 | six
 1 | -1 | seven
 2 |  2 | seven
 3 | -3 | seven
 2 |  4 | seven
 5 | -5 | seven
 5 | -5 | seven
 0 |    | seven
   |  0 | seven
 1 | -1 | eight
 2 |  2 | eight
 3 | -3 | eight
 2 |  4 | eight
 5 | -5 | eight
 5 | -5 | eight
 0 |    | eight
   |  0 | eight
 1 | -1 | zero
 2 |  2 | zero
 3 | -3 | zero
 2 |  4 | zero
 5 | -5 | zero
 5 | -5 | zero
 0 |    | zero
   |  0 | zero
 1 | -1 | null
 2 |  2 | null
 3 | -3 | null
 2 |  4 | null
 5 | -5 | null
 5 | -5 | null
 0 |    | null
   |  0 | null
 1 | -1 | zero
 2 |  2 | zero
 3 | -3 | zero
 2 |  4 | zero
 5 | -5 | zero
 5 | -5 | zero
 0 |    | zero
   |  0 | zero
(86 rows)

--Testcase 127:
EXPLAIN VERBOSE SELECT t1.a, t1.b, t2.d FROM J1_TBL t1(a, b, c, f) FULL JOIN J2_TBL t2(d, e, f) ON t1.a = t2.d ORDER BY t1.f OFFSET 3;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Limit  (cost=6325.95..6471.55 rows=58240 width=44)
   Output: t1.a, t1.b, t2.d, t1.f
   ->  Sort  (cost=6325.94..6471.55 rows=58243 width=44)
         Output: t1.a, t1.b, t2.d, t1.f
         Sort Key: t1.f
         ->  Merge Full Join  (cost=825.36..1716.07 rows=58243 width=44)
               Output: t1.a, t1.b, t2.d, t1.f
               Merge Cond: (t1.a = t2.d)
               ->  Sort  (cost=412.68..421.21 rows=3413 width=40)
                     Output: t1.a, t1.b, t1.f
                     Sort Key: t1.a
                     ->  Foreign Scan on public.j1_tbl t1  (cost=100.00..212.39 rows=3413 width=40)
                           Output: t1.a, t1.b, t1.f
                           Node: postgres_svr / Status: Alive
                             Limit push-down: no
                             Sort push-down: no
                             Remote SQL: SELECT i, j FROM public.j1_tbl
               ->  Sort  (cost=412.68..421.21 rows=3413 width=4)
                     Output: t2.d
                     Sort Key: t2.d
                     ->  Foreign Scan on public.j2_tbl t2  (cost=100.00..212.39 rows=3413 width=4)
                           Output: t2.d
                           Node: postgres_svr / Status: Alive
                             Limit push-down: no
                             Sort push-down: no
                             Remote SQL: SELECT i FROM public.j2_tbl
(26 rows)

--Testcase 128:
SELECT t1.a, t1.b, t2.d FROM J1_TBL t1(a, b, c, f) FULL JOIN J2_TBL t2(d, e, f) ON t1.a = t2.d ORDER BY t1.f OFFSET 3;
 a | b | d 
---+---+---
 2 | 3 | 2
 3 | 2 | 3
 4 | 1 |  
 5 | 0 | 5
 5 | 0 | 5
 0 |   | 0
 6 | 6 |  
 7 | 7 |  
 8 | 8 |  
   |   |  
   |   |  
(11 rows)

--Testcase 129:
EXPLAIN VERBOSE SELECT a.i, a.j, x.i, x.j, ss.z FROM J1_TBL a, J1_TBL x LEFT JOIN (SELECT i FROM J2_TBL y) ss(z) ON x.i = ss.z ORDER BY a.__spd_url OFFSET 5;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=54576444.14..55073401.20 rows=198782825 width=52)
   Output: a.i, a.j, x.i, x.j, y.i, a.__spd_url
   ->  Sort  (cost=54576444.13..55073401.20 rows=198782830 width=52)
         Output: a.i, a.j, x.i, x.j, y.i, a.__spd_url
         Sort Key: a.__spd_url
         ->  Nested Loop  (cost=100.00..246.52 rows=198782830 width=52)
               Output: a.i, a.j, x.i, x.j, y.i, a.__spd_url
               ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=12)
                     Output: x.i, x.j, y.i
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Sort push-down: no
                       Relations: (public.j1_tbl x) LEFT JOIN (public.j2_tbl y)
                       Remote SQL: SELECT r2.i, r2.j, r5.i FROM (public.j1_tbl r2 LEFT JOIN public.j2_tbl r5 ON (((r2.i = r5.i))))
               ->  Foreign Scan on public.j1_tbl a  (cost=100.00..212.39 rows=3413 width=40)
                     Output: a.i, a.j, a.__spd_url
                     Node: postgres_svr / Status: Alive
                       Limit push-down: no
                       Sort push-down: no
                       Remote SQL: SELECT i, j FROM public.j1_tbl
(20 rows)

--Testcase 130:
SELECT a.i, a.j, x.i, x.j, ss.z FROM J1_TBL a, J1_TBL x LEFT JOIN (SELECT i FROM J2_TBL y) ss(z) ON x.i = ss.z ORDER BY a.__spd_url OFFSET 5;
 i | j | i | j | z 
---+---+---+---+---
 6 | 6 | 1 | 4 | 1
 7 | 7 | 1 | 4 | 1
 8 | 8 | 1 | 4 | 1
 0 |   | 1 | 4 | 1
   |   | 1 | 4 | 1
   | 0 | 1 | 4 | 1
 1 | 4 | 2 | 3 | 2
 2 | 3 | 2 | 3 | 2
 3 | 2 | 2 | 3 | 2
 4 | 1 | 2 | 3 | 2
 5 | 0 | 2 | 3 | 2
 6 | 6 | 2 | 3 | 2
 7 | 7 | 2 | 3 | 2
 8 | 8 | 2 | 3 | 2
 0 |   | 2 | 3 | 2
   |   | 2 | 3 | 2
   | 0 | 2 | 3 | 2
 1 | 4 | 3 | 2 | 3
 2 | 3 | 3 | 2 | 3
 3 | 2 | 3 | 2 | 3
 4 | 1 | 3 | 2 | 3
 5 | 0 | 3 | 2 | 3
 6 | 6 | 3 | 2 | 3
 7 | 7 | 3 | 2 | 3
 8 | 8 | 3 | 2 | 3
 0 |   | 3 | 2 | 3
   |   | 3 | 2 | 3
   | 0 | 3 | 2 | 3
 1 | 4 | 2 | 3 | 2
 2 | 3 | 2 | 3 | 2
 3 | 2 | 2 | 3 | 2
 4 | 1 | 2 | 3 | 2
 5 | 0 | 2 | 3 | 2
 6 | 6 | 2 | 3 | 2
 7 | 7 | 2 | 3 | 2
 8 | 8 | 2 | 3 | 2
 0 |   | 2 | 3 | 2
   |   | 2 | 3 | 2
   | 0 | 2 | 3 | 2
 1 | 4 | 5 | 0 | 5
 2 | 3 | 5 | 0 | 5
 3 | 2 | 5 | 0 | 5
 4 | 1 | 5 | 0 | 5
 5 | 0 | 5 | 0 | 5
 6 | 6 | 5 | 0 | 5
 7 | 7 | 5 | 0 | 5
 8 | 8 | 5 | 0 | 5
 0 |   | 5 | 0 | 5
   |   | 5 | 0 | 5
   | 0 | 5 | 0 | 5
 1 | 4 | 5 | 0 | 5
 2 | 3 | 5 | 0 | 5
 3 | 2 | 5 | 0 | 5
 4 | 1 | 5 | 0 | 5
 5 | 0 | 5 | 0 | 5
 6 | 6 | 5 | 0 | 5
 7 | 7 | 5 | 0 | 5
 8 | 8 | 5 | 0 | 5
 0 |   | 5 | 0 | 5
   |   | 5 | 0 | 5
   | 0 | 5 | 0 | 5
 1 | 4 | 0 |   | 0
 2 | 3 | 0 |   | 0
 3 | 2 | 0 |   | 0
 4 | 1 | 0 |   | 0
 5 | 0 | 0 |   | 0
 6 | 6 | 0 |   | 0
 7 | 7 | 0 |   | 0
 8 | 8 | 0 |   | 0
 0 |   | 0 |   | 0
   |   | 0 |   | 0
   | 0 | 0 |   | 0
 1 | 4 |   | 0 |  
 2 | 3 |   | 0 |  
 3 | 2 |   | 0 |  
 4 | 1 |   | 0 |  
 5 | 0 |   | 0 |  
 6 | 6 |   | 0 |  
 7 | 7 |   | 0 |  
 8 | 8 |   | 0 |  
 0 |   |   | 0 |  
   |   |   | 0 |  
   | 0 |   | 0 |  
 1 | 4 |   |   |  
 2 | 3 |   |   |  
 3 | 2 |   |   |  
 4 | 1 |   |   |  
 5 | 0 |   |   |  
 6 | 6 |   |   |  
 7 | 7 |   |   |  
 8 | 8 |   |   |  
 0 |   |   |   |  
   |   |   |   |  
   | 0 |   |   |  
 1 | 4 | 8 | 8 |  
 2 | 3 | 8 | 8 |  
 3 | 2 | 8 | 8 |  
 4 | 1 | 8 | 8 |  
 5 | 0 | 8 | 8 |  
 6 | 6 | 8 | 8 |  
 7 | 7 | 8 | 8 |  
 8 | 8 | 8 | 8 |  
 0 |   | 8 | 8 |  
   |   | 8 | 8 |  
   | 0 | 8 | 8 |  
 1 | 4 | 6 | 6 |  
 2 | 3 | 6 | 6 |  
 3 | 2 | 6 | 6 |  
 4 | 1 | 6 | 6 |  
 5 | 0 | 6 | 6 |  
 6 | 6 | 6 | 6 |  
 7 | 7 | 6 | 6 |  
 8 | 8 | 6 | 6 |  
 0 |   | 6 | 6 |  
   |   | 6 | 6 |  
   | 0 | 6 | 6 |  
 1 | 4 | 7 | 7 |  
 2 | 3 | 7 | 7 |  
 3 | 2 | 7 | 7 |  
 4 | 1 | 7 | 7 |  
 5 | 0 | 7 | 7 |  
 6 | 6 | 7 | 7 |  
 7 | 7 | 7 | 7 |  
 8 | 8 | 7 | 7 |  
 0 |   | 7 | 7 |  
   |   | 7 | 7 |  
   | 0 | 7 | 7 |  
 1 | 4 | 4 | 1 |  
 2 | 3 | 4 | 1 |  
 3 | 2 | 4 | 1 |  
 4 | 1 | 4 | 1 |  
 5 | 0 | 4 | 1 |  
 6 | 6 | 4 | 1 |  
 7 | 7 | 4 | 1 |  
 8 | 8 | 4 | 1 |  
 0 |   | 4 | 1 |  
   |   | 4 | 1 |  
   | 0 | 4 | 1 |  
(138 rows)

--Testcase 131:
EXPLAIN VERBOSE SELECT f1.i, f1.j, f2.i FROM J1_TBL f1 RIGHT JOIN J2_TBL f2 ON (f1.i = f2.i AND f1.j IS NOT NULL) ORDER BY f1.__spd_url OFFSET 3;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Limit  (cost=6295.01..6439.89 rows=57950 width=44)
   Output: f1.i, f1.j, f2.i, f1.__spd_url
   ->  Sort  (cost=6295.01..6439.89 rows=57953 width=44)
         Output: f1.i, f1.j, f2.i, f1.__spd_url
         Sort Key: f1.__spd_url
         ->  Merge Right Join  (cost=823.90..1710.17 rows=57953 width=44)
               Output: f1.i, f1.j, f2.i, f1.__spd_url
               Merge Cond: (f1.i = f2.i)
               ->  Sort  (cost=411.22..419.71 rows=3396 width=40)
                     Output: f1.i, f1.j, f1.__spd_url
                     Sort Key: f1.i
                     ->  Foreign Scan on public.j1_tbl f1  (cost=100.00..212.05 rows=3396 width=40)
                           Output: f1.i, f1.j, f1.__spd_url
                           Node: postgres_svr / Status: Alive
                             Limit push-down: no
                             Sort push-down: no
                             Remote SQL: SELECT i, j FROM public.j1_tbl WHERE ((j IS NOT NULL))
               ->  Sort  (cost=412.68..421.21 rows=3413 width=4)
                     Output: f2.i
                     Sort Key: f2.i
                     ->  Foreign Scan on public.j2_tbl f2  (cost=100.00..212.39 rows=3413 width=4)
                           Output: f2.i
                           Node: postgres_svr / Status: Alive
                             Limit push-down: no
                             Sort push-down: no
                             Remote SQL: SELECT i FROM public.j2_tbl
(26 rows)

--Testcase 132:
SELECT f1.i, f1.j, f2.i FROM J1_TBL f1 RIGHT JOIN J2_TBL f2 ON (f1.i = f2.i AND f1.j IS NOT NULL) ORDER BY f1.__spd_url OFFSET 3;
 i | j | i 
---+---+---
 2 | 3 | 2
 3 | 2 | 3
 5 | 0 | 5
   |   |  
   |   | 0
(5 rows)

--Testcase 133:
EXPLAIN VERBOSE SELECT t1.i, t2.i, t3.i, t4.i FROM J1_TBL AS t1 LEFT JOIN J2_TBL AS t2 ON t1.i = t2.i RIGHT JOIN J3_TBL AS t3 INNER JOIN J1_TBL AS t4 ON t4.i = t3.i ON t1.i = t3.i WHERE t1.i IS NOT NULL ORDER BY t1.__spd_url OFFSET 1;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=3585259.30..3627451.14 rows=16876738 width=48)
   Output: t1.i, t2.i, t3.i, t4.i, t1.__spd_url
   ->  Sort  (cost=3585259.29..3627451.14 rows=16876739 width=48)
         Output: t1.i, t2.i, t3.i, t4.i, t1.__spd_url
         Sort Key: t1.__spd_url
         ->  Merge Join  (cost=823.91..1855.08 rows=16876739 width=48)
               Output: t1.i, t2.i, t3.i, t4.i, t1.__spd_url
               Merge Cond: (t1.i = t4.i)
               ->  Merge Left Join  (cost=823.90..1710.17 rows=57953 width=40)
                     Output: t1.i, t1.__spd_url, t2.i
                     Merge Cond: (t1.i = t2.i)
                     ->  Sort  (cost=411.22..419.71 rows=3396 width=36)
                           Output: t1.i, t1.__spd_url
                           Sort Key: t1.i
                           ->  Foreign Scan on public.j1_tbl t1  (cost=100.00..212.05 rows=3396 width=36)
                                 Output: t1.i, t1.__spd_url
                                 Node: postgres_svr / Status: Alive
                                   Limit push-down: no
                                   Sort push-down: no
                                   Remote SQL: SELECT i FROM public.j1_tbl WHERE ((i IS NOT NULL))
                     ->  Sort  (cost=412.68..421.21 rows=3413 width=4)
                           Output: t2.i
                           Sort Key: t2.i
                           ->  Foreign Scan on public.j2_tbl t2  (cost=100.00..212.39 rows=3413 width=4)
                                 Output: t2.i
                                 Node: postgres_svr / Status: Alive
                                   Limit push-down: no
                                   Sort push-down: no
                                   Remote SQL: SELECT i FROM public.j2_tbl
               ->  Sort  (cost=0.01..0.02 rows=0 width=8)
                     Output: t3.i, t4.i
                     Sort Key: t3.i
                     ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=8)
                           Output: t3.i, t4.i
                           Node: postgres_svr / Status: Alive
                             Limit push-down: no
                             Sort push-down: no
                             Relations: (public.j3_tbl t3) INNER JOIN (public.j1_tbl t4)
                             Remote SQL: SELECT r4.i, r5.i FROM (public.j3_tbl r4 INNER JOIN public.j1_tbl r5 ON (((r4.i = r5.i))))
(39 rows)

--Testcase 134:
SELECT t1.i, t2.i, t3.i, t4.i FROM J1_TBL AS t1 LEFT JOIN J2_TBL AS t2 ON t1.i = t2.i RIGHT JOIN J3_TBL AS t3 INNER JOIN J1_TBL AS t4 ON t4.i = t3.i ON t1.i = t3.i WHERE t1.i IS NOT NULL ORDER BY t1.__spd_url OFFSET 1;
 i | i | i | i 
---+---+---+---
 2 | 2 | 2 | 2
 2 | 2 | 2 | 2
 2 | 2 | 2 | 2
 2 | 2 | 2 | 2
 3 | 3 | 3 | 3
 4 |   | 4 | 4
 5 | 5 | 5 | 5
 5 | 5 | 5 | 5
(8 rows)

--Join  + aggregate functions + GROUP BY + ORDER BY(__spd_url) + LIMIT
--Testcase 135:
EXPLAIN VERBOSE SELECT max(t1.i + t1.j), t1.t, t2.i, t2.k FROM J1_TBL t1 INNER JOIN J2_TBL t2 USING(i) GROUP BY t1.i, t1.j, t1.t, t2.i, t2.k, t1.__spd_url ORDER BY t1.__spd_url LIMIT 5;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Limit  (cost=8915.94..8916.16 rows=5 width=84)
   Output: (max((t1.i + t1.j))), t1.t, t2.i, t2.k, t1.__spd_url, t1.i, t1.j
   ->  GroupAggregate  (cost=8915.94..10626.41 rows=40000 width=84)
         Output: max((t1.i + t1.j)), t1.t, t2.i, t2.k, t1.__spd_url, t1.i, t1.j
         Group Key: t1.__spd_url, t1.i, t1.j, t1.t, t2.i, t2.k
         ->  Sort  (cost=8915.94..9061.55 rows=58243 width=80)
               Output: t1.t, t2.i, t2.k, t1.__spd_url, t1.i, t1.j
               Sort Key: t1.__spd_url, t2.i, t1.j, t1.t, t2.k
               ->  Merge Join  (cost=825.36..1716.07 rows=58243 width=80)
                     Output: t1.t, t2.i, t2.k, t1.__spd_url, t1.i, t1.j
                     Merge Cond: (t1.i = t2.i)
                     ->  Sort  (cost=412.68..421.21 rows=3413 width=72)
                           Output: t1.i, t1.j, t1.t, t1.__spd_url
                           Sort Key: t1.i
                           ->  Foreign Scan on public.j1_tbl t1  (cost=100.00..212.39 rows=3413 width=72)
                                 Output: t1.i, t1.j, t1.t, t1.__spd_url
                                 Node: postgres_svr / Status: Alive
                                   Limit push-down: no
                                   Sort push-down: no
                                   Remote SQL: SELECT i, j, t FROM public.j1_tbl
                     ->  Sort  (cost=412.68..421.21 rows=3413 width=8)
                           Output: t2.i, t2.k
                           Sort Key: t2.i
                           ->  Foreign Scan on public.j2_tbl t2  (cost=100.00..212.39 rows=3413 width=8)
                                 Output: t2.i, t2.k
                                 Node: postgres_svr / Status: Alive
                                   Limit push-down: no
                                   Sort push-down: no
                                   Remote SQL: SELECT i, k FROM public.j2_tbl
(29 rows)

--Testcase 136:
SELECT max(t1.i + t1.j), t1.t, t2.i, t2.k FROM J1_TBL t1 INNER JOIN J2_TBL t2 USING(i) GROUP BY t1.i, t1.j, t1.t, t2.i, t2.k, t1.__spd_url ORDER BY t1.__spd_url LIMIT 5;
 max |   t   | i | k  
-----+-------+---+----
     | zero  | 0 |   
   5 | one   | 1 | -1
   5 | two   | 2 |  2
   5 | two   | 2 |  4
   5 | three | 3 | -3
(5 rows)

--Testcase 137:
EXPLAIN VERBOSE SELECT min(t1.i) FROM j1_tbl t1 FULL JOIN (SELECT i, k FROM j2_tbl) t2 ON (t1.i = t2.i) GROUP BY t1.i, t2.i, t1.__spd_url ORDER BY t1.__spd_url LIMIT 3;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Limit  (cost=6325.94..6326.03 rows=3 width=44)
   Output: (min(t1.i)), t1.__spd_url, t1.i, j2_tbl.i
   ->  GroupAggregate  (cost=6325.94..7453.98 rows=40000 width=44)
         Output: min(t1.i), t1.__spd_url, t1.i, j2_tbl.i
         Group Key: t1.__spd_url, t1.i, j2_tbl.i
         ->  Sort  (cost=6325.94..6471.55 rows=58243 width=40)
               Output: t1.__spd_url, t1.i, j2_tbl.i
               Sort Key: t1.__spd_url, t1.i, j2_tbl.i
               ->  Merge Full Join  (cost=825.36..1716.07 rows=58243 width=40)
                     Output: t1.__spd_url, t1.i, j2_tbl.i
                     Merge Cond: (t1.i = j2_tbl.i)
                     ->  Sort  (cost=412.68..421.21 rows=3413 width=36)
                           Output: t1.i, t1.__spd_url
                           Sort Key: t1.i
                           ->  Foreign Scan on public.j1_tbl t1  (cost=100.00..212.39 rows=3413 width=36)
                                 Output: t1.i, t1.__spd_url
                                 Node: postgres_svr / Status: Alive
                                   Limit push-down: no
                                   Sort push-down: no
                                   Remote SQL: SELECT i FROM public.j1_tbl
                     ->  Sort  (cost=412.68..421.21 rows=3413 width=4)
                           Output: j2_tbl.i
                           Sort Key: j2_tbl.i
                           ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=4)
                                 Output: j2_tbl.i
                                 Node: postgres_svr / Status: Alive
                                   Limit push-down: no
                                   Sort push-down: no
                                   Remote SQL: SELECT i FROM public.j2_tbl
(29 rows)

--Testcase 138:
SELECT min(t1.i) FROM j1_tbl t1 FULL JOIN (SELECT i, k FROM j2_tbl) t2 ON (t1.i = t2.i) GROUP BY t1.i, t2.i, t1.__spd_url ORDER BY t1.__spd_url LIMIT 3;
 min 
-----
   0
   1
   2
(3 rows)

--Testcase 139:
EXPLAIN VERBOSE SELECT avg(t1.i * t1.j), t1.t, sum(t2.i - t2.k) FROM J1_TBL t1 LEFT JOIN J2_TBL t2 USING (i) GROUP BY t1.t, t2.__spd_url ORDER BY t2.__spd_url LIMIT 5;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Limit  (cost=8915.94..8916.13 rows=5 width=104)
   Output: (avg((t1.i * t1.j))), t1.t, (sum((t2.i - t2.k))), t2.__spd_url
   ->  GroupAggregate  (cost=8915.94..10435.19 rows=40000 width=104)
         Output: avg((t1.i * t1.j)), t1.t, sum((t2.i - t2.k)), t2.__spd_url
         Group Key: t2.__spd_url, t1.t
         ->  Sort  (cost=8915.94..9061.55 rows=58243 width=80)
               Output: t1.t, t2.__spd_url, t1.i, t1.j, t2.i, t2.k
               Sort Key: t2.__spd_url, t1.t
               ->  Merge Left Join  (cost=825.36..1716.07 rows=58243 width=80)
                     Output: t1.t, t2.__spd_url, t1.i, t1.j, t2.i, t2.k
                     Merge Cond: (t1.i = t2.i)
                     ->  Sort  (cost=412.68..421.21 rows=3413 width=40)
                           Output: t1.i, t1.j, t1.t
                           Sort Key: t1.i
                           ->  Foreign Scan on public.j1_tbl t1  (cost=100.00..212.39 rows=3413 width=40)
                                 Output: t1.i, t1.j, t1.t
                                 Node: postgres_svr / Status: Alive
                                   Limit push-down: no
                                   Sort push-down: no
                                   Remote SQL: SELECT i, j, t FROM public.j1_tbl
                     ->  Sort  (cost=412.68..421.21 rows=3413 width=40)
                           Output: t2.i, t2.k, t2.__spd_url
                           Sort Key: t2.i
                           ->  Foreign Scan on public.j2_tbl t2  (cost=100.00..212.39 rows=3413 width=40)
                                 Output: t2.i, t2.k, t2.__spd_url
                                 Node: postgres_svr / Status: Alive
                                   Limit push-down: no
                                   Sort push-down: no
                                   Remote SQL: SELECT i, k FROM public.j2_tbl
(29 rows)

--Testcase 140:
SELECT avg(t1.i * t1.j), t1.t, sum(t2.i - t2.k) FROM J1_TBL t1 LEFT JOIN J2_TBL t2 USING (i) GROUP BY t1.t, t2.__spd_url ORDER BY t2.__spd_url LIMIT 5;
          avg           |   t   | sum 
------------------------+-------+-----
 0.00000000000000000000 | five  |  20
     4.0000000000000000 | one   |   2
     6.0000000000000000 | three |   6
     6.0000000000000000 | two   |  -2
                        | zero  |    
(5 rows)

--Testcase 141:
EXPLAIN VERBOSE SELECT J1_TBL.i, max(j), k FROM J1_TBL CROSS JOIN J2_TBL GROUP BY J1_TBL.i, j, k, J1_TBL.__spd_url ORDER BY J1_TBL.__spd_url LIMIT 5;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit  (cost=1549483.31..1549483.33 rows=5 width=48)
   Output: j1_tbl.i, (max(j1_tbl.j)), j2_tbl.k, j1_tbl.__spd_url, j1_tbl.j
   ->  Sort  (cost=1549483.31..1549583.31 rows=40000 width=48)
         Output: j1_tbl.i, (max(j1_tbl.j)), j2_tbl.k, j1_tbl.__spd_url, j1_tbl.j
         Sort Key: j1_tbl.__spd_url
         ->  HashAggregate  (cost=1343658.93..1548818.93 rows=40000 width=48)
               Output: j1_tbl.i, max(j1_tbl.j), j2_tbl.k, j1_tbl.__spd_url, j1_tbl.j
               Group Key: j1_tbl.__spd_url, j1_tbl.i, j1_tbl.j, j2_tbl.k
               ->  Nested Loop  (cost=200.00..146040.43 rows=11648569 width=44)
                     Output: j1_tbl.i, j2_tbl.k, j1_tbl.__spd_url, j1_tbl.j
                     ->  Foreign Scan on public.j1_tbl  (cost=100.00..212.39 rows=3413 width=40)
                           Output: j1_tbl.i, j1_tbl.j, j1_tbl.__spd_url
                           Node: postgres_svr / Status: Alive
                             Limit push-down: no
                             Sort push-down: no
                             Remote SQL: SELECT i, j FROM public.j1_tbl
                     ->  Materialize  (cost=100.00..229.45 rows=3413 width=4)
                           Output: j2_tbl.k
                           ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=4)
                                 Output: j2_tbl.k
                                 Node: postgres_svr / Status: Alive
                                   Limit push-down: no
                                   Sort push-down: no
                                   Remote SQL: SELECT k FROM public.j2_tbl
(24 rows)

--Testcase 142:
SELECT J1_TBL.i, max(j), k FROM J1_TBL CROSS JOIN J2_TBL GROUP BY J1_TBL.i, j, k, J1_TBL.__spd_url ORDER BY J1_TBL.__spd_url LIMIT 5;
 i | max | k  
---+-----+----
 2 |   3 |  0
 6 |   6 |   
 8 |   8 |   
 0 |     |  2
 6 |   6 | -1
(5 rows)

--Testcase 143:
EXPLAIN VERBOSE SELECT sum(J1_TBL.i) + avg(J1_TBL.j), count(J1_TBL.t) FROM J1_TBL RIGHT JOIN (SELECT i, k FROM J2_TBL) s ON J1_TBL.i = s.i GROUP BY J1_TBL.__spd_url ORDER BY J1_TBL.__spd_url LIMIT 3;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Limit  (cost=2304.58..2304.59 rows=3 width=72)
   Output: (((sum(j1_tbl.i))::numeric + avg(j1_tbl.j))), (count(j1_tbl.t)), j1_tbl.__spd_url
   ->  Sort  (cost=2304.58..2305.08 rows=200 width=72)
         Output: (((sum(j1_tbl.i))::numeric + avg(j1_tbl.j))), (count(j1_tbl.t)), j1_tbl.__spd_url
         Sort Key: j1_tbl.__spd_url
         ->  HashAggregate  (cost=2298.50..2302.00 rows=200 width=72)
               Output: ((sum(j1_tbl.i))::numeric + avg(j1_tbl.j)), count(j1_tbl.t), j1_tbl.__spd_url
               Group Key: j1_tbl.__spd_url
               ->  Merge Left Join  (cost=825.36..1716.07 rows=58243 width=72)
                     Output: j1_tbl.__spd_url, j1_tbl.i, j1_tbl.j, j1_tbl.t
                     Merge Cond: (j2_tbl.i = j1_tbl.i)
                     ->  Sort  (cost=412.68..421.21 rows=3413 width=4)
                           Output: j2_tbl.i
                           Sort Key: j2_tbl.i
                           ->  Foreign Scan on public.j2_tbl  (cost=100.00..212.39 rows=3413 width=4)
                                 Output: j2_tbl.i
                                 Node: postgres_svr / Status: Alive
                                   Limit push-down: no
                                   Sort push-down: no
                                   Remote SQL: SELECT i FROM public.j2_tbl
                     ->  Sort  (cost=412.68..421.21 rows=3413 width=72)
                           Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
                           Sort Key: j1_tbl.i
                           ->  Foreign Scan on public.j1_tbl  (cost=100.00..212.39 rows=3413 width=72)
                                 Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j1_tbl.__spd_url
                                 Node: postgres_svr / Status: Alive
                                   Limit push-down: no
                                   Sort push-down: no
                                   Remote SQL: SELECT i, j, t FROM public.j1_tbl
(29 rows)

--Testcase 144:
SELECT sum(J1_TBL.i) + avg(J1_TBL.j), count(J1_TBL.t) FROM J1_TBL RIGHT JOIN (SELECT i, k FROM J2_TBL) s ON J1_TBL.i = s.i GROUP BY J1_TBL.__spd_url ORDER BY J1_TBL.__spd_url LIMIT 3;
      ?column?       | count 
---------------------+-------
 20.0000000000000000 |     7
                     |     0
(2 rows)

--Testcase 145:
EXPLAIN VERBOSE SELECT count(k), max(t3.t) FROM J1_TBL t1 CROSS JOIN J2_TBL t2 INNER JOIN J3_TBL t3 USING(t) GROUP BY k, t3.t, t3.__spd_url ORDER BY t3.__spd_url LIMIT 5;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=29756673.63..29756673.65 rows=5 width=108)
   Output: (count(t2.k)), (max(t3.t)), t3.__spd_url, t2.k, t3.t
   ->  Sort  (cost=29756673.63..29756773.63 rows=40000 width=108)
         Output: (count(t2.k)), (max(t3.t)), t3.__spd_url, t2.k, t3.t
         Sort Key: t3.__spd_url
         ->  HashAggregate  (cost=25096624.27..29756009.25 rows=40000 width=108)
               Output: count(t2.k), max(t3.t), t3.__spd_url, t2.k, t3.t
               Group Key: t3.__spd_url, t2.k, t3.t
               Planned Partitions: 4
               ->  Hash Join  (cost=100.00..225.20 rows=198783359 width=68)
                     Output: t3.__spd_url, t2.k, t3.t
                     Hash Cond: (t3.t = t1.t)
                     ->  Foreign Scan on public.j3_tbl t3  (cost=100.00..212.39 rows=3413 width=64)
                           Output: t3.t, t3.__spd_url
                           Node: postgres_svr / Status: Alive
                             Limit push-down: no
                             Sort push-down: no
                             Remote SQL: SELECT t FROM public.j3_tbl
                     ->  Hash  (cost=0.00..0.00 rows=0 width=36)
                           Output: t2.k, t1.t
                           ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=36)
                                 Output: t2.k, t1.t
                                 Node: postgres_svr / Status: Alive
                                   Limit push-down: no
                                   Sort push-down: no
                                   Relations: (public.j2_tbl t2) INNER JOIN (public.j1_tbl t1)
                                   Remote SQL: SELECT r2.k, r1.t FROM (public.j2_tbl r2 INNER JOIN public.j1_tbl r1 ON (TRUE))
(27 rows)

--Testcase 146:
SELECT count(k), max(t3.t) FROM J1_TBL t1 CROSS JOIN J2_TBL t2 INNER JOIN J3_TBL t3 USING(t) GROUP BY k, t3.t, t3.__spd_url ORDER BY t3.__spd_url LIMIT 5;
 count | max  
-------+------
     1 | five
     1 | five
     0 | five
     1 | five
     2 | five
(5 rows)

--Pattern 7+8
--Join  with WHERE + LIMIT
--Testcase 147:
EXPLAIN VERBOSE SELECT k, t FROM J1_TBL INNER JOIN J2_TBL USING (i) WHERE J1_TBL.i <= J2_TBL.k LIMIT 5;
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..100.12 rows=0 width=36)
   Output: j2_tbl.k, j1_tbl.t
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Relations: (public.j1_tbl) INNER JOIN (public.j2_tbl)
     Remote SQL: SELECT r2.k, r1.t FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (((r1.i <= r2.k)) AND ((r1.i = r2.i)))) LIMIT 5::bigint
(6 rows)

--Testcase 148:
SELECT k, t FROM J1_TBL INNER JOIN J2_TBL USING (i) WHERE J1_TBL.i <= J2_TBL.k LIMIT 5;
 k |  t  
---+-----
 2 | two
 4 | two
(2 rows)

--Testcase 149:
EXPLAIN VERBOSE SELECT t1.i, k, t FROM J1_TBL t1 CROSS JOIN J2_TBL t2 WHERE t1.i = t2.i LIMIT 3;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..100.06 rows=0 width=40)
   Output: t1.i, t2.k, t1.t
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Relations: (public.j1_tbl t1) INNER JOIN (public.j2_tbl t2)
     Remote SQL: SELECT r1.i, r2.k, r1.t FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) LIMIT 3::bigint
(6 rows)

--Testcase 150:
SELECT t1.i, k, t FROM J1_TBL t1 CROSS JOIN J2_TBL t2 WHERE t1.i = t2.i LIMIT 3;
 i | k  |   t   
---+----+-------
 1 | -1 | one
 2 |  2 | two
 3 | -3 | three
(3 rows)

--Testcase 151:
EXPLAIN VERBOSE SELECT k, t FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k != 1) LIMIT 1;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..100.02 rows=0 width=36)
   Output: j2_tbl.k, j1_tbl.t
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Relations: (public.j1_tbl) INNER JOIN (public.j2_tbl)
     Remote SQL: SELECT r2.k, r1.t FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (((r1.i = r2.i)) AND ((r2.k <> 1)))) LIMIT 1::bigint
(6 rows)

--Testcase 152:
SELECT k, t FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k != 1) LIMIT 1;
 k  |  t  
----+-----
 -1 | one
(1 row)

--Testcase 153:
EXPLAIN VERBOSE SELECT t1.i, k, t FROM J1_TBL t1 FULL JOIN J2_TBL t2 USING (i) WHERE k IS NOT NULL LIMIT 5;
                                                                         QUERY PLAN                                                                         
------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..100.11 rows=0 width=40)
   Output: t1.i, t2.k, t1.t
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Relations: (public.j2_tbl t2) LEFT JOIN (public.j1_tbl t1)
     Remote SQL: SELECT r1.i, r2.k, r1.t FROM (public.j2_tbl r2 LEFT JOIN public.j1_tbl r1 ON (((r1.i = r2.i)))) WHERE ((r2.k IS NOT NULL)) LIMIT 5::bigint
(6 rows)

--Testcase 154:
SELECT t1.i, k, t FROM J1_TBL t1 FULL JOIN J2_TBL t2 USING (i) WHERE k IS NOT NULL LIMIT 5;
 i | k  |   t   
---+----+-------
 1 | -1 | one
 2 |  2 | two
 3 | -3 | three
 2 |  4 | two
 5 | -5 | five
(5 rows)

--Testcase 155:
EXPLAIN VERBOSE SELECT i, k FROM (SELECT i, t FROM J1_TBL) AS t1 RIGHT JOIN (SELECT i, k FROM J2_TBL) t2 USING (i) WHERE i IS NOT NULL LIMIT 5;
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..100.11 rows=0 width=8)
   Output: j2_tbl.i, j2_tbl.k
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Relations: (public.j2_tbl) LEFT JOIN (public.j1_tbl)
     Remote SQL: SELECT r5.i, r5.k FROM (public.j2_tbl r5 LEFT JOIN public.j1_tbl r4 ON (((r4.i = r5.i)))) WHERE ((r5.i IS NOT NULL)) LIMIT 5::bigint
(6 rows)

--Testcase 156:
SELECT i, k FROM (SELECT i, t FROM J1_TBL) AS t1 RIGHT JOIN (SELECT i, k FROM J2_TBL) t2 USING (i) WHERE i IS NOT NULL LIMIT 5;
 i | k  
---+----
 1 | -1
 2 |  2
 3 | -3
 2 |  4
 5 | -5
(5 rows)

--Testcase 157:
EXPLAIN VERBOSE SELECT t1.i, t2.i, t3.i, t4.i FROM J1_TBL AS t1 LEFT JOIN J2_TBL AS t2 ON t1.i = t2.i RIGHT JOIN J3_TBL AS t3 INNER JOIN J1_TBL AS t4 ON t4.i = t3.i ON t1.i = t3.i WHERE t1.i IS NOT NULL LIMIT 5;
                                                                                                                              QUERY PLAN                                                                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..100.11 rows=0 width=16)
   Output: t1.i, t2.i, t3.i, t4.i
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Relations: (((public.j1_tbl t1) LEFT JOIN (public.j2_tbl t2)) INNER JOIN (public.j3_tbl t3)) INNER JOIN (public.j1_tbl t4)
     Remote SQL: SELECT r1.i, r2.i, r4.i, r5.i FROM (((public.j1_tbl r1 LEFT JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) INNER JOIN public.j3_tbl r4 ON (((r1.i = r4.i)) AND ((r1.i IS NOT NULL)))) INNER JOIN public.j1_tbl r5 ON (((r1.i = r5.i)))) LIMIT 5::bigint
(6 rows)

--Testcase 158:
SELECT t1.i, t2.i, t3.i, t4.i FROM J1_TBL AS t1 LEFT JOIN J2_TBL AS t2 ON t1.i = t2.i RIGHT JOIN J3_TBL AS t3 INNER JOIN J1_TBL AS t4 ON t4.i = t3.i ON t1.i = t3.i WHERE t1.i IS NOT NULL LIMIT 5;
 i | i | i | i 
---+---+---+---
 1 | 1 | 1 | 1
 2 | 2 | 2 | 2
 2 | 2 | 2 | 2
 2 | 2 | 2 | 2
 2 | 2 | 2 | 2
(5 rows)

--Join  with WHERE + ORDER BY +  OFFSET
--Testcase 159:
EXPLAIN VERBOSE SELECT tx.ii, tx.jj, tx.kk FROM (J1_TBL t1 (a, b, c, f) CROSS JOIN J2_TBL t2 (d, e, f)) AS tx (ii, jj, tt, ff, ii2, kk, ff2) WHERE tx.ii IS NOT NULL ORDER BY tx.ii, tx.jj, tx.kk OFFSET 1;
                                                                                                  QUERY PLAN                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..232016.85 rows=0 width=12)
   Output: t1.a, t1.b, t2.e
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Sort push-down: yes
     Relations: (public.j1_tbl t1) INNER JOIN (public.j2_tbl t2)
     Remote SQL: SELECT r1.i, r1.j, r2.k FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (((r1.i IS NOT NULL)))) ORDER BY r1.i ASC NULLS LAST, r1.j ASC NULLS LAST, r2.k ASC NULLS LAST OFFSET 1::bigint
(7 rows)

--Testcase 160:
SELECT tx.ii, tx.jj, tx.kk FROM (J1_TBL t1 (a, b, c, f) CROSS JOIN J2_TBL t2 (d, e, f)) AS tx (ii, jj, tt, ff, ii2, kk, ff2) WHERE tx.ii IS NOT NULL ORDER BY tx.ii, tx.jj, tx.kk OFFSET 1;
 ii | jj | kk 
----+----+----
  0 |    | -5
  0 |    | -3
  0 |    | -1
  0 |    |  0
  0 |    |  2
  0 |    |  4
  0 |    |   
  1 |  4 | -5
  1 |  4 | -5
  1 |  4 | -3
  1 |  4 | -1
  1 |  4 |  0
  1 |  4 |  2
  1 |  4 |  4
  1 |  4 |   
  2 |  3 | -5
  2 |  3 | -5
  2 |  3 | -3
  2 |  3 | -1
  2 |  3 |  0
  2 |  3 |  2
  2 |  3 |  4
  2 |  3 |   
  3 |  2 | -5
  3 |  2 | -5
  3 |  2 | -3
  3 |  2 | -1
  3 |  2 |  0
  3 |  2 |  2
  3 |  2 |  4
  3 |  2 |   
  4 |  1 | -5
  4 |  1 | -5
  4 |  1 | -3
  4 |  1 | -1
  4 |  1 |  0
  4 |  1 |  2
  4 |  1 |  4
  4 |  1 |   
  5 |  0 | -5
  5 |  0 | -5
  5 |  0 | -3
  5 |  0 | -1
  5 |  0 |  0
  5 |  0 |  2
  5 |  0 |  4
  5 |  0 |   
  6 |  6 | -5
  6 |  6 | -5
  6 |  6 | -3
  6 |  6 | -1
  6 |  6 |  0
  6 |  6 |  2
  6 |  6 |  4
  6 |  6 |   
  7 |  7 | -5
  7 |  7 | -5
  7 |  7 | -3
  7 |  7 | -1
  7 |  7 |  0
  7 |  7 |  2
  7 |  7 |  4
  7 |  7 |   
  8 |  8 | -5
  8 |  8 | -5
  8 |  8 | -3
  8 |  8 | -1
  8 |  8 |  0
  8 |  8 |  2
  8 |  8 |  4
  8 |  8 |   
(71 rows)

--Testcase 161:
EXPLAIN VERBOSE SELECT i, j, t FROM J1_TBL RIGHT JOIN J2_TBL USING (i) WHERE t IS NOT NULL ORDER BY i, j, t OFFSET 2;
                                                                                                            QUERY PLAN                                                                                                             
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.01..266788.48 rows=0 width=40)
   Output: j2_tbl.i, j1_tbl.j, j1_tbl.t
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Sort push-down: yes
     Relations: (public.j1_tbl) INNER JOIN (public.j2_tbl)
     Remote SQL: SELECT r2.i, r1.j, r1.t FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (((r1.i = r2.i)) AND ((r1.t IS NOT NULL)))) ORDER BY r2.i ASC NULLS LAST, r1.j ASC NULLS LAST, r1.t ASC NULLS LAST OFFSET 2::bigint
(7 rows)

--Testcase 162:
SELECT i, j, t FROM J1_TBL RIGHT JOIN J2_TBL USING (i) WHERE t IS NOT NULL ORDER BY i, j, t OFFSET 2;
 i | j |   t   
---+---+-------
 2 | 3 | two
 2 | 3 | two
 3 | 2 | three
 5 | 0 | five
 5 | 0 | five
(5 rows)

--Testcase 163:
EXPLAIN VERBOSE SELECT i, k, t FROM J1_TBL FULL JOIN J2_TBL USING (i) WHERE i >= 0 ORDER BY i, k, t OFFSET 1;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.01..0.02 rows=1 width=40)
   Output: (COALESCE(j1_tbl.i, j2_tbl.i)), j2_tbl.k, j1_tbl.t
   ->  Sort  (cost=0.01..0.02 rows=0 width=40)
         Output: (COALESCE(j1_tbl.i, j2_tbl.i)), j2_tbl.k, j1_tbl.t
         Sort Key: (COALESCE(j1_tbl.i, j2_tbl.i)), j2_tbl.k, j1_tbl.t
         ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=40)
               Output: COALESCE(j1_tbl.i, j2_tbl.i), j2_tbl.k, j1_tbl.t
               Filter: (COALESCE(j1_tbl.i, j2_tbl.i) >= 0)
               Node: postgres_svr / Status: Alive
                 Limit push-down: no
                 Sort push-down: no
                 Relations: (public.j1_tbl) FULL JOIN (public.j2_tbl)
                 Remote SQL: SELECT r1.i, r2.i, r2.k, r1.t FROM (public.j1_tbl r1 FULL JOIN public.j2_tbl r2 ON (((r1.i = r2.i))))
(13 rows)

--Testcase 164:
SELECT i, k, t FROM J1_TBL FULL JOIN J2_TBL USING (i) WHERE i >= 0 ORDER BY i, k, t OFFSET 1;
 i | k  |   t   
---+----+-------
 1 | -1 | one
 2 |  2 | two
 2 |  4 | two
 3 | -3 | three
 4 |    | four
 5 | -5 | five
 5 | -5 | five
 6 |    | six
 7 |    | seven
 8 |    | eight
(10 rows)

--Testcase 165:
EXPLAIN VERBOSE SELECT i, t FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (i >= 1) ORDER BY i, t OFFSET 1;
                                                                                            QUERY PLAN                                                                                            
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..89606.25 rows=0 width=36)
   Output: j1_tbl.i, j1_tbl.t
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Sort push-down: yes
     Relations: (public.j1_tbl) LEFT JOIN (public.j2_tbl)
     Remote SQL: SELECT r1.i, r1.t FROM (public.j1_tbl r1 LEFT JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) WHERE ((r1.i >= 1)) ORDER BY r1.i ASC NULLS LAST, r1.t ASC NULLS LAST OFFSET 1::bigint
(7 rows)

--Testcase 166:
SELECT i, t FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (i >= 1) ORDER BY i, t OFFSET 1;
 i |   t   
---+-------
 2 | two
 2 | two
 3 | three
 4 | four
 5 | five
 5 | five
 6 | six
 7 | seven
 8 | eight
(9 rows)

--Testcase 167:
EXPLAIN VERBOSE SELECT t1.i FROM J1_TBL AS t1 INNER JOIN J2_TBL AS t2 ON t1.i = t2.i WHERE t1.i > 0 ORDER BY t1.i OFFSET 1;
                                                                             QUERY PLAN                                                                              
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.01..101199.98 rows=0 width=4)
   Output: t1.i
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Sort push-down: yes
     Relations: (public.j1_tbl t1) INNER JOIN (public.j2_tbl t2)
     Remote SQL: SELECT r1.i FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (((r1.i = r2.i)) AND ((r1.i > 0)))) ORDER BY r1.i ASC NULLS LAST OFFSET 1::bigint
(7 rows)

--Testcase 168:
SELECT t1.i FROM J1_TBL AS t1 INNER JOIN J2_TBL AS t2 ON t1.i = t2.i WHERE t1.i > 0 ORDER BY t1.i OFFSET 1;
 i 
---
 2
 2
 3
 5
 5
(5 rows)

--Join  with LIMIT
--Testcase 169:
EXPLAIN VERBOSE SELECT J1_TBL.i, J1_TBL.j, J1_TBL.t FROM J1_TBL CROSS JOIN J2_TBL LIMIT 5;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..100.10 rows=0 width=40)
   Output: j1_tbl.i, j1_tbl.j, j1_tbl.t
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Relations: (public.j1_tbl) INNER JOIN (public.j2_tbl)
     Remote SQL: SELECT r1.i, r1.j, r1.t FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (TRUE)) LIMIT 5::bigint
(6 rows)

--Testcase 170:
SELECT J1_TBL.i, J1_TBL.j, J1_TBL.t FROM J1_TBL CROSS JOIN J2_TBL LIMIT 5;
 i | j |   t   
---+---+-------
 1 | 4 | one
 2 | 3 | two
 3 | 2 | three
 4 | 1 | four
 5 | 0 | five
(5 rows)

--Testcase 171:
EXPLAIN VERBOSE SELECT J1_TBL.i, J1_TBL.j, J1_TBL.t FROM J1_TBL INNER JOIN J2_TBL USING (i) AS x LIMIT 10;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..100.21 rows=0 width=40)
   Output: j1_tbl.i, j1_tbl.j, j1_tbl.t
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Relations: (public.j1_tbl) INNER JOIN (public.j2_tbl)
     Remote SQL: SELECT r1.i, r1.j, r1.t FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) LIMIT 10::bigint
(6 rows)

--Testcase 172:
SELECT J1_TBL.i, J1_TBL.j, J1_TBL.t FROM J1_TBL INNER JOIN J2_TBL USING (i) AS x LIMIT 10;
 i | j |   t   
---+---+-------
 1 | 4 | one
 2 | 3 | two
 3 | 2 | three
 2 | 3 | two
 5 | 0 | five
 5 | 0 | five
 0 |   | zero
(7 rows)

--Testcase 173:
EXPLAIN VERBOSE SELECT t1.a, t1.b, t1.c, t2.a, t2.b FROM J1_TBL t1 (a, b, c, d) FULL JOIN J2_TBL t2 (a, b, d) USING (b) LIMIT 5;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..100.11 rows=0 width=48)
   Output: t1.a, t1.b, t1.c, t2.a, t2.b
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Relations: (public.j1_tbl t1) FULL JOIN (public.j2_tbl t2)
     Remote SQL: SELECT r1.i, r1.j, r1.t, r2.i, r2.k FROM (public.j1_tbl r1 FULL JOIN public.j2_tbl r2 ON (((r1.j = r2.k)))) LIMIT 5::bigint
(6 rows)

--Testcase 174:
SELECT t1.a, t1.b, t1.c, t2.a, t2.b FROM J1_TBL t1 (a, b, c, d) FULL JOIN J2_TBL t2 (a, b, d) USING (b) LIMIT 5;
 a | b |   c   | a | b  
---+---+-------+---+----
   |   |       | 1 | -1
 3 | 2 | three | 2 |  2
   |   |       | 3 | -3
 1 | 4 | one   | 2 |  4
   |   |       | 5 | -5
(5 rows)

--Testcase 175:
EXPLAIN VERBOSE SELECT J1_TBL.i, J1_TBL.j, J1_TBL.t FROM J1_TBL LEFT JOIN J2_TBL USING (i) LIMIT 5;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..100.11 rows=0 width=40)
   Output: j1_tbl.i, j1_tbl.j, j1_tbl.t
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Relations: (public.j1_tbl) LEFT JOIN (public.j2_tbl)
     Remote SQL: SELECT r1.i, r1.j, r1.t FROM (public.j1_tbl r1 LEFT JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) LIMIT 5::bigint
(6 rows)

--Testcase 176:
SELECT J1_TBL.i, J1_TBL.j, J1_TBL.t FROM J1_TBL LEFT JOIN J2_TBL USING (i) LIMIT 5;
 i | j |   t   
---+---+-------
 1 | 4 | one
 2 | 3 | two
 2 | 3 | two
 3 | 2 | three
 4 | 1 | four
(5 rows)

--Testcase 177:
EXPLAIN VERBOSE SELECT J2_TBL.i, J2_TBL.k FROM J1_TBL RIGHT JOIN J2_TBL USING (i) LIMIT 5;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..100.11 rows=0 width=8)
   Output: j2_tbl.i, j2_tbl.k
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Relations: (public.j2_tbl) LEFT JOIN (public.j1_tbl)
     Remote SQL: SELECT r2.i, r2.k FROM (public.j2_tbl r2 LEFT JOIN public.j1_tbl r1 ON (((r1.i = r2.i)))) LIMIT 5::bigint
(6 rows)

--Testcase 178:
SELECT J2_TBL.i, J2_TBL.k FROM J1_TBL RIGHT JOIN J2_TBL USING (i) LIMIT 5;
 i | k  
---+----
 1 | -1
 2 |  2
 3 | -3
 2 |  4
 5 | -5
(5 rows)

--Join  with OFFSET
--Testcase 179:
EXPLAIN VERBOSE SELECT i, k, t FROM J1_TBL LEFT JOIN J2_TBL USING (i) OFFSET 2;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.01..262281.02 rows=0 width=40)
   Output: j1_tbl.i, j2_tbl.k, j1_tbl.t
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Relations: (public.j1_tbl) LEFT JOIN (public.j2_tbl)
     Remote SQL: SELECT r1.i, r2.k, r1.t FROM (public.j1_tbl r1 LEFT JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) OFFSET 2::bigint
(6 rows)

--Testcase 180:
SELECT i, k, t FROM J1_TBL LEFT JOIN J2_TBL USING (i) OFFSET 2;
 i | k  |   t   
---+----+-------
 3 | -3 | three
 2 |  4 | two
 5 | -5 | five
 5 | -5 | five
 0 |    | zero
   |    | zero
   |    | null
 8 |    | eight
 6 |    | six
 7 |    | seven
 4 |    | four
(11 rows)

--Testcase 181:
EXPLAIN VERBOSE SELECT i, k, t FROM J1_TBL INNER JOIN J2_TBL USING (i) OFFSET 1;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..262281.04 rows=0 width=40)
   Output: j1_tbl.i, j2_tbl.k, j1_tbl.t
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Relations: (public.j1_tbl) INNER JOIN (public.j2_tbl)
     Remote SQL: SELECT r1.i, r2.k, r1.t FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) OFFSET 1::bigint
(6 rows)

--Testcase 182:
SELECT i, k, t FROM J1_TBL INNER JOIN J2_TBL USING (i) OFFSET 1;
 i | k  |   t   
---+----+-------
 2 |  2 | two
 3 | -3 | three
 2 |  4 | two
 5 | -5 | five
 5 | -5 | five
 0 |    | zero
(6 rows)

--Testcase 183:
EXPLAIN VERBOSE SELECT J1_TBL.i, J2_TBL.k, J1_TBL.t FROM J1_TBL RIGHT JOIN J2_TBL USING (i) OFFSET 1;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..262281.04 rows=0 width=40)
   Output: j1_tbl.i, j2_tbl.k, j1_tbl.t
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Relations: (public.j2_tbl) LEFT JOIN (public.j1_tbl)
     Remote SQL: SELECT r1.i, r2.k, r1.t FROM (public.j2_tbl r2 LEFT JOIN public.j1_tbl r1 ON (((r1.i = r2.i)))) OFFSET 1::bigint
(6 rows)

--Testcase 184:
SELECT J1_TBL.i, J2_TBL.k, J1_TBL.t FROM J1_TBL RIGHT JOIN J2_TBL USING (i) OFFSET 1;
 i | k  |   t   
---+----+-------
 2 |  2 | two
 3 | -3 | three
 2 |  4 | two
 5 | -5 | five
 5 | -5 | five
 0 |    | zero
   |  0 | 
(7 rows)

--Testcase 185:
EXPLAIN VERBOSE SELECT J1_TBL.i, k, t FROM J1_TBL CROSS JOIN J2_TBL OFFSET 1;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..233159.62 rows=0 width=40)
   Output: j1_tbl.i, j2_tbl.k, j1_tbl.t
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Relations: (public.j1_tbl) INNER JOIN (public.j2_tbl)
     Remote SQL: SELECT r1.i, r2.k, r1.t FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (TRUE)) OFFSET 1::bigint
(6 rows)

--Testcase 186:
SELECT J1_TBL.i, k, t FROM J1_TBL CROSS JOIN J2_TBL OFFSET 1;
 i | k  |   t   
---+----+-------
 2 | -1 | two
 3 | -1 | three
 4 | -1 | four
 5 | -1 | five
 6 | -1 | six
 7 | -1 | seven
 8 | -1 | eight
 0 | -1 | zero
   | -1 | null
   | -1 | zero
 1 |  2 | one
 2 |  2 | two
 3 |  2 | three
 4 |  2 | four
 5 |  2 | five
 6 |  2 | six
 7 |  2 | seven
 8 |  2 | eight
 0 |  2 | zero
   |  2 | null
   |  2 | zero
 1 | -3 | one
 2 | -3 | two
 3 | -3 | three
 4 | -3 | four
 5 | -3 | five
 6 | -3 | six
 7 | -3 | seven
 8 | -3 | eight
 0 | -3 | zero
   | -3 | null
   | -3 | zero
 1 |  4 | one
 2 |  4 | two
 3 |  4 | three
 4 |  4 | four
 5 |  4 | five
 6 |  4 | six
 7 |  4 | seven
 8 |  4 | eight
 0 |  4 | zero
   |  4 | null
   |  4 | zero
 1 | -5 | one
 2 | -5 | two
 3 | -5 | three
 4 | -5 | four
 5 | -5 | five
 6 | -5 | six
 7 | -5 | seven
 8 | -5 | eight
 0 | -5 | zero
   | -5 | null
   | -5 | zero
 1 | -5 | one
 2 | -5 | two
 3 | -5 | three
 4 | -5 | four
 5 | -5 | five
 6 | -5 | six
 7 | -5 | seven
 8 | -5 | eight
 0 | -5 | zero
   | -5 | null
   | -5 | zero
 1 |    | one
 2 |    | two
 3 |    | three
 4 |    | four
 5 |    | five
 6 |    | six
 7 |    | seven
 8 |    | eight
 0 |    | zero
   |    | null
   |    | zero
 1 |  0 | one
 2 |  0 | two
 3 |  0 | three
 4 |  0 | four
 5 |  0 | five
 6 |  0 | six
 7 |  0 | seven
 8 |  0 | eight
 0 |  0 | zero
   |  0 | null
   |  0 | zero
(87 rows)

--Testcase 187:
EXPLAIN VERBOSE SELECT i, k, t FROM J1_TBL FULL JOIN J2_TBL USING (i) OFFSET 3;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.01..262281.00 rows=0 width=40)
   Output: COALESCE(j1_tbl.i, j2_tbl.i), j2_tbl.k, j1_tbl.t
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Relations: (public.j1_tbl) FULL JOIN (public.j2_tbl)
     Remote SQL: SELECT r1.i, r2.i, r2.k, r1.t FROM (public.j1_tbl r1 FULL JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) OFFSET 3::bigint
(6 rows)

--Testcase 188:
SELECT i, k, t FROM J1_TBL FULL JOIN J2_TBL USING (i) OFFSET 3;
 i | k  |   t   
---+----+-------
 2 |  4 | two
 5 | -5 | five
 5 | -5 | five
 0 |    | zero
   |  0 | 
   |    | zero
   |    | null
 8 |    | eight
 6 |    | six
 7 |    | seven
 4 |    | four
(11 rows)

--Join  with LIMIT, OFFSET
--Testcase 189:
EXPLAIN VERBOSE SELECT x, t2.i FROM (SELECT j/2 AS x FROM J1_TBL) ss1 INNER JOIN J2_TBL t2 ON x = i LIMIT 5 OFFSET 0;
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..100.12 rows=0 width=8)
   Output: (j1_tbl.j / 2), t2.i
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Relations: (public.j1_tbl) INNER JOIN (public.j2_tbl t2)
     Remote SQL: SELECT r4.j, r2.i FROM (public.j1_tbl r4 INNER JOIN public.j2_tbl r2 ON ((((r4.j / 2) = r2.i)))) LIMIT 5::bigint OFFSET 0::bigint
(6 rows)

--Testcase 190:
SELECT x, t2.i FROM (SELECT j/2 AS x FROM J1_TBL) ss1 INNER JOIN J2_TBL t2 ON x = i LIMIT 5 OFFSET 0;
 x | i 
---+---
 1 | 1
 1 | 1
 2 | 2
 3 | 3
 3 | 3
(5 rows)

--Testcase 191:
EXPLAIN VERBOSE SELECT x.i, x.j, x.t, y.i, y.k FROM J1_TBL x LEFT JOIN (SELECT i, k FROM J2_TBL) y ON x.i = y.i LIMIT 3 OFFSET 5;
                                                                          QUERY PLAN                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.01..100.08 rows=0 width=48)
   Output: x.i, x.j, x.t, j2_tbl.i, j2_tbl.k
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Relations: (public.j1_tbl x) LEFT JOIN (public.j2_tbl)
     Remote SQL: SELECT r1.i, r1.j, r1.t, r4.i, r4.k FROM (public.j1_tbl r1 LEFT JOIN public.j2_tbl r4 ON (((r1.i = r4.i)))) LIMIT 3::bigint OFFSET 5::bigint
(6 rows)

--Testcase 192:
SELECT x.i, x.j, x.t, y.i, y.k FROM J1_TBL x LEFT JOIN (SELECT i, k FROM J2_TBL) y ON x.i = y.i LIMIT 3 OFFSET 5;
 i | j |  t   | i | k  
---+---+------+---+----
 5 | 0 | five | 5 | -5
 5 | 0 | five | 5 | -5
 6 | 6 | six  |   |   
(3 rows)

--Testcase 193:
EXPLAIN VERBOSE SELECT f1.i, f1.j, f2.i, f2.k FROM J1_TBL f1 RIGHT JOIN J2_TBL f2 ON (f1.i = f2.i AND f1.j >= f2.k) LIMIT 5 OFFSET 1;
                                                                                 QUERY PLAN                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.01..100.12 rows=0 width=16)
   Output: f1.i, f1.j, f2.i, f2.k
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Relations: (public.j2_tbl f2) LEFT JOIN (public.j1_tbl f1)
     Remote SQL: SELECT r1.i, r1.j, r2.i, r2.k FROM (public.j2_tbl r2 LEFT JOIN public.j1_tbl r1 ON (((r1.j >= r2.k)) AND ((r1.i = r2.i)))) LIMIT 5::bigint OFFSET 1::bigint
(6 rows)

--Testcase 194:
SELECT f1.i, f1.j, f2.i, f2.k FROM J1_TBL f1 RIGHT JOIN J2_TBL f2 ON (f1.i = f2.i AND f1.j >= f2.k) LIMIT 5 OFFSET 1;
 i | j | i | k  
---+---+---+----
 2 | 3 | 2 |  2
 3 | 2 | 3 | -3
   |   | 2 |  4
 5 | 0 | 5 | -5
 5 | 0 | 5 | -5
(5 rows)

--Testcase 195:
EXPLAIN VERBOSE SELECT j1.i, j2.i, j1.t, j2.k FROM J1_TBL j1 CROSS JOIN J2_TBL j2 LIMIT 3 OFFSET 0;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..100.06 rows=0 width=44)
   Output: j1.i, j2.i, j1.t, j2.k
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Relations: (public.j1_tbl j1) INNER JOIN (public.j2_tbl j2)
     Remote SQL: SELECT r1.i, r2.i, r1.t, r2.k FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (TRUE)) LIMIT 3::bigint OFFSET 0::bigint
(6 rows)

--Testcase 196:
SELECT j1.i, j2.i, j1.t, j2.k FROM J1_TBL j1 CROSS JOIN J2_TBL j2 LIMIT 3 OFFSET 0;
 i | i |   t   | k  
---+---+-------+----
 1 | 1 | one   | -1
 2 | 1 | two   | -1
 3 | 1 | three | -1
(3 rows)

--Testcase 197:
EXPLAIN VERBOSE SELECT j1.i, j2.i, j1.i + j2.i, j1.j * j2.k, j1.t FROM J1_TBL j1 FULL JOIN J2_TBL j2 ON j1.i = j2.i LIMIT 5 OFFSET 0;
                                                                          QUERY PLAN                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..100.11 rows=0 width=48)
   Output: j1.i, j2.i, (j1.i + j2.i), (j1.j * j2.k), j1.t
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Relations: (public.j1_tbl j1) FULL JOIN (public.j2_tbl j2)
     Remote SQL: SELECT r1.i, r2.i, r1.j, r2.k, r1.t FROM (public.j1_tbl r1 FULL JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) LIMIT 5::bigint OFFSET 0::bigint
(6 rows)

--Testcase 198:
SELECT j1.i, j2.i, j1.i + j2.i, j1.j * j2.k, j1.t FROM J1_TBL j1 FULL JOIN J2_TBL j2 ON j1.i = j2.i LIMIT 5 OFFSET 0;
 i | i | ?column? | ?column? |   t   
---+---+----------+----------+-------
 1 | 1 |        2 |       -4 | one
 2 | 2 |        4 |        6 | two
 3 | 3 |        6 |       -6 | three
 2 | 2 |        4 |       12 | two
 5 | 5 |       10 |        0 | five
(5 rows)

--Join  with LIMIT, OFFSET and ORDER BY
--Testcase 199:
EXPLAIN VERBOSE SELECT t1.i, t1.j, t1.t FROM J1_TBL t1 LEFT JOIN (SELECT i, k , '***'::text AS d1 FROM J2_TBL t2) b1 ON t1.i = b1.i ORDER BY t1.i, b1.i LIMIT 5 OFFSET 0;
                                                                                                QUERY PLAN                                                                                                
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..100.11 rows=0 width=44)
   Output: t1.i, t1.j, t1.t, t2.i
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Sort push-down: yes
     Relations: (public.j1_tbl t1) LEFT JOIN (public.j2_tbl t2)
     Remote SQL: SELECT r1.i, r1.j, r1.t, r4.i FROM (public.j1_tbl r1 LEFT JOIN public.j2_tbl r4 ON (((r1.i = r4.i)))) ORDER BY r1.i ASC NULLS LAST, r4.i ASC NULLS LAST LIMIT 5::bigint OFFSET 0::bigint
(7 rows)

--Testcase 200:
SELECT t1.i, t1.j, t1.t FROM J1_TBL t1 LEFT JOIN (SELECT i, k , '***'::text AS d1 FROM J2_TBL t2) b1 ON t1.i = b1.i ORDER BY t1.i, b1.i LIMIT 5 OFFSET 0;
 i | j |   t   
---+---+-------
 0 |   | zero
 1 | 4 | one
 2 | 3 | two
 2 | 3 | two
 3 | 2 | three
(5 rows)

--Testcase 201:
EXPLAIN VERBOSE SELECT t1.i, t1.j, b1.i FROM J1_TBL t1 RIGHT JOIN (SELECT i, null::int AS d2 FROM J2_TBL t2) b1 ON t1.i = b1.i ORDER BY t1.i, b1.i LIMIT 5 OFFSET 1;
                                                                                             QUERY PLAN                                                                                             
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..100.11 rows=0 width=12)
   Output: t1.i, t1.j, t2.i
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Sort push-down: yes
     Relations: (public.j2_tbl t2) LEFT JOIN (public.j1_tbl t1)
     Remote SQL: SELECT r1.i, r1.j, r4.i FROM (public.j2_tbl r4 LEFT JOIN public.j1_tbl r1 ON (((r1.i = r4.i)))) ORDER BY r1.i ASC NULLS LAST, r4.i ASC NULLS LAST LIMIT 5::bigint OFFSET 1::bigint
(7 rows)

--Testcase 202:
SELECT t1.i, t1.j, b1.i FROM J1_TBL t1 RIGHT JOIN (SELECT i, null::int AS d2 FROM J2_TBL t2) b1 ON t1.i = b1.i ORDER BY t1.i, b1.i LIMIT 5 OFFSET 1;
 i | j | i 
---+---+---
 1 | 4 | 1
 2 | 3 | 2
 2 | 3 | 2
 3 | 2 | 3
 5 | 0 | 5
(5 rows)

--Testcase 203:
EXPLAIN VERBOSE SELECT t1.i, t1.j, t2.i, t2.k FROM J1_TBL t1 INNER JOIN J2_TBL t2 ON t2.k = 2 ORDER BY t1.i LIMIT 3 OFFSET 0;
                                                                                    QUERY PLAN                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..100.07 rows=0 width=16)
   Output: t1.i, t1.j, t2.i, t2.k
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Sort push-down: yes
     Relations: (public.j1_tbl t1) INNER JOIN (public.j2_tbl t2)
     Remote SQL: SELECT r1.i, r1.j, r2.i, r2.k FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (((r2.k = 2)))) ORDER BY r1.i ASC NULLS LAST LIMIT 3::bigint OFFSET 0::bigint
(7 rows)

--Testcase 204:
SELECT t1.i, t1.j, t2.i, t2.k FROM J1_TBL t1 INNER JOIN J2_TBL t2 ON t2.k = 2 ORDER BY t1.i LIMIT 3 OFFSET 0;
 i | j | i | k 
---+---+---+---
 0 |   | 2 | 2
 1 | 4 | 2 | 2
 2 | 3 | 2 | 2
(3 rows)

--Testcase 205:
EXPLAIN VERBOSE SELECT t1.i, t1.j, t2.i, t2.k FROM J1_TBL t1 FULL JOIN J2_TBL t2 ON t1.i = t2.i ORDER BY t1.i LIMIT 3 OFFSET 0;
                                                                                     QUERY PLAN                                                                                      
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..100.07 rows=0 width=16)
   Output: t1.i, t1.j, t2.i, t2.k
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Sort push-down: yes
     Relations: (public.j1_tbl t1) FULL JOIN (public.j2_tbl t2)
     Remote SQL: SELECT r1.i, r1.j, r2.i, r2.k FROM (public.j1_tbl r1 FULL JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) ORDER BY r1.i ASC NULLS LAST LIMIT 3::bigint OFFSET 0::bigint
(7 rows)

--Testcase 206:
SELECT t1.i, t1.j, t2.i, t2.k FROM J1_TBL t1 FULL JOIN J2_TBL t2 ON t1.i = t2.i ORDER BY t1.i LIMIT 3 OFFSET 0;
 i | j | i | k  
---+---+---+----
 0 |   | 0 |   
 1 | 4 | 1 | -1
 2 | 3 | 2 |  2
(3 rows)

--Testcase 207:
EXPLAIN VERBOSE SELECT t1.i/2, t1.j - 1, t1.t || '***' FROM J1_TBL t1 CROSS JOIN J2_TBL t2(x, y, z) ORDER BY t1.i LIMIT 5 OFFSET 2;
                                                                             QUERY PLAN                                                                              
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..100.13 rows=0 width=44)
   Output: (t1.i / 2), (t1.j - 1), (t1.t || '***'::text), t1.i
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Sort push-down: yes
     Relations: (public.j1_tbl t1) INNER JOIN (public.j2_tbl t2)
     Remote SQL: SELECT r1.i, r1.j, r1.t FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (TRUE)) ORDER BY r1.i ASC NULLS LAST LIMIT 5::bigint OFFSET 2::bigint
(7 rows)

--Testcase 208:
SELECT t1.i/2, t1.j - 1, t1.t || '***' FROM J1_TBL t1 CROSS JOIN J2_TBL t2(x, y, z) ORDER BY t1.i LIMIT 5 OFFSET 2;
 ?column? | ?column? | ?column? 
----------+----------+----------
        0 |          | zero***
        0 |          | zero***
        0 |          | zero***
        0 |          | zero***
        0 |          | zero***
(5 rows)

--Testcase 209:
EXPLAIN VERBOSE SELECT x1.a, x1.b, x1.c, x1.e, xx1 FROM (J1_TBL t1 LEFT JOIN J2_TBL t2 ON (t1.i = t2.i)) x1(a, b, c, d, e, f, g) FULL JOIN J2_TBL x2(xx1, xx2, xx3) ON (x1.a = xx1) ORDER BY x1.a, x1.b LIMIT 10 OFFSET 0;
                                                                                                                            QUERY PLAN                                                                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=100.00..100.22 rows=0 width=48)
   Output: t1.i, t1.j, t1.t, t2.i, x2.xx1
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Sort push-down: yes
     Relations: ((public.j1_tbl t1) LEFT JOIN (public.j2_tbl t2)) FULL JOIN (public.j2_tbl x2)
     Remote SQL: SELECT r1.i, r1.j, r1.t, r2.i, r4.i FROM ((public.j1_tbl r1 LEFT JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) FULL JOIN public.j2_tbl r4 ON (((r1.i = r4.i)))) ORDER BY r1.i ASC NULLS LAST, r1.j ASC NULLS LAST LIMIT 10::bigint OFFSET 0::bigint
(7 rows)

--Testcase 210:
SELECT x1.a, x1.b, x1.c, x1.e, xx1 FROM (J1_TBL t1 LEFT JOIN J2_TBL t2 ON (t1.i = t2.i)) x1(a, b, c, d, e, f, g) FULL JOIN J2_TBL x2(xx1, xx2, xx3) ON (x1.a = xx1) ORDER BY x1.a, x1.b LIMIT 10 OFFSET 0;
 a | b |   c   | e | xx1 
---+---+-------+---+-----
 0 |   | zero  | 0 |   0
 1 | 4 | one   | 1 |   1
 2 | 3 | two   | 2 |   2
 2 | 3 | two   | 2 |   2
 2 | 3 | two   | 2 |   2
 2 | 3 | two   | 2 |   2
 3 | 2 | three | 3 |   3
 4 | 1 | four  |   |    
 5 | 0 | five  | 5 |   5
 5 | 0 | five  | 5 |   5
(10 rows)

--Join  with GROUP BY, OFFSET and ORDER BY
--Testcase 211:
EXPLAIN VERBOSE SELECT t1.i, t1.j, b1.k FROM J1_TBL t1 LEFT JOIN (SELECT i, k , '***'::text AS d1 FROM J2_TBL t2) b1 ON t1.i = b1.i GROUP BY t1.i, t1.j, b1.k, b1.i ORDER BY t1.i, b1.i OFFSET 1;
                                                                                                  QUERY PLAN                                                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=122410.25..156626.69 rows=0 width=16)
   Output: t1.i, t1.j, t2.k, t2.i
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Sort push-down: yes
     Agg push-down: yes
     Relations: Aggregate on ((public.j1_tbl t1) LEFT JOIN (public.j2_tbl t2))
     Remote SQL: SELECT r1.i, r1.j, r4.k, r4.i FROM (public.j1_tbl r1 LEFT JOIN public.j2_tbl r4 ON (((r1.i = r4.i)))) GROUP BY 1, 4, 2, 3 ORDER BY r1.i ASC NULLS LAST, r4.i ASC NULLS LAST OFFSET 1::bigint
(8 rows)

--Testcase 212:
SELECT t1.i, t1.j, b1.k FROM J1_TBL t1 LEFT JOIN (SELECT i, k , '***'::text AS d1 FROM J2_TBL t2) b1 ON t1.i = b1.i GROUP BY t1.i, t1.j, b1.k, b1.i ORDER BY t1.i, b1.i OFFSET 1;
 i | j | k  
---+---+----
 1 | 4 | -1
 2 | 3 |  2
 2 | 3 |  4
 3 | 2 | -3
 4 | 1 |   
 5 | 0 | -5
 6 | 6 |   
 7 | 7 |   
 8 | 8 |   
   | 0 |   
   |   |   
(11 rows)

--Testcase 213:
EXPLAIN VERBOSE SELECT t1.i, t1.j, t1.t FROM J1_TBL t1 RIGHT JOIN (SELECT i, null::int AS d2 FROM J2_TBL t2) b1 ON t1.i = b1.i GROUP BY t1.i, t1.j, t1.t, b1.i ORDER BY t1.i, b1.i OFFSET 1;
                                                                                                  QUERY PLAN                                                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=122410.43..155160.22 rows=0 width=44)
   Output: t1.i, t1.j, t1.t, t2.i
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Sort push-down: yes
     Agg push-down: yes
     Relations: Aggregate on ((public.j2_tbl t2) LEFT JOIN (public.j1_tbl t1))
     Remote SQL: SELECT r1.i, r1.j, r1.t, r4.i FROM (public.j2_tbl r4 LEFT JOIN public.j1_tbl r1 ON (((r1.i = r4.i)))) GROUP BY 1, 4, 2, 3 ORDER BY r1.i ASC NULLS LAST, r4.i ASC NULLS LAST OFFSET 1::bigint
(8 rows)

--Testcase 214:
SELECT t1.i, t1.j, t1.t FROM J1_TBL t1 RIGHT JOIN (SELECT i, null::int AS d2 FROM J2_TBL t2) b1 ON t1.i = b1.i GROUP BY t1.i, t1.j, t1.t, b1.i ORDER BY t1.i, b1.i OFFSET 1;
 i | j |   t   
---+---+-------
 1 | 4 | one
 2 | 3 | two
 3 | 2 | three
 5 | 0 | five
   |   | 
(5 rows)

--Testcase 215:
EXPLAIN VERBOSE SELECT t1.i, t1.j, t2.i, t2.k FROM J1_TBL t1 INNER JOIN J2_TBL t2 ON t2.k = 2 GROUP BY t1.i, t1.j, t2.i, t2.k ORDER BY t1.i OFFSET 1;
                                                                                      QUERY PLAN                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=709.27..1139.95 rows=0 width=16)
   Output: t1.i, t1.j, t2.i, t2.k
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Sort push-down: yes
     Agg push-down: yes
     Relations: Aggregate on ((public.j1_tbl t1) INNER JOIN (public.j2_tbl t2))
     Remote SQL: SELECT r1.i, r1.j, r2.i, r2.k FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (((r2.k = 2)))) GROUP BY 1, 2, 3, 4 ORDER BY r1.i ASC NULLS LAST OFFSET 1::bigint
(8 rows)

--Testcase 216:
SELECT t1.i, t1.j, t2.i, t2.k FROM J1_TBL t1 INNER JOIN J2_TBL t2 ON t2.k = 2 GROUP BY t1.i, t1.j, t2.i, t2.k ORDER BY t1.i OFFSET 1;
 i | j | i | k 
---+---+---+---
 1 | 4 | 2 | 2
 2 | 3 | 2 | 2
 3 | 2 | 2 | 2
 4 | 1 | 2 | 2
 5 | 0 | 2 | 2
 6 | 6 | 2 | 2
 7 | 7 | 2 | 2
 8 | 8 | 2 | 2
   |   | 2 | 2
   | 0 | 2 | 2
(10 rows)

--Testcase 217:
EXPLAIN VERBOSE SELECT t1.i, t1.j, t2.i, t2.k FROM J1_TBL t1 FULL JOIN J2_TBL t2 ON t1.i = t2.i GROUP BY t1.i, t1.j, t2.i, t2.k ORDER BY t1.i, t1.j, t2.i, t2.k OFFSET 1;
                                                                                                                       QUERY PLAN                                                                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=122410.25..156626.69 rows=0 width=16)
   Output: t1.i, t1.j, t2.i, t2.k
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Sort push-down: yes
     Agg push-down: yes
     Relations: Aggregate on ((public.j1_tbl t1) FULL JOIN (public.j2_tbl t2))
     Remote SQL: SELECT r1.i, r1.j, r2.i, r2.k FROM (public.j1_tbl r1 FULL JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) GROUP BY 1, 2, 3, 4 ORDER BY r1.i ASC NULLS LAST, r1.j ASC NULLS LAST, r2.i ASC NULLS LAST, r2.k ASC NULLS LAST OFFSET 1::bigint
(8 rows)

--Testcase 218:
SELECT t1.i, t1.j, t2.i, t2.k FROM J1_TBL t1 FULL JOIN J2_TBL t2 ON t1.i = t2.i GROUP BY t1.i, t1.j, t2.i, t2.k ORDER BY t1.i, t1.j, t2.i, t2.k OFFSET 1;
 i | j | i | k  
---+---+---+----
 1 | 4 | 1 | -1
 2 | 3 | 2 |  2
 2 | 3 | 2 |  4
 3 | 2 | 3 | -3
 4 | 1 |   |   
 5 | 0 | 5 | -5
 6 | 6 |   |   
 7 | 7 |   |   
 8 | 8 |   |   
   | 0 |   |   
   |   |   |  0
   |   |   |   
(12 rows)

--Testcase 219:
EXPLAIN VERBOSE SELECT t1.i/2, t1.j - 1, t1.t || '***' FROM J1_TBL t1 CROSS JOIN J2_TBL t2(x, y, z) GROUP BY t1.i, t1.j, t2.x, t1.t ORDER BY t1.i OFFSET 2;
                                                                                                          QUERY PLAN                                                                                                          
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=122410.01..125119.78 rows=0 width=84)
   Output: ((t1.i / 2)), ((t1.j - 1)), ((t1.t || '***'::text)), t1.i, t1.j, t2.x, t1.t
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Sort push-down: yes
     Agg push-down: yes
     Relations: Aggregate on ((public.j1_tbl t1) INNER JOIN (public.j2_tbl t2))
     Remote SQL: SELECT (r1.i / 2), (r1.j - 1), (r1.t || '***'::text), r1.i, r1.j, r2.i, r1.t FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (TRUE)) GROUP BY 4, 5, 6, 7 ORDER BY r1.i ASC NULLS LAST OFFSET 2::bigint
(8 rows)

--Testcase 220:
SELECT t1.i/2, t1.j - 1, t1.t || '***' FROM J1_TBL t1 CROSS JOIN J2_TBL t2(x, y, z) GROUP BY t1.i, t1.j, t2.x, t1.t ORDER BY t1.i OFFSET 2;
 ?column? | ?column? | ?column? 
----------+----------+----------
        0 |          | zero***
        0 |          | zero***
        0 |          | zero***
        0 |          | zero***
        0 |        3 | one***
        0 |        3 | one***
        0 |        3 | one***
        0 |        3 | one***
        0 |        3 | one***
        0 |        3 | one***
        1 |        2 | two***
        1 |        2 | two***
        1 |        2 | two***
        1 |        2 | two***
        1 |        2 | two***
        1 |        2 | two***
        1 |        1 | three***
        1 |        1 | three***
        1 |        1 | three***
        1 |        1 | three***
        1 |        1 | three***
        1 |        1 | three***
        2 |        0 | four***
        2 |        0 | four***
        2 |        0 | four***
        2 |        0 | four***
        2 |        0 | four***
        2 |        0 | four***
        2 |       -1 | five***
        2 |       -1 | five***
        2 |       -1 | five***
        2 |       -1 | five***
        2 |       -1 | five***
        2 |       -1 | five***
        3 |        5 | six***
        3 |        5 | six***
        3 |        5 | six***
        3 |        5 | six***
        3 |        5 | six***
        3 |        5 | six***
        3 |        6 | seven***
        3 |        6 | seven***
        3 |        6 | seven***
        3 |        6 | seven***
        3 |        6 | seven***
        3 |        6 | seven***
        4 |        7 | eight***
        4 |        7 | eight***
        4 |        7 | eight***
        4 |        7 | eight***
        4 |        7 | eight***
        4 |        7 | eight***
          |       -1 | zero***
          |          | null***
          |       -1 | zero***
          |          | null***
          |          | null***
          |          | null***
          |       -1 | zero***
          |       -1 | zero***
          |          | null***
          |          | null***
          |       -1 | zero***
          |       -1 | zero***
(64 rows)

--Join  with LIMIT, OFFSET, aggregate function, GROUP BY
--Testcase 221:
EXPLAIN VERBOSE SELECT t1.i, count(k), '12x ' || t  FROM J1_TBL t1 INNER JOIN J2_TBL t2 ON t2.i != 0 GROUP BY t1.i, k, t LIMIT 5 OFFSET 0;
                                                                                              QUERY PLAN                                                                                               
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=87029.11..87031.29 rows=0 width=80)
   Output: t1.i, (count(t2.k)), (('12x '::text || t1.t)), t2.k, t1.t
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Agg push-down: yes
     Relations: Aggregate on ((public.j1_tbl t1) INNER JOIN (public.j2_tbl t2))
     Remote SQL: SELECT r1.i, count(r2.k), ('12x '::text || r1.t), r2.k, r1.t FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (((r2.i <> 0)))) GROUP BY 1, 4, 5 LIMIT 5::bigint OFFSET 0::bigint
(7 rows)

--Testcase 222:
SELECT t1.i, count(k), '12x ' || t  FROM J1_TBL t1 INNER JOIN J2_TBL t2 ON t2.i != 0 GROUP BY t1.i, k, t LIMIT 5 OFFSET 0;
 i | count | ?column?  
---+-------+-----------
 0 |     2 | 12x zero
 5 |     1 | 12x five
 4 |     1 | 12x four
   |     1 | 12x null
 8 |     1 | 12x eight
(5 rows)

--Testcase 223:
EXPLAIN VERBOSE SELECT count(J1_TBL.i), avg(k), min(t) FROM J1_TBL CROSS JOIN J2_TBL GROUP BY k, t LIMIT 5 OFFSET 0;
                                                                                    QUERY PLAN                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=58342.85..58343.00 rows=0 width=108)
   Output: (count(j1_tbl.i)), (avg(j2_tbl.k)), (min(j1_tbl.t)), j2_tbl.k, j1_tbl.t
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Agg push-down: yes
     Relations: Aggregate on ((public.j1_tbl) INNER JOIN (public.j2_tbl))
     Remote SQL: SELECT count(r1.i), avg(r2.k), min(r1.t), r2.k, r1.t FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (TRUE)) GROUP BY 4, 5 LIMIT 5::bigint OFFSET 0::bigint
(7 rows)

--Testcase 224:
SELECT count(J1_TBL.i), avg(k), min(t) FROM J1_TBL CROSS JOIN J2_TBL GROUP BY k, t LIMIT 5 OFFSET 0;
 count |           avg           |  min  
-------+-------------------------+-------
     2 |     -5.0000000000000000 | one
     1 |      2.0000000000000000 | six
     1 | -1.00000000000000000000 | three
     1 |                         | three
     1 |      2.0000000000000000 | four
(5 rows)

--Testcase 225:
EXPLAIN VERBOSE SELECT max(t1.a), min(t1.b), t2.d FROM J1_TBL t1(a, b, c, f) FULL JOIN J2_TBL t2(d, e, f) ON t1.a = t2.d GROUP BY t1.a, t1.b, t2.d LIMIT 5 OFFSET 5;
                                                                                       QUERY PLAN                                                                                        
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=87466.46..87468.64 rows=0 width=20)
   Output: (max(t1.a)), (min(t1.b)), t2.d, t1.a, t1.b
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Agg push-down: yes
     Relations: Aggregate on ((public.j1_tbl t1) FULL JOIN (public.j2_tbl t2))
     Remote SQL: SELECT max(r1.i), min(r1.j), r2.i, r1.i, r1.j FROM (public.j1_tbl r1 FULL JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) GROUP BY 4, 5, 3 LIMIT 5::bigint OFFSET 5::bigint
(7 rows)

--Testcase 226:
SELECT max(t1.a), min(t1.b), t2.d FROM J1_TBL t1(a, b, c, f) FULL JOIN J2_TBL t2(d, e, f) ON t1.a = t2.d GROUP BY t1.a, t1.b, t2.d LIMIT 5 OFFSET 5;
 max | min | d 
-----+-----+---
   8 |   8 |  
   1 |   4 | 1
   2 |   3 | 2
   7 |   7 |  
   5 |   0 | 5
(5 rows)

--Testcase 227:
EXPLAIN VERBOSE SELECT t1.i, max(k), min(t3.t) FROM J1_TBL t1 CROSS JOIN J2_TBL t2 INNER JOIN J3_TBL t3 USING(t) GROUP BY t1.i, k, t3.t LIMIT 5 OFFSET 0;
                                                                                                            QUERY PLAN                                                                                                            
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=298174344.98..298174345.14 rows=0 width=76)
   Output: t1.i, (max(t2.k)), (min(t3.t)), t2.k, t3.t
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Agg push-down: yes
     Relations: Aggregate on (((public.j1_tbl t1) INNER JOIN (public.j3_tbl t3)) INNER JOIN (public.j2_tbl t2))
     Remote SQL: SELECT r1.i, max(r2.k), min(r4.t), r2.k, r4.t FROM ((public.j1_tbl r1 INNER JOIN public.j3_tbl r4 ON (((r1.t = r4.t)))) INNER JOIN public.j2_tbl r2 ON (TRUE)) GROUP BY 1, 4, 5 LIMIT 5::bigint OFFSET 0::bigint
(7 rows)

--Testcase 228:
SELECT t1.i, max(k), min(t3.t) FROM J1_TBL t1 CROSS JOIN J2_TBL t2 INNER JOIN J3_TBL t3 USING(t) GROUP BY t1.i, k, t3.t LIMIT 5 OFFSET 0;
 i | max | min  
---+-----+------
 5 |  -1 | five
 5 |   4 | five
 5 |  -3 | five
 5 |   0 | five
 5 |  -5 | five
(5 rows)

--Join  with WHERE, LIMIT, OFFSET, ORDER BY, GROUP BY
--Testcase 229:
EXPLAIN VERBOSE SELECT a.i, a.j, ss.z FROM J1_TBL a LEFT JOIN (SELECT i FROM J2_TBL y) ss(z) ON a.i = ss.z WHERE a.j = ss.z GROUP BY a.i, a.j, ss.z ORDER BY a.i ASC, a.j DESC, ss.z LIMIT 5 OFFSET 1;
                                                                                                     QUERY PLAN                                                                                                      
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=557.05..557.76 rows=0 width=12)
   Output: a.i, a.j, y.i
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Sort push-down: yes
     Agg push-down: yes
     Relations: Aggregate on ((public.j1_tbl a) INNER JOIN (public.j2_tbl y))
     Remote SQL: SELECT r1.i, r1.j, r4.i FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r4 ON (((r1.i = r4.i)) AND ((r1.i = r1.j)))) GROUP BY 1, 2, 3 ORDER BY r1.i ASC NULLS LAST LIMIT 5::bigint OFFSET 1::bigint
(8 rows)

--Testcase 230:
SELECT a.i, a.j, ss.z FROM J1_TBL a LEFT JOIN (SELECT i FROM J2_TBL y) ss(z) ON a.i = ss.z WHERE a.j = ss.z GROUP BY a.i, a.j, ss.z ORDER BY a.i ASC, a.j DESC, ss.z LIMIT 5 OFFSET 1;
 i | j | z 
---+---+---
(0 rows)

--Testcase 231:
EXPLAIN VERBOSE SELECT f1.i, f1.j, f2.i FROM J1_TBL f1 RIGHT JOIN J2_TBL f2 ON (f1.i = f2.i AND f1.j IS NOT NULL) WHERE f1.t IS NULL GROUP BY f1.i, f1.j, f2.i ORDER BY 1 DESC LIMIT 5 OFFSET 1;
                                                                                                                    QUERY PLAN                                                                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=91376.02..91378.29 rows=0 width=12)
   Output: f1.i, f1.j, f2.i
   Node: postgres_svr / Status: Alive
     Limit push-down: yes
     Sort push-down: yes
     Agg push-down: yes
     Relations: Aggregate on ((public.j2_tbl f2) LEFT JOIN (public.j1_tbl f1))
     Remote SQL: SELECT r1.i, r1.j, r2.i FROM (public.j2_tbl r2 LEFT JOIN public.j1_tbl r1 ON (((r1.i = r2.i)) AND ((r1.j IS NOT NULL)))) WHERE ((r1.t IS NULL)) GROUP BY 1, 2, 3 ORDER BY r1.i DESC NULLS FIRST LIMIT 5::bigint OFFSET 1::bigint
(8 rows)

--Testcase 232:
SELECT f1.i, f1.j, f2.i FROM J1_TBL f1 RIGHT JOIN J2_TBL f2 ON (f1.i = f2.i AND f1.j IS NOT NULL) WHERE f1.t IS NULL GROUP BY f1.i, f1.j, f2.i ORDER BY 1 DESC LIMIT 5 OFFSET 1;
 i | j | i 
---+---+---
   |   |  
(1 row)

--Pattern 9
--Join  with GROUP BY + ORDER BY
--Testcase 233:
EXPLAIN VERBOSE SELECT j2_tbl.i, k FROM j2_tbl INNER JOIN (SELECT i FROM j1_tbl GROUP BY i) j3 ON j2_tbl.i = j3.i GROUP BY j3.i, j2_tbl.i, k  ORDER BY j3.i;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Group  (cost=108.53..158.80 rows=17 width=12)
   Output: j2_tbl.i, j2_tbl.k, j1_tbl.i
   Group Key: j1_tbl.i, j2_tbl.i, j2_tbl.k
   ->  Nested Loop  (cost=108.53..158.68 rows=17 width=12)
         Output: j2_tbl.i, j2_tbl.k, j1_tbl.i
         Inner Unique: true
         Join Filter: (j2_tbl.i = j1_tbl.i)
         ->  Foreign Scan on public.j2_tbl  (cost=0.00..0.00 rows=1 width=8)
               Output: j2_tbl.i, j2_tbl.k
               Node: postgres_svr / Status: Alive
                 Sort push-down: yes
                 Remote SQL: SELECT i, k FROM public.j2_tbl ORDER BY i ASC NULLS LAST, k ASC NULLS LAST
         ->  Foreign Scan  (cost=108.53..158.66 rows=0 width=4)
               Output: j1_tbl.i
               Node: postgres_svr / Status: Alive
                 Agg push-down: yes
                 Relations: Aggregate on (public.j1_tbl)
                 Remote SQL: SELECT i FROM public.j1_tbl GROUP BY 1
(18 rows)

--Testcase 234:
SELECT j2_tbl.i, k FROM j2_tbl INNER JOIN (SELECT i FROM j1_tbl GROUP BY i) j3 ON j2_tbl.i = j3.i GROUP BY j3.i, j2_tbl.i, k  ORDER BY j3.i;
 i | k  
---+----
 0 |   
 1 | -1
 2 |  2
 2 |  4
 3 | -3
 5 | -5
(6 rows)

--Testcase 235:
EXPLAIN VERBOSE SELECT t1.j FROM j1_tbl t1 LEFT JOIN j2_tbl t2 ON (t1.i = t2.i) GROUP BY t1.j ORDER BY t1.j;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=30677.49..61353.76 rows=0 width=4)
   Output: t1.j
   Node: postgres_svr / Status: Alive
     Sort push-down: yes
     Agg push-down: yes
     Relations: Aggregate on ((public.j1_tbl t1) LEFT JOIN (public.j2_tbl t2))
     Remote SQL: SELECT r1.j FROM (public.j1_tbl r1 LEFT JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) GROUP BY 1 ORDER BY r1.j ASC NULLS LAST
(7 rows)

--Testcase 236:
SELECT t1.j FROM j1_tbl t1 LEFT JOIN j2_tbl t2 ON (t1.i = t2.i) GROUP BY t1.j ORDER BY t1.j;
 j 
---
 0
 1
 2
 3
 4
 6
 7
 8
  
(9 rows)

--Testcase 237:
EXPLAIN VERBOSE SELECT t1.i FROM j1_tbl t1 FULL JOIN (SELECT i, k FROM j2_tbl) t2 ON (t1.i = t2.i) GROUP BY t1.i ORDER BY 1;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=30677.49..61353.76 rows=0 width=4)
   Output: t1.i
   Node: postgres_svr / Status: Alive
     Sort push-down: yes
     Agg push-down: yes
     Relations: Aggregate on ((public.j1_tbl t1) FULL JOIN (public.j2_tbl))
     Remote SQL: SELECT r1.i FROM (public.j1_tbl r1 FULL JOIN public.j2_tbl r4 ON (((r1.i = r4.i)))) GROUP BY 1 ORDER BY r1.i ASC NULLS LAST
(7 rows)

--Testcase 238:
SELECT t1.i FROM j1_tbl t1 FULL JOIN (SELECT i, k FROM j2_tbl) t2 ON (t1.i = t2.i) GROUP BY t1.i ORDER BY 1;
 i 
---
 0
 1
 2
 3
 4
 5
 6
 7
 8
  
(10 rows)

--Testcase 239:
EXPLAIN VERBOSE SELECT j1.i, j1.j, j2.k  FROM J1_TBL j1 CROSS JOIN J2_TBL j2 GROUP BY j1.i, j1.j, j2.k ORDER BY j2.k;
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=91832.48..94005.25 rows=0 width=12)
   Output: j1.i, j1.j, j2.k
   Node: postgres_svr / Status: Alive
     Sort push-down: yes
     Agg push-down: yes
     Relations: Aggregate on ((public.j1_tbl j1) INNER JOIN (public.j2_tbl j2))
     Remote SQL: SELECT r1.i, r1.j, r2.k FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (TRUE)) GROUP BY 3, 1, 2 ORDER BY r2.k ASC NULLS LAST
(7 rows)

--Testcase 240:
SELECT j1.i, j1.j, j2.k  FROM J1_TBL j1 CROSS JOIN J2_TBL j2 GROUP BY j1.i, j1.j, j2.k ORDER BY j2.k;
 i | j | k  
---+---+----
 7 | 7 | -5
   | 0 | -5
 4 | 1 | -5
 5 | 0 | -5
 2 | 3 | -5
 6 | 6 | -5
 3 | 2 | -5
 8 | 8 | -5
 0 |   | -5
   |   | -5
 1 | 4 | -5
 7 | 7 | -3
 5 | 0 | -3
 6 | 6 | -3
 3 | 2 | -3
 2 | 3 | -3
 1 | 4 | -3
 8 | 8 | -3
   | 0 | -3
 4 | 1 | -3
 0 |   | -3
   |   | -3
 0 |   | -1
 2 | 3 | -1
 1 | 4 | -1
 4 | 1 | -1
 6 | 6 | -1
 3 | 2 | -1
   | 0 | -1
   |   | -1
 7 | 7 | -1
 8 | 8 | -1
 5 | 0 | -1
 2 | 3 |  0
   | 0 |  0
 6 | 6 |  0
 1 | 4 |  0
 5 | 0 |  0
 0 |   |  0
 3 | 2 |  0
 7 | 7 |  0
   |   |  0
 4 | 1 |  0
 8 | 8 |  0
   | 0 |  2
 1 | 4 |  2
 8 | 8 |  2
   |   |  2
 3 | 2 |  2
 4 | 1 |  2
 6 | 6 |  2
 5 | 0 |  2
 2 | 3 |  2
 7 | 7 |  2
 0 |   |  2
 1 | 4 |  4
   | 0 |  4
 2 | 3 |  4
 0 |   |  4
 4 | 1 |  4
 6 | 6 |  4
 8 | 8 |  4
   |   |  4
 3 | 2 |  4
 5 | 0 |  4
 7 | 7 |  4
 4 | 1 |   
 0 |   |   
   | 0 |   
 7 | 7 |   
   |   |   
 5 | 0 |   
 6 | 6 |   
 1 | 4 |   
 2 | 3 |   
 3 | 2 |   
 8 | 8 |   
(77 rows)

--Testcase 241:
EXPLAIN VERBOSE SELECT J2_TBL.k, J1_TBL.t FROM J1_TBL RIGHT JOIN J2_TBL ON (J1_TBL.i <= J2_TBL.k) GROUP BY J1_TBL.i, J2_TBL.k, J1_TBL.t ORDER BY J2_TBL.k;
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=91832.48..124582.75 rows=0 width=40)
   Output: j2_tbl.k, j1_tbl.t, j1_tbl.i
   Node: postgres_svr / Status: Alive
     Sort push-down: yes
     Agg push-down: yes
     Relations: Aggregate on ((public.j2_tbl) LEFT JOIN (public.j1_tbl))
     Remote SQL: SELECT r2.k, r1.t, r1.i FROM (public.j2_tbl r2 LEFT JOIN public.j1_tbl r1 ON (((r1.i <= r2.k)))) GROUP BY 1, 3, 2 ORDER BY r2.k ASC NULLS LAST
(7 rows)

--Testcase 242:
SELECT J2_TBL.k, J1_TBL.t FROM J1_TBL RIGHT JOIN J2_TBL ON (J1_TBL.i <= J2_TBL.k) GROUP BY J1_TBL.i, J2_TBL.k, J1_TBL.t ORDER BY J2_TBL.k;
 k  |   t   
----+-------
 -5 | 
 -3 | 
 -1 | 
  0 | zero
  2 | zero
  2 | two
  2 | one
  4 | three
  4 | one
  4 | zero
  4 | two
  4 | four
    | 
(13 rows)

--Testcase 243:
EXPLAIN VERBOSE SELECT t1.i, j, t3.t FROM J1_TBL t1 FULL JOIN J2_TBL t2 ON t1.i = t2.i LEFT JOIN J3_TBL t3 ON t3.i = 1 GROUP BY t1.i, t1.j, t1.t, t3.t ORDER BY t1.i, t1.j, t1.t, t3.t;
                                                                                                                                      QUERY PLAN                                                                                                                                      
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=2079369.57..2630078.83 rows=0 width=72)
   Output: t1.i, t1.j, t3.t, t1.t
   Node: postgres_svr / Status: Alive
     Sort push-down: yes
     Agg push-down: yes
     Relations: Aggregate on (((public.j1_tbl t1) FULL JOIN (public.j2_tbl t2)) LEFT JOIN (public.j3_tbl t3))
     Remote SQL: SELECT r1.i, r1.j, r4.t, r1.t FROM ((public.j1_tbl r1 FULL JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) LEFT JOIN public.j3_tbl r4 ON (((r4.i = 1)))) GROUP BY 1, 2, 4, 3 ORDER BY r1.i ASC NULLS LAST, r1.j ASC NULLS LAST, r1.t ASC NULLS LAST, r4.t ASC NULLS LAST
(7 rows)

--Testcase 244:
SELECT t1.i, j, t3.t FROM J1_TBL t1 FULL JOIN J2_TBL t2 ON t1.i = t2.i LEFT JOIN J3_TBL t3 ON t3.i = 1 GROUP BY t1.i, t1.j, t1.t, t3.t ORDER BY t1.i, t1.j, t1.t, t3.t;
 i | j |   t   
---+---+-------
 0 |   | first
 1 | 4 | first
 2 | 3 | first
 3 | 2 | first
 4 | 1 | first
 5 | 0 | first
 6 | 6 | first
 7 | 7 | first
 8 | 8 | first
   | 0 | first
   |   | first
   |   | first
(12 rows)

--Join  + aggregate functions + GROUP BY + ORDER BY
--Testcase 245:
EXPLAIN VERBOSE SELECT count(t1.i) - 1, k, t FROM J1_TBL t1 INNER JOIN J2_TBL t2 ON t2.i != 0 GROUP BY t1.i, k, t ORDER BY 1, 2, 3;
                                                                                                               QUERY PLAN                                                                                                               
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=124530.37..126064.87 rows=0 width=48)
   Output: ((count(t1.i) - 1)), t2.k, t1.t, t1.i
   Node: postgres_svr / Status: Alive
     Sort push-down: yes
     Agg push-down: yes
     Relations: Aggregate on ((public.j1_tbl t1) INNER JOIN (public.j2_tbl t2))
     Remote SQL: SELECT (count(r1.i) - 1), r2.k, r1.t, r1.i FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (((r2.i <> 0)))) GROUP BY 4, 2, 3 ORDER BY (count(r1.i) - 1) ASC NULLS LAST, r2.k ASC NULLS LAST, r1.t ASC NULLS LAST
(7 rows)

--Testcase 246:
SELECT count(t1.i) - 1, k, t FROM J1_TBL t1 INNER JOIN J2_TBL t2 ON t2.i != 0 GROUP BY t1.i, k, t ORDER BY 1, 2, 3;
 ?column? | k  |   t   
----------+----+-------
       -1 | -5 | null
       -1 | -5 | zero
       -1 | -3 | null
       -1 | -3 | zero
       -1 | -1 | null
       -1 | -1 | zero
       -1 |  2 | null
       -1 |  2 | zero
       -1 |  4 | null
       -1 |  4 | zero
        0 | -3 | eight
        0 | -3 | five
        0 | -3 | four
        0 | -3 | one
        0 | -3 | seven
        0 | -3 | six
        0 | -3 | three
        0 | -3 | two
        0 | -3 | zero
        0 | -1 | eight
        0 | -1 | five
        0 | -1 | four
        0 | -1 | one
        0 | -1 | seven
        0 | -1 | six
        0 | -1 | three
        0 | -1 | two
        0 | -1 | zero
        0 |  2 | eight
        0 |  2 | five
        0 |  2 | four
        0 |  2 | one
        0 |  2 | seven
        0 |  2 | six
        0 |  2 | three
        0 |  2 | two
        0 |  2 | zero
        0 |  4 | eight
        0 |  4 | five
        0 |  4 | four
        0 |  4 | one
        0 |  4 | seven
        0 |  4 | six
        0 |  4 | three
        0 |  4 | two
        0 |  4 | zero
        1 | -5 | eight
        1 | -5 | five
        1 | -5 | four
        1 | -5 | one
        1 | -5 | seven
        1 | -5 | six
        1 | -5 | three
        1 | -5 | two
        1 | -5 | zero
(55 rows)

--Testcase 247:
EXPLAIN VERBOSE SELECT sum(x.i+x.j), avg(k) FROM J1_TBL x CROSS JOIN J2_TBL y GROUP BY k, t ORDER BY k, t;
                                                                                           QUERY PLAN                                                                                           
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=61254.99..62567.66 rows=0 width=76)
   Output: (sum((x.i + x.j))), (avg(y.k)), y.k, x.t
   Node: postgres_svr / Status: Alive
     Sort push-down: yes
     Agg push-down: yes
     Relations: Aggregate on ((public.j1_tbl x) INNER JOIN (public.j2_tbl y))
     Remote SQL: SELECT sum((r1.i + r1.j)), avg(r2.k), r2.k, r1.t FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (TRUE)) GROUP BY 3, 4 ORDER BY r2.k ASC NULLS LAST, r1.t ASC NULLS LAST
(7 rows)

--Testcase 248:
SELECT sum(x.i+x.j), avg(k) FROM J1_TBL x CROSS JOIN J2_TBL y GROUP BY k, t ORDER BY k, t;
 sum |           avg           
-----+-------------------------
  32 |     -5.0000000000000000
  10 |     -5.0000000000000000
  10 |     -5.0000000000000000
     |     -5.0000000000000000
  10 |     -5.0000000000000000
  28 |     -5.0000000000000000
  24 |     -5.0000000000000000
  10 |     -5.0000000000000000
  10 |     -5.0000000000000000
     |     -5.0000000000000000
  16 |     -3.0000000000000000
   5 |     -3.0000000000000000
   5 |     -3.0000000000000000
     |     -3.0000000000000000
   5 |     -3.0000000000000000
  14 |     -3.0000000000000000
  12 |     -3.0000000000000000
   5 |     -3.0000000000000000
   5 |     -3.0000000000000000
     |     -3.0000000000000000
  16 | -1.00000000000000000000
   5 | -1.00000000000000000000
   5 | -1.00000000000000000000
     | -1.00000000000000000000
   5 | -1.00000000000000000000
  14 | -1.00000000000000000000
  12 | -1.00000000000000000000
   5 | -1.00000000000000000000
   5 | -1.00000000000000000000
     | -1.00000000000000000000
  16 |  0.00000000000000000000
   5 |  0.00000000000000000000
   5 |  0.00000000000000000000
     |  0.00000000000000000000
   5 |  0.00000000000000000000
  14 |  0.00000000000000000000
  12 |  0.00000000000000000000
   5 |  0.00000000000000000000
   5 |  0.00000000000000000000
     |  0.00000000000000000000
  16 |      2.0000000000000000
   5 |      2.0000000000000000
   5 |      2.0000000000000000
     |      2.0000000000000000
   5 |      2.0000000000000000
  14 |      2.0000000000000000
  12 |      2.0000000000000000
   5 |      2.0000000000000000
   5 |      2.0000000000000000
     |      2.0000000000000000
  16 |      4.0000000000000000
   5 |      4.0000000000000000
   5 |      4.0000000000000000
     |      4.0000000000000000
   5 |      4.0000000000000000
  14 |      4.0000000000000000
  12 |      4.0000000000000000
   5 |      4.0000000000000000
   5 |      4.0000000000000000
     |      4.0000000000000000
  16 |                        
   5 |                        
   5 |                        
     |                        
   5 |                        
  14 |                        
  12 |                        
   5 |                        
   5 |                        
     |                        
(70 rows)

--Testcase 249:
EXPLAIN VERBOSE SELECT max(t1.a) + max(t2.d) + 1, t1.b, t2.e FROM J1_TBL t1(a, b, c, f) FULL JOIN J2_TBL t2(d, e, f) ON t1.a = t2.d GROUP BY t1.a, t1.b, t2.e ORDER BY t1.a, t1.b, t2.e;
                                                                                                               QUERY PLAN                                                                                                               
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=91832.48..124940.80 rows=0 width=16)
   Output: (((max(t1.a) + max(t2.d)) + 1)), t1.b, t2.e, t1.a
   Node: postgres_svr / Status: Alive
     Sort push-down: yes
     Agg push-down: yes
     Relations: Aggregate on ((public.j1_tbl t1) FULL JOIN (public.j2_tbl t2))
     Remote SQL: SELECT ((max(r1.i) + max(r2.i)) + 1), r1.j, r2.k, r1.i FROM (public.j1_tbl r1 FULL JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) GROUP BY 4, 2, 3 ORDER BY r1.i ASC NULLS LAST, r1.j ASC NULLS LAST, r2.k ASC NULLS LAST
(7 rows)

--Testcase 250:
SELECT max(t1.a) + max(t2.d) + 1, t1.b, t2.e FROM J1_TBL t1(a, b, c, f) FULL JOIN J2_TBL t2(d, e, f) ON t1.a = t2.d GROUP BY t1.a, t1.b, t2.e ORDER BY t1.a, t1.b, t2.e;
 ?column? | b | e  
----------+---+----
        1 |   |   
        3 | 4 | -1
        5 | 3 |  2
        5 | 3 |  4
        7 | 2 | -3
          | 1 |   
       11 | 0 | -5
          | 6 |   
          | 7 |   
          | 8 |   
          | 0 |   
          |   |  0
          |   |   
(13 rows)

--Testcase 251:
EXPLAIN VERBOSE SELECT min(a.j), ss.z FROM J1_TBL a LEFT JOIN (SELECT i FROM J2_TBL y) ss(z) ON a.i = ss.z GROUP BY a.j, ss.z ORDER BY ss.z;
                                                                           QUERY PLAN                                                                            
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=61254.99..93145.15 rows=0 width=12)
   Output: (min(a.j)), y.i, a.j
   Node: postgres_svr / Status: Alive
     Sort push-down: yes
     Agg push-down: yes
     Relations: Aggregate on ((public.j1_tbl a) LEFT JOIN (public.j2_tbl y))
     Remote SQL: SELECT min(r1.j), r4.i, r1.j FROM (public.j1_tbl r1 LEFT JOIN public.j2_tbl r4 ON (((r1.i = r4.i)))) GROUP BY 2, 3 ORDER BY r4.i ASC NULLS LAST
(7 rows)

--Testcase 252:
SELECT min(a.j), ss.z FROM J1_TBL a LEFT JOIN (SELECT i FROM J2_TBL y) ss(z) ON a.i = ss.z GROUP BY a.j, ss.z ORDER BY ss.z;
 min | z 
-----+---
     | 0
   4 | 1
   3 | 2
   2 | 3
   0 | 5
   0 |  
   1 |  
   6 |  
   7 |  
   8 |  
     |  
(11 rows)

--Testcase 253:
EXPLAIN VERBOSE SELECT f1.i, min(f1.j) > 0, f1.j, f2.i FROM J1_TBL f1 RIGHT JOIN J2_TBL f2 ON (f1.i = f2.i AND f1.j IS NULL) GROUP BY f1.i, f1.j, f2.i ORDER BY f1.i;
                                                                                             QUERY PLAN                                                                                              
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=556.92..914.52 rows=0 width=13)
   Output: f1.i, ((min(f1.j) > 0)), f1.j, f2.i
   Node: postgres_svr / Status: Alive
     Sort push-down: yes
     Agg push-down: yes
     Relations: Aggregate on ((public.j2_tbl f2) LEFT JOIN (public.j1_tbl f1))
     Remote SQL: SELECT r1.i, (min(r1.j) > 0), r1.j, r2.i FROM (public.j2_tbl r2 LEFT JOIN public.j1_tbl r1 ON (((r1.i = r2.i)) AND ((r1.j IS NULL)))) GROUP BY 1, 3, 4 ORDER BY r1.i ASC NULLS LAST
(7 rows)

--Testcase 254:
SELECT f1.i, min(f1.j) > 0, f1.j, f2.i FROM J1_TBL f1 RIGHT JOIN J2_TBL f2 ON (f1.i = f2.i AND f1.j IS NULL) GROUP BY f1.i, f1.j, f2.i ORDER BY f1.i;
 i | ?column? | j | i 
---+----------+---+---
 0 |          |   | 0
   |          |   |  
   |          |   | 2
   |          |   | 3
   |          |   | 5
   |          |   | 1
(6 rows)

--Testcase 255:
EXPLAIN VERBOSE SELECT t1.i, k, max(t3.t) FROM J1_TBL t1 CROSS JOIN J2_TBL t2 INNER JOIN J3_TBL t3 USING(t) GROUP BY t1.i, k, t3.t ORDER BY 1, 2, 3;
                                                                                                                            QUERY PLAN                                                                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=299857111.53..300037111.53 rows=0 width=72)
   Output: t1.i, t2.k, (max(t3.t)), t3.t
   Node: postgres_svr / Status: Alive
     Sort push-down: yes
     Agg push-down: yes
     Relations: Aggregate on (((public.j1_tbl t1) INNER JOIN (public.j3_tbl t3)) INNER JOIN (public.j2_tbl t2))
     Remote SQL: SELECT r1.i, r2.k, max(r4.t), r4.t FROM ((public.j1_tbl r1 INNER JOIN public.j3_tbl r4 ON (((r1.t = r4.t)))) INNER JOIN public.j2_tbl r2 ON (TRUE)) GROUP BY 1, 2, 4 ORDER BY r1.i ASC NULLS LAST, r2.k ASC NULLS LAST, max(r4.t) ASC NULLS LAST
(7 rows)

--Testcase 256:
SELECT t1.i, k, max(t3.t) FROM J1_TBL t1 CROSS JOIN J2_TBL t2 INNER JOIN J3_TBL t3 USING(t) GROUP BY t1.i, k, t3.t ORDER BY 1, 2, 3;
 i | k  | max  
---+----+------
 5 | -5 | five
 5 | -3 | five
 5 | -1 | five
 5 |  0 | five
 5 |  2 | five
 5 |  4 | five
 5 |    | five
(7 rows)

--Join  with ORDER BY
--Testcase 257:
EXPLAIN VERBOSE SELECT t1.i, t2.i, t1.j, t2.k FROM J1_TBL t1 LEFT JOIN J2_TBL t2 ON t1.i = t2.i ORDER BY t1.i, t2.i;
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=16)
   Output: t1.i, t2.i, t1.j, t2.k
   Node: postgres_svr / Status: Alive
     Sort push-down: yes
     Relations: (public.j1_tbl t1) LEFT JOIN (public.j2_tbl t2)
     Remote SQL: SELECT r1.i, r2.i, r1.j, r2.k FROM (public.j1_tbl r1 LEFT JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) ORDER BY r1.i ASC NULLS LAST, r2.i ASC NULLS LAST
(6 rows)

--Testcase 258:
SELECT t1.i, t2.i, t1.j, t2.k FROM J1_TBL t1 LEFT JOIN J2_TBL t2 ON t1.i = t2.i ORDER BY t1.i, t2.i;
 i | i | j | k  
---+---+---+----
 0 | 0 |   |   
 1 | 1 | 4 | -1
 2 | 2 | 3 |  2
 2 | 2 | 3 |  4
 3 | 3 | 2 | -3
 4 |   | 1 |   
 5 | 5 | 0 | -5
 5 | 5 | 0 | -5
 6 |   | 6 |   
 7 |   | 7 |   
 8 |   | 8 |   
   |   |   |   
   |   | 0 |   
(13 rows)

--Testcase 259:
EXPLAIN VERBOSE SELECT t2.i, t2.k FROM J1_TBL t1 FULL JOIN J2_TBL t2 using(i) ORDER BY t1.i;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=12)
   Output: t2.i, t2.k, t1.i
   Node: postgres_svr / Status: Alive
     Sort push-down: yes
     Relations: (public.j1_tbl t1) FULL JOIN (public.j2_tbl t2)
     Remote SQL: SELECT r2.i, r2.k, r1.i FROM (public.j1_tbl r1 FULL JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) ORDER BY r1.i ASC NULLS LAST
(6 rows)

--Testcase 260:
SELECT t2.i, t2.k FROM J1_TBL t1 FULL JOIN J2_TBL t2 using(i) ORDER BY t1.i;
 i | k  
---+----
 0 |   
 1 | -1
 2 |  2
 2 |  4
 3 | -3
   |   
 5 | -5
 5 | -5
   |   
   |   
   |   
   |  0
   |   
   |   
(14 rows)

--Testcase 261:
EXPLAIN VERBOSE SELECT J1_TBL.i, J1_TBL.j, J1_TBL.t, J2_TBL.i, J2_TBL.k FROM J1_TBL CROSS JOIN J2_TBL ORDER BY J1_TBL.i;
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=48)
   Output: j1_tbl.i, j1_tbl.j, j1_tbl.t, j2_tbl.i, j2_tbl.k
   Node: postgres_svr / Status: Alive
     Sort push-down: yes
     Relations: (public.j1_tbl) INNER JOIN (public.j2_tbl)
     Remote SQL: SELECT r1.i, r1.j, r1.t, r2.i, r2.k FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (TRUE)) ORDER BY r1.i ASC NULLS LAST
(6 rows)

--Testcase 262:
SELECT J1_TBL.i, J1_TBL.j, J1_TBL.t, J2_TBL.i, J2_TBL.k FROM J1_TBL CROSS JOIN J2_TBL ORDER BY J1_TBL.i;
 i | j |   t   | i | k  
---+---+-------+---+----
 0 |   | zero  | 1 | -1
 0 |   | zero  |   |  0
 0 |   | zero  | 0 |   
 0 |   | zero  | 5 | -5
 0 |   | zero  | 5 | -5
 0 |   | zero  | 2 |  4
 0 |   | zero  | 3 | -3
 0 |   | zero  | 2 |  2
 1 | 4 | one   | 3 | -3
 1 | 4 | one   | 2 |  2
 1 | 4 | one   | 1 | -1
 1 | 4 | one   | 2 |  4
 1 | 4 | one   | 5 | -5
 1 | 4 | one   | 5 | -5
 1 | 4 | one   | 0 |   
 1 | 4 | one   |   |  0
 2 | 3 | two   | 2 |  2
 2 | 3 | two   | 0 |   
 2 | 3 | two   |   |  0
 2 | 3 | two   | 5 | -5
 2 | 3 | two   | 1 | -1
 2 | 3 | two   | 3 | -3
 2 | 3 | two   | 5 | -5
 2 | 3 | two   | 2 |  4
 3 | 2 | three | 2 |  4
 3 | 2 | three | 2 |  2
 3 | 2 | three |   |  0
 3 | 2 | three | 1 | -1
 3 | 2 | three | 0 |   
 3 | 2 | three | 3 | -3
 3 | 2 | three | 5 | -5
 3 | 2 | three | 5 | -5
 4 | 1 | four  | 3 | -3
 4 | 1 | four  | 2 |  4
 4 | 1 | four  | 5 | -5
 4 | 1 | four  | 5 | -5
 4 | 1 | four  | 1 | -1
 4 | 1 | four  | 0 |   
 4 | 1 | four  |   |  0
 4 | 1 | four  | 2 |  2
 5 | 0 | five  | 2 |  4
 5 | 0 | five  | 3 | -3
 5 | 0 | five  |   |  0
 5 | 0 | five  | 5 | -5
 5 | 0 | five  | 2 |  2
 5 | 0 | five  | 0 |   
 5 | 0 | five  | 5 | -5
 5 | 0 | five  | 1 | -1
 6 | 6 | six   | 5 | -5
 6 | 6 | six   | 5 | -5
 6 | 6 | six   | 2 |  4
 6 | 6 | six   |   |  0
 6 | 6 | six   | 3 | -3
 6 | 6 | six   | 1 | -1
 6 | 6 | six   | 0 |   
 6 | 6 | six   | 2 |  2
 7 | 7 | seven | 2 |  4
 7 | 7 | seven | 1 | -1
 7 | 7 | seven | 5 | -5
 7 | 7 | seven | 3 | -3
 7 | 7 | seven | 5 | -5
 7 | 7 | seven | 2 |  2
 7 | 7 | seven | 0 |   
 7 | 7 | seven |   |  0
 8 | 8 | eight |   |  0
 8 | 8 | eight | 2 |  4
 8 | 8 | eight | 0 |   
 8 | 8 | eight | 3 | -3
 8 | 8 | eight | 5 | -5
 8 | 8 | eight | 1 | -1
 8 | 8 | eight | 5 | -5
 8 | 8 | eight | 2 |  2
   |   | null  | 0 |   
   |   | null  | 5 | -5
   | 0 | zero  |   |  0
   |   | null  | 2 |  2
   | 0 | zero  | 3 | -3
   |   | null  | 3 | -3
   | 0 | zero  | 5 | -5
   |   | null  | 1 | -1
   | 0 | zero  | 0 |   
   | 0 | zero  | 5 | -5
   |   | null  |   |  0
   |   | null  | 5 | -5
   | 0 | zero  | 2 |  4
   | 0 | zero  | 1 | -1
   |   | null  | 2 |  4
   | 0 | zero  | 2 |  2
(88 rows)

--Testcase 263:
EXPLAIN VERBOSE SELECT t1.i FROM J1_TBL AS t1 INNER JOIN J2_TBL AS t2 ON t1.i = t2.i ORDER BY t1.i;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=4)
   Output: t1.i
   Node: postgres_svr / Status: Alive
     Sort push-down: yes
     Relations: (public.j1_tbl t1) INNER JOIN (public.j2_tbl t2)
     Remote SQL: SELECT r1.i FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) ORDER BY r1.i ASC NULLS LAST
(6 rows)

--Testcase 264:
SELECT t1.i FROM J1_TBL AS t1 INNER JOIN J2_TBL AS t2 ON t1.i = t2.i ORDER BY t1.i;
 i 
---
 0
 1
 2
 2
 3
 5
 5
(7 rows)

--Testcase 265:
EXPLAIN VERBOSE SELECT t2.i FROM J1_TBL t1 RIGHT JOIN J2_TBL t2 ON t2.i = t1.i ORDER BY t2.i;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=4)
   Output: t2.i
   Node: postgres_svr / Status: Alive
     Sort push-down: yes
     Relations: (public.j2_tbl t2) LEFT JOIN (public.j1_tbl t1)
     Remote SQL: SELECT r2.i FROM (public.j2_tbl r2 LEFT JOIN public.j1_tbl r1 ON (((r2.i = r1.i)))) ORDER BY r2.i ASC NULLS LAST
(6 rows)

--Testcase 266:
SELECT t2.i FROM J1_TBL t1 RIGHT JOIN J2_TBL t2 ON t2.i = t1.i ORDER BY t2.i;
 i 
---
 0
 1
 2
 2
 3
 5
 5
  
(8 rows)

--Testcase 267:
EXPLAIN VERBOSE SELECT t1.i, t2.k, t3.i FROM J1_TBL t1 RIGHT JOIN (J2_TBL t2 LEFT JOIN J3_TBL t3 ON t2.i > t3.i INNER JOIN J1_TBL t4 ON t2.i = t4.i) ON t1.i = t2.i AND t1.t != t3.t ORDER BY t1.i, t2.k, t3.i;
                                                                                                                                                    QUERY PLAN                                                                                                                                                    
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=12)
   Output: t1.i, t2.k, t3.i
   Node: postgres_svr / Status: Alive
     Sort push-down: yes
     Relations: (((public.j2_tbl t2) LEFT JOIN (public.j3_tbl t3)) INNER JOIN (public.j1_tbl t4)) LEFT JOIN (public.j1_tbl t1)
     Remote SQL: SELECT r1.i, r2.k, r3.i FROM (((public.j2_tbl r2 LEFT JOIN public.j3_tbl r3 ON (((r2.i > r3.i)))) INNER JOIN public.j1_tbl r5 ON (((r2.i = r5.i)))) LEFT JOIN public.j1_tbl r1 ON (((r1.t <> r3.t)) AND ((r1.i = r2.i)))) ORDER BY r1.i ASC NULLS LAST, r2.k ASC NULLS LAST, r3.i ASC NULLS LAST
(6 rows)

--Testcase 268:
SELECT t1.i, t2.k, t3.i FROM J1_TBL t1 RIGHT JOIN (J2_TBL t2 LEFT JOIN J3_TBL t3 ON t2.i > t3.i INNER JOIN J1_TBL t4 ON t2.i = t4.i) ON t1.i = t2.i AND t1.t != t3.t ORDER BY t1.i, t2.k, t3.i;
 i | k  | i 
---+----+---
 2 |  2 | 1
 2 |  4 | 1
 3 | -3 | 1
 3 | -3 | 2
 5 | -5 | 1
 5 | -5 | 1
 5 | -5 | 2
 5 | -5 | 2
 5 | -5 | 3
 5 | -5 | 3
 5 | -5 | 4
 5 | -5 | 4
   | -5 | 2
   | -5 | 2
   | -3 | 2
   | -1 |  
   |    |  
(17 rows)

--Pattern 10
--Join 
--Testcase 269:
EXPLAIN VERBOSE SELECT tx.ii, tx.jj, tx.kk FROM (J1_TBL t1 (a, b, c, s) CROSS JOIN J2_TBL t2 (d, e, s)) AS tx (ii, jj, tt, ii2, kk, ss1, ss2);
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=12)
   Output: t1.a, t1.b, t2.d
   Node: postgres_svr / Status: Alive
     Relations: (public.j1_tbl t1) INNER JOIN (public.j2_tbl t2)
     Remote SQL: SELECT r1.i, r1.j, r2.i FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (TRUE))
(5 rows)

--Testcase 270:
SELECT tx.ii, tx.jj, tx.kk FROM (J1_TBL t1 (a, b, c, s) CROSS JOIN J2_TBL t2 (d, e, s)) AS tx (ii, jj, tt, ii2, kk, ss1, ss2);
 ii | jj | kk 
----+----+----
  1 |  4 |  1
  2 |  3 |  1
  3 |  2 |  1
  4 |  1 |  1
  5 |  0 |  1
  6 |  6 |  1
  7 |  7 |  1
  8 |  8 |  1
  0 |    |  1
    |    |  1
    |  0 |  1
  1 |  4 |  2
  2 |  3 |  2
  3 |  2 |  2
  4 |  1 |  2
  5 |  0 |  2
  6 |  6 |  2
  7 |  7 |  2
  8 |  8 |  2
  0 |    |  2
    |    |  2
    |  0 |  2
  1 |  4 |  3
  2 |  3 |  3
  3 |  2 |  3
  4 |  1 |  3
  5 |  0 |  3
  6 |  6 |  3
  7 |  7 |  3
  8 |  8 |  3
  0 |    |  3
    |    |  3
    |  0 |  3
  1 |  4 |  2
  2 |  3 |  2
  3 |  2 |  2
  4 |  1 |  2
  5 |  0 |  2
  6 |  6 |  2
  7 |  7 |  2
  8 |  8 |  2
  0 |    |  2
    |    |  2
    |  0 |  2
  1 |  4 |  5
  2 |  3 |  5
  3 |  2 |  5
  4 |  1 |  5
  5 |  0 |  5
  6 |  6 |  5
  7 |  7 |  5
  8 |  8 |  5
  0 |    |  5
    |    |  5
    |  0 |  5
  1 |  4 |  5
  2 |  3 |  5
  3 |  2 |  5
  4 |  1 |  5
  5 |  0 |  5
  6 |  6 |  5
  7 |  7 |  5
  8 |  8 |  5
  0 |    |  5
    |    |  5
    |  0 |  5
  1 |  4 |  0
  2 |  3 |  0
  3 |  2 |  0
  4 |  1 |  0
  5 |  0 |  0
  6 |  6 |  0
  7 |  7 |  0
  8 |  8 |  0
  0 |    |  0
    |    |  0
    |  0 |  0
  1 |  4 |   
  2 |  3 |   
  3 |  2 |   
  4 |  1 |   
  5 |  0 |   
  6 |  6 |   
  7 |  7 |   
  8 |  8 |   
  0 |    |   
    |    |   
    |  0 |   
(88 rows)

--Testcase 271:
EXPLAIN VERBOSE SELECT i, j, t FROM J1_TBL RIGHT JOIN J2_TBL USING (i);
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=40)
   Output: j2_tbl.i, j1_tbl.j, j1_tbl.t
   Node: postgres_svr / Status: Alive
     Relations: (public.j2_tbl) LEFT JOIN (public.j1_tbl)
     Remote SQL: SELECT r2.i, r1.j, r1.t FROM (public.j2_tbl r2 LEFT JOIN public.j1_tbl r1 ON (((r1.i = r2.i))))
(5 rows)

--Testcase 272:
SELECT i, j, t FROM J1_TBL RIGHT JOIN J2_TBL USING (i);
 i | j |   t   
---+---+-------
 1 | 4 | one
 2 | 3 | two
 3 | 2 | three
 2 | 3 | two
 5 | 0 | five
 5 | 0 | five
 0 |   | zero
   |   | 
(8 rows)

--Testcase 273:
EXPLAIN VERBOSE SELECT i, k, t FROM J1_TBL FULL JOIN J2_TBL USING (i);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=40)
   Output: COALESCE(j1_tbl.i, j2_tbl.i), j2_tbl.k, j1_tbl.t
   Node: postgres_svr / Status: Alive
     Relations: (public.j1_tbl) FULL JOIN (public.j2_tbl)
     Remote SQL: SELECT r1.i, r2.i, r2.k, r1.t FROM (public.j1_tbl r1 FULL JOIN public.j2_tbl r2 ON (((r1.i = r2.i))))
(5 rows)

--Testcase 274:
SELECT i, k, t FROM J1_TBL FULL JOIN J2_TBL USING (i);
 i | k  |   t   
---+----+-------
 1 | -1 | one
 2 |  2 | two
 3 | -3 | three
 2 |  4 | two
 5 | -5 | five
 5 | -5 | five
 0 |    | zero
   |  0 | 
   |    | zero
   |    | null
 8 |    | eight
 6 |    | six
 7 |    | seven
 4 |    | four
(14 rows)

--Testcase 275:
EXPLAIN VERBOSE SELECT i, t FROM J1_TBL LEFT JOIN J2_TBL USING (i);
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=36)
   Output: j1_tbl.i, j1_tbl.t
   Node: postgres_svr / Status: Alive
     Relations: (public.j1_tbl) LEFT JOIN (public.j2_tbl)
     Remote SQL: SELECT r1.i, r1.t FROM (public.j1_tbl r1 LEFT JOIN public.j2_tbl r2 ON (((r1.i = r2.i))))
(5 rows)

--Testcase 276:
SELECT i, t FROM J1_TBL LEFT JOIN J2_TBL USING (i);
 i |   t   
---+-------
 1 | one
 2 | two
 3 | three
 2 | two
 5 | five
 5 | five
 0 | zero
   | zero
   | null
 8 | eight
 6 | six
 7 | seven
 4 | four
(13 rows)

--Testcase 277:
EXPLAIN VERBOSE SELECT t1.i FROM J1_TBL AS t1 INNER JOIN J2_TBL AS t2 ON t1.i = t2.i;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=4)
   Output: t1.i
   Node: postgres_svr / Status: Alive
     Relations: (public.j1_tbl t1) INNER JOIN (public.j2_tbl t2)
     Remote SQL: SELECT r1.i FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (((r1.i = r2.i))))
(5 rows)

--Testcase 278:
SELECT t1.i FROM J1_TBL AS t1 INNER JOIN J2_TBL AS t2 ON t1.i = t2.i;
 i 
---
 1
 2
 3
 2
 5
 5
 0
(7 rows)

--Testcase 279:
EXPLAIN VERBOSE SELECT t1.i, j, t3.t FROM J1_TBL t1 FULL JOIN J2_TBL t2 ON t1.i = t2.i LEFT JOIN J3_TBL t3 ON t3.i = 1;
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=40)
   Output: t1.i, t1.j, t3.t
   Node: postgres_svr / Status: Alive
     Relations: ((public.j1_tbl t1) FULL JOIN (public.j2_tbl t2)) LEFT JOIN (public.j3_tbl t3)
     Remote SQL: SELECT r1.i, r1.j, r4.t FROM ((public.j1_tbl r1 FULL JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) LEFT JOIN public.j3_tbl r4 ON (((r4.i = 1))))
(5 rows)

--Testcase 280:
SELECT t1.i, j, t3.t FROM J1_TBL t1 FULL JOIN J2_TBL t2 ON t1.i = t2.i LEFT JOIN J3_TBL t3 ON t3.i = 1;
 i | j |   t   
---+---+-------
 1 | 4 | first
 2 | 3 | first
 3 | 2 | first
 2 | 3 | first
 5 | 0 | first
 5 | 0 | first
 0 |   | first
   |   | first
   | 0 | first
   |   | first
 8 | 8 | first
 6 | 6 | first
 7 | 7 | first
 4 | 1 | first
(14 rows)

--Testcase 281:
EXPLAIN VERBOSE SELECT t1.i, t2.i, t3.i, t4.i FROM J1_TBL AS t1 LEFT JOIN J2_TBL AS t2 ON t1.i = t2.i RIGHT JOIN J3_TBL AS t3 INNER JOIN J1_TBL AS t4 ON t4.i = t3.i ON t1.i = t3.i;
                                                                                                         QUERY PLAN                                                                                                         
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=16)
   Output: t1.i, t2.i, t3.i, t4.i
   Node: postgres_svr / Status: Alive
     Relations: (((public.j3_tbl t3) INNER JOIN (public.j1_tbl t4)) LEFT JOIN (public.j1_tbl t1)) LEFT JOIN (public.j2_tbl t2)
     Remote SQL: SELECT r1.i, r2.i, r4.i, r5.i FROM (((public.j3_tbl r4 INNER JOIN public.j1_tbl r5 ON (((r4.i = r5.i)))) LEFT JOIN public.j1_tbl r1 ON (((r1.i = r4.i)))) LEFT JOIN public.j2_tbl r2 ON (((r1.i = r2.i))))
(5 rows)

--Testcase 282:
SELECT t1.i, t2.i, t3.i, t4.i FROM J1_TBL AS t1 LEFT JOIN J2_TBL AS t2 ON t1.i = t2.i RIGHT JOIN J3_TBL AS t3 INNER JOIN J1_TBL AS t4 ON t4.i = t3.i ON t1.i = t3.i;
 i | i | i | i 
---+---+---+---
 1 | 1 | 1 | 1
 2 | 2 | 2 | 2
 2 | 2 | 2 | 2
 2 | 2 | 2 | 2
 2 | 2 | 2 | 2
 3 | 3 | 3 | 3
 4 |   | 4 | 4
 5 | 5 | 5 | 5
 5 | 5 | 5 | 5
(9 rows)

--Join  + aggregate functions  + GROUP BY
--Testcase 283:
EXPLAIN VERBOSE SELECT count(*) FROM J1_TBL a INNER JOIN J2_TBL b ON a.i = b.i GROUP BY a.i, b.i;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=58342.85..88752.53 rows=1 width=16)
   Output: (count(*)), a.i, b.i
   Node: postgres_svr / Status: Alive
     Agg push-down: yes
     Relations: Aggregate on ((public.j1_tbl a) INNER JOIN (public.j2_tbl b))
     Remote SQL: SELECT count(*), r1.i, r2.i FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) GROUP BY 2, 3
(6 rows)

--Testcase 284:
SELECT count(*) FROM J1_TBL a INNER JOIN J2_TBL b ON a.i = b.i GROUP BY a.i, b.i;
 count 
-------
     1
     1
     2
     1
     2
(5 rows)

--Testcase 285:
EXPLAIN VERBOSE SELECT count(J1_TBL.i) AS x, J1_TBL.j AS y FROM J1_TBL LEFT JOIN J2_TBL ON J1_TBL.i=J2_TBL.i GROUP BY J1_TBL.j, J1_TBL.i;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=58342.85..87562.76 rows=1 width=16)
   Output: (count(j1_tbl.i)), j1_tbl.j, j1_tbl.i
   Node: postgres_svr / Status: Alive
     Agg push-down: yes
     Relations: Aggregate on ((public.j1_tbl) LEFT JOIN (public.j2_tbl))
     Remote SQL: SELECT count(r1.i), r1.j, r1.i FROM (public.j1_tbl r1 LEFT JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) GROUP BY 2, 3
(6 rows)

--Testcase 286:
SELECT count(J1_TBL.i) AS x, J1_TBL.j AS y FROM J1_TBL LEFT JOIN J2_TBL ON J1_TBL.i=J2_TBL.i GROUP BY J1_TBL.j, J1_TBL.i;
 x | y 
---+---
 0 |  
 1 | 2
 1 | 4
 1 | 7
 1 | 8
 1 | 1
 1 | 6
 1 |  
 2 | 3
 2 | 0
 0 | 0
(11 rows)

--Testcase 287:
EXPLAIN VERBOSE SELECT sum(J1_TBL.i), avg(J1_TBL.j) FROM J1_TBL CROSS JOIN J2_TBL GROUP BY J1_TBL.i;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=29221.42..29315.68 rows=1 width=44)
   Output: (sum(j1_tbl.i)), (avg(j1_tbl.j)), j1_tbl.i
   Node: postgres_svr / Status: Alive
     Agg push-down: yes
     Relations: Aggregate on ((public.j1_tbl) INNER JOIN (public.j2_tbl))
     Remote SQL: SELECT sum(r1.i), avg(r1.j), r1.i FROM (public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (TRUE)) GROUP BY 3
(6 rows)

--Testcase 288:
SELECT sum(J1_TBL.i), avg(J1_TBL.j) FROM J1_TBL CROSS JOIN J2_TBL GROUP BY J1_TBL.i;
 sum |          avg           
-----+------------------------
  64 |     8.0000000000000000
     | 0.00000000000000000000
  24 |     2.0000000000000000
  40 | 0.00000000000000000000
  32 | 1.00000000000000000000
   0 |                       
  48 |     6.0000000000000000
  16 |     3.0000000000000000
  56 |     7.0000000000000000
   8 |     4.0000000000000000
(10 rows)

--Testcase 289:
EXPLAIN VERBOSE SELECT max(J1_TBL.t || '111'), min(J2_TBL.i) FROM J1_TBL RIGHT JOIN J2_TBL USING (i) GROUP BY J1_TBL.i, J2_TBL.i;
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=58342.85..88752.53 rows=1 width=44)
   Output: (max((j1_tbl.t || '111'::text))), (min(j2_tbl.i)), j1_tbl.i, j2_tbl.i
   Node: postgres_svr / Status: Alive
     Agg push-down: yes
     Relations: Aggregate on ((public.j2_tbl) LEFT JOIN (public.j1_tbl))
     Remote SQL: SELECT max((r1.t || '111'::text)), min(r2.i), r1.i, r2.i FROM (public.j2_tbl r2 LEFT JOIN public.j1_tbl r1 ON (((r1.i = r2.i)))) GROUP BY 3, 4
(6 rows)

--Testcase 290:
SELECT max(J1_TBL.t || '111'), min(J2_TBL.i) FROM J1_TBL RIGHT JOIN J2_TBL USING (i) GROUP BY J1_TBL.i, J2_TBL.i;
   max    | min 
----------+-----
          |    
 three111 |   3
 five111  |   5
 one111   |   1
 two111   |   2
 zero111  |   0
(6 rows)

--Testcase 291:
EXPLAIN VERBOSE SELECT t1.i, min(t1.j), max(t2.i), sum(t2.k) FROM J1_TBL t1 FULL JOIN J2_TBL t2 ON t1.i = t2.i GROUP BY t1.i, t1.t;
                                                                        QUERY PLAN                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=58342.85..87562.76 rows=1 width=52)
   Output: t1.i, (min(t1.j)), (max(t2.i)), (sum(t2.k)), t1.t
   Node: postgres_svr / Status: Alive
     Agg push-down: yes
     Relations: Aggregate on ((public.j1_tbl t1) FULL JOIN (public.j2_tbl t2))
     Remote SQL: SELECT r1.i, min(r1.j), max(r2.i), sum(r2.k), r1.t FROM (public.j1_tbl r1 FULL JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) GROUP BY 1, 5
(6 rows)

--Testcase 292:
SELECT t1.i, min(t1.j), max(t2.i), sum(t2.k) FROM J1_TBL t1 FULL JOIN J2_TBL t2 ON t1.i = t2.i GROUP BY t1.i, t1.t;
 i | min | max | sum 
---+-----+-----+-----
   |     |     |   0
 6 |   6 |     |    
 8 |   8 |     |    
   |     |     |    
 4 |   1 |     |    
 7 |   7 |     |    
 3 |   2 |   3 |  -3
   |   0 |     |    
 0 |     |   0 |    
 2 |   3 |   2 |   6
 5 |   0 |   5 | -10
 1 |   4 |   1 |  -1
(12 rows)

--Testcase 293:
EXPLAIN VERBOSE SELECT sum(t1.i + t2.i), avg(t1.i - t2.i) FROM J1_TBL t1 INNER JOIN J2_TBL t2 ON t1.i = t2.i CROSS JOIN J2_TBL t3 GROUP BY t1.i, t2.i;
                                                                                                QUERY PLAN                                                                                                
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=198782929.99..198813383.80 rows=1 width=48)
   Output: (sum((t1.i + t2.i))), (avg((t1.i - t2.i))), t1.i, t2.i
   Node: postgres_svr / Status: Alive
     Agg push-down: yes
     Relations: Aggregate on (((public.j1_tbl t1) INNER JOIN (public.j2_tbl t2)) INNER JOIN (public.j2_tbl t3))
     Remote SQL: SELECT sum((r1.i + r2.i)), avg((r1.i - r2.i)), r1.i, r2.i FROM ((public.j1_tbl r1 INNER JOIN public.j2_tbl r2 ON (((r1.i = r2.i)))) INNER JOIN public.j2_tbl r4 ON (TRUE)) GROUP BY 3, 4
(6 rows)

--Testcase 294:
SELECT sum(t1.i + t2.i), avg(t1.i - t2.i) FROM J1_TBL t1 INNER JOIN J2_TBL t2 ON t1.i = t2.i CROSS JOIN J2_TBL t3 GROUP BY t1.i, t2.i;
 sum |          avg           
-----+------------------------
   0 | 0.00000000000000000000
  16 | 0.00000000000000000000
  64 | 0.00000000000000000000
  48 | 0.00000000000000000000
 160 | 0.00000000000000000000
(5 rows)


DROP USER MAPPING FOR CURRENT_USER SERVER postgres_svr;
DROP USER MAPPING FOR CURRENT_USER SERVER pgspider_core_svr;
DROP SERVER postgres_svr CASCADE;
NOTICE:  drop cascades to 3 other objects
DETAIL:  drop cascades to foreign table j1_tbl__postgres_svr__0
drop cascades to foreign table j2_tbl__postgres_svr__0
drop cascades to foreign table j3_tbl__postgres_svr__0
DROP SERVER pgspider_core_svr CASCADE;
NOTICE:  drop cascades to 3 other objects
DETAIL:  drop cascades to foreign table j1_tbl
drop cascades to foreign table j2_tbl
drop cascades to foreign table j3_tbl
DROP EXTENSION postgres_fdw CASCADE;
DROP EXTENSION pgspider_core_fdw CASCADE;
